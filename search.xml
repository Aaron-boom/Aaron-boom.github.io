<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/04/13/About-Me/</url>
    <content><![CDATA[<blockquote>
<p>A Coder，成都，杭州</p>
</blockquote>
<span id="more"></span>
<p>姓名：荣笙 </br></p>
<p>方向：中间件</br></p>
<p>Email：<a href="mailto:&#55;&#53;&#55;&#50;&#51;&#48;&#x30;&#55;&#x39;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#55;&#53;&#55;&#50;&#51;&#48;&#x30;&#55;&#x39;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a></br></p>
<hr>
<p><strong>想说：</strong>一路走来，有很多的事。但是随着时间，都会慢慢回归平淡。如果你看到了这句话，请相信，生活一定是在慢慢变好的！祝福你，陌生的人~ </p>
]]></content>
  </entry>
  <entry>
    <title>Ambari+HDP生产集群搭建（入门级）</title>
    <url>/2020/05/17/Ambari-HDP%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%EF%BC%88%E5%85%A5%E9%97%A8%E7%BA%A7%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>ambari+HDP的集群搭建。做一个入门级的介绍。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>参考：<br><a href="https://www.rookiegao.top/archives/ambari%E5%85%A5%E9%97%A8#ambari%E7%AE%80%E8%BF%B0">https://www.rookiegao.top/archives/ambari%E5%85%A5%E9%97%A8#ambari%E7%AE%80%E8%BF%B0</a><br><a href="https://www.bilibili.com/video/BV1R4411a7hR?p=4">https://www.bilibili.com/video/BV1R4411a7hR?p=4</a><br><a href="https://blog.csdn.net/z3225167/article/details/92803720">https://blog.csdn.net/z3225167/article/details/92803720</a><br><a href="https://www.cnblogs.com/zhang-ke/p/8944240.html">https://www.cnblogs.com/zhang-ke/p/8944240.html</a><br><a href="https://www.jianshu.com/p/928c5f4832a6">https://www.jianshu.com/p/928c5f4832a6</a></p>
</blockquote>
<h2 id="1-集群节点规划及准备"><a href="#1-集群节点规划及准备" class="headerlink" title="1. 集群节点规划及准备"></a>1. 集群节点规划及准备</h2><blockquote>
<p>采用离线安装的策略，所以yum.hdp这台主机作为提供yum源的主机，上面有Ambari和HDP的安装包文件。nd-00.hdp这台主机作为提供Ambari服务的主机。其他主机就是正常的运算节点了。</p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/%E9%9B%86%E7%BE%A4%E5%87%A0%E7%82%B9%E8%A7%84%E5%88%92HDP+ambari.png"></p>
<ul>
<li>集群开始安装之前，请提前设置好静态的ip和主机名（Hostname）。可以参考下原生Apache Hadoop的搭建。</li>
</ul>
<h3 id="1-0-主机准备："><a href="#1-0-主机准备：" class="headerlink" title="1.0 主机准备："></a>1.0 主机准备：</h3><blockquote>
<p>思路：可先设置一台主机，之后再克隆其他主机，使得基本的环境和软件保持一致。</p>
</blockquote>
<ol>
<li><p>修改主机网卡：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//注意有些网卡是ifcfg-ens33</span><br><span class="line">vim /etc/sysconfig/network-script/ifcfg-eth0</span><br></pre></td></tr></table></figure>
<p> <img src="http://cdn.rongshen2020.com/%E7%BD%91%E5%8D%A1.png"></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service network restart //重启网络</span><br><span class="line">ifconfig //检查是否改过来了</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭防火墙，设置开机不启动：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改hosts文件，称为修改主机映射：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure>
<p> <img src="http://cdn.rongshen2020.com/hosts%E6%96%87%E4%BB%B6.png"></p>
</li>
<li><p>修改本机的name：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br></pre></td></tr></table></figure>

<p> <img src="http://cdn.rongshen2020.com/hostname.png"></p>
</li>
<li><p>设置阿里云开源镜像：</p>
<ul>
<li>配置方法：<a href="https://developer.aliyun.com/mirror/centos">https://developer.aliyun.com/mirror/centos</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">//2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</span><br><span class="line">//2.1 CentOS 6</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">//2.2 CentOS 7</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">//2.3 CentOS 8</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">//3.运行yum makecache生成缓存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装时间同步服务ntp：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y ntp</span><br><span class="line">service ntpd start //启动ntpd服务</span><br><span class="line">chkconfig ntpd on //设置开机自动启动</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装jdk，配置环境：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">tar zxvf jdk-8u141-linux-x64.tar.gz -C /usr/java/</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">	<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭Selinux和THP（如果不关闭THP，Hadoop的系统CPU使用率很高）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sestatus</span><br><span class="line">//设置SELINUX=disabled</span><br><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line"></span><br><span class="line">//如果出现下述结果说明启动了THP</span><br><span class="line">cat /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">	[always] madvise never</span><br><span class="line">cat /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">	[always] madvise never</span><br><span class="line"></span><br><span class="line">//永久关闭</span><br><span class="line">vi /etc/rc.d/rc.local</span><br><span class="line">//增加下列内容</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/enabled;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/defrag;<span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">//重启机器，可等等</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">//检查，如果为下述情况说明已经禁用</span><br><span class="line">cat /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line">	always madvise [never]</span><br><span class="line">cat /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">	always madvise [never]</span><br></pre></td></tr></table></figure></li>
<li><p>克隆剩下的主机：</p>
<ul>
<li>前8步把各主机的环境全部搭建好，接下来就是克隆主机。虽然这是在Vmare虚拟机上这样操作，但是在其他的像Zstack这样的云主机管理，也因像前8点那样，准备好环境。克隆主机时要删除一个文件（记录mac地址的文件，注意这是虚拟机上才有的操作）。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line">//关机再克隆</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>克隆之后，修改配置：</p>
<ol>
<li><p>修改ip地址和删除mac的HWADDR地址：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//注意有些网卡是ifcfg-ens33</span><br><span class="line">vim /etc/sysconfig/network-script/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">//修改好之后重启网卡</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p> <img src="http://cdn.rongshen2020.com/%E5%85%8B%E9%9A%86%E5%90%8E%E4%BF%AE%E6%94%B9ip%E5%9C%B0%E5%9D%80.png"></p>
</li>
<li><p>修改主机名：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.rongshen2020.com/%E4%B8%BB%E6%9C%BA%E5%90%8Dnetwork%E6%96%87%E4%BB%B6.png" alt="主机名network文件"></p>
</li>
<li><p>注意，有个文件记录了网卡的情况，可做参考：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line"></span><br><span class="line">//如有问题，直接删除这个文件</span><br></pre></td></tr></table></figure>

<p> <img src="http://cdn.rongshen2020.com/70-persistent-net%E6%96%87%E4%BB%B6.png" alt="70-persistent-net文件"></p>
</li>
</ol>
</li>
<li><p>重复上述步骤，依次修改克隆的其他主机。</p>
</li>
</ol>
<h3 id="1-1-配置免密登录："><a href="#1-1-配置免密登录：" class="headerlink" title="1.1 配置免密登录："></a>1.1 配置免密登录：</h3><blockquote>
<p>这里不用详细讲解，我在Apache hadoop集群搭建中详细说过这件事。就是将生成的公钥和私钥进行匹配，公钥传给自己和其他主机。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//生成密钥，生成的密钥位于/root/.ssh/目录下</span><br><span class="line">ssh-keygen -t rsa </span><br><span class="line"></span><br><span class="line">ssh-copy-id nd-00.hdp //后面接主机名</span><br></pre></td></tr></table></figure>
<h3 id="1-2-节点操作："><a href="#1-2-节点操作：" class="headerlink" title="1.2 节点操作："></a>1.2 节点操作：</h3><blockquote>
<p>在hdp-nd-00/01/02/03/04节点上都要操作。</p>
</blockquote>
<h4 id="1-2-1-确保节点scp命令可用，若不可用执行"><a href="#1-2-1-确保节点scp命令可用，若不可用执行" class="headerlink" title="1.2.1 确保节点scp命令可用，若不可用执行"></a>1.2.1 确保节点scp命令可用，若不可用执行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y openssh-clients</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-设置每台节点的hostname和hosts："><a href="#1-2-2-设置每台节点的hostname和hosts：" class="headerlink" title="1.2.2 设置每台节点的hostname和hosts："></a>1.2.2 设置每台节点的hostname和hosts：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//修改主机名称</span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">//配置主机映射</span><br><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-安装jdk，配置环境："><a href="#1-2-3-安装jdk，配置环境：" class="headerlink" title="1.2.3 安装jdk，配置环境："></a>1.2.3 安装jdk，配置环境：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">tar zxvf jdk-8u141-linux-x64.tar.gz -C /usr/java/</span><br><span class="line"></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h3 id="1-3-安装MySQL，创建相应的数据库："><a href="#1-3-安装MySQL，创建相应的数据库：" class="headerlink" title="1.3 安装MySQL，创建相应的数据库："></a>1.3 安装MySQL，创建相应的数据库：</h3><h4 id="1-3-1-安装Mysql："><a href="#1-3-1-安装Mysql：" class="headerlink" title="1.3.1 安装Mysql："></a>1.3.1 安装Mysql：</h4><blockquote>
<p>在nd-00.hdp这台主机安装mysql服务。Ambari使用的默认数据库是PostgreSQL，用于存储安装元数据，可以使用自己安装MySQL数据库作为Ambari元数据库。注意：一定要用root用户操作如下步骤；如果有mysql，先卸载MySQL再安装。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list mysql-server</span><br><span class="line"></span><br><span class="line">//安装mysql-server</span><br><span class="line">yum install mysql-server</span><br><span class="line"></span><br><span class="line">//启动mysql服务，设置密码</span><br><span class="line">service mysqld start</span><br><span class="line">/usr/bin/mysqladmin -u root password <span class="string">&#x27;root1111&#x27;</span> <span class="comment">##设置密码，不要全用数字</span></span><br><span class="line">chkconfig mysqld on  <span class="comment">##设置开机自动启动</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line">//在[client]下添加，如果没有[client]请自行添加</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">//在[mysqld]下添加</span><br><span class="line">collation_server-utf8_general_ci</span><br><span class="line">character_set_server=utf-8</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/mysql-conf%E6%96%87%E4%BB%B6.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br><span class="line">mysqld -uroot -p    <span class="comment">##输入密码</span></span><br><span class="line">	Mysql &gt; show variables like <span class="string">&#x27;character_set_%&#x27;</span>;  <span class="comment">##查看编码</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-在数据库创建相应的用户和DB："><a href="#1-3-2-在数据库创建相应的用户和DB：" class="headerlink" title="1.3.2 在数据库创建相应的用户和DB："></a>1.3.2 在数据库创建相应的用户和DB：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//使用root用户登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">//创建ambari数据库及数据库的用户名和密码，一些监控信息要保存在数据库中</span><br><span class="line">create database ambari character <span class="built_in">set</span> utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;Ambari123&#x27;</span>;</span><br><span class="line">CREATE ALL PRIVILEGES ON ambari.* TO <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">//创建hive数据库及hive库的用户名和密码</span><br><span class="line">create database hive character <span class="built_in">set</span> utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;hive&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;Hive123&#x27;</span>;</span><br><span class="line">CREATE ALL PRIVILEGES ON hive.* TO <span class="string">&#x27;hive&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">//创建oozie数据库及oozie库的用户名和密码</span><br><span class="line">create database oozie character <span class="built_in">set</span> utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;oozie&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;Oozie123&#x27;</span>;</span><br><span class="line">CREATE ALL PRIVILEGES ON oozie.* TO <span class="string">&#x27;oozie&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-安装mysql连接的jar包："><a href="#1-3-3-安装mysql连接的jar包：" class="headerlink" title="1.3.3 安装mysql连接的jar包："></a>1.3.3 安装mysql连接的jar包：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-connector-java</span><br><span class="line"></span><br><span class="line">//查看下载后的jar，看目录中是否有mysql-connector-java-5.1.17.jar</span><br><span class="line">ls /usr/share/java</span><br></pre></td></tr></table></figure>

<h2 id="2-本地yum源"><a href="#2-本地yum源" class="headerlink" title="2. 本地yum源"></a>2. 本地yum源</h2><blockquote>
<p>我们将安装包全部下载，并配置成本地YUM源，搭建本地yum源的目的是为了加快搭建安装的速度，因为Ambari和HDP的安装包在墙外，在线安装浪费时间。在yum.hdp主机上进行配置。</p>
</blockquote>
<ul>
<li>Apache Amabri是一种基于web的工具，支持Apache Hadoop集群的创建、管理和监控。</li>
<li>HDP(Hortonworks Data Platform)是由Hortonworks公司为企业准备的Hadoop大数据管理平台，集成了所有关键的Hadoop生态圈项目（组件）。</li>
</ul>
<h3 id="2-1-下载Ambari"><a href="#2-1-下载Ambari" class="headerlink" title="2.1 下载Ambari:"></a>2.1 下载Ambari:</h3><blockquote>
<p>看下迅雷是否可以下载？</p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/ambari%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85.png"></p>
<h3 id="2-2-下载HDP："><a href="#2-2-下载HDP：" class="headerlink" title="2.2 下载HDP："></a>2.2 下载HDP：</h3><h3 id="2-3-设置阿里云开源镜像："><a href="#2-3-设置阿里云开源镜像：" class="headerlink" title="2.3 设置阿里云开源镜像："></a>2.3 设置阿里云开源镜像：</h3><ul>
<li>配置方法：<a href="https://developer.aliyun.com/mirror/centos">https://developer.aliyun.com/mirror/centos</a>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//1.备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">//2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</span><br><span class="line">//2.1 CentOS 6</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">//2.2 CentOS 7</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">//2.3 CentOS 8</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">//3.运行yum makecache生成缓存</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-安装yum相关工具："><a href="#2-4-安装yum相关工具：" class="headerlink" title="2.4 安装yum相关工具："></a>2.4 安装yum相关工具：</h3><blockquote>
<p>在yum.hdp这台主机上。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install yum-utils -y</span><br><span class="line">yum repolist</span><br><span class="line">yum install createrepo -y</span><br></pre></td></tr></table></figure>

<h3 id="2-5-安装-Apache-httpd："><a href="#2-5-安装-Apache-httpd：" class="headerlink" title="2.5 安装 Apache httpd："></a>2.5 安装 Apache httpd：</h3><blockquote>
<p>这个httpd服务的作用主要是，这台主机作为yum源，那么其他主机要从这上面下载需要的东西，需要一个服务器。所以我们使用httpd这个服务。</p>
</blockquote>
<h4 id="2-5-1-安装httpd："><a href="#2-5-1-安装httpd：" class="headerlink" title="2.5.1 安装httpd："></a>2.5.1 安装httpd：</h4><ul>
<li>使用yum在线安装httpd：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br></pre></td></tr></table></figure></li>
<li>安装完httpd后，会生成/var/www/html目录（相当于Tomcat的webapps目录）。进入到/var/www/html目录下，创建ambari和hdp目录，用来存放安装文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html</span><br><span class="line"></span><br><span class="line">mkdir /var/www/html/ambari</span><br><span class="line">mkdir /var/www/html/hdp</span><br><span class="line">mkdir /var/www/html/hdp/HDP-UTILS-1.1.0.21</span><br><span class="line"></span><br><span class="line">tar -zxvf ambari-2.4.1.0-centos6.tar.gz -C /var/www/html/ambari/</span><br><span class="line">tar -zxvf HDP-2.5.0.0-centos6-rpm.tar.gz -C /var/www/html/hdp/</span><br><span class="line">tar -zxvf HDP-UTILS-1.1.0.21-centos6.tar.gz -C /var/www/html/hdp/HDP-UTILS-1.1.0.21</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-启动httpd服务："><a href="#2-5-2-启动httpd服务：" class="headerlink" title="2.5.2 启动httpd服务："></a>2.5.2 启动httpd服务：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure></li>
<li>httpd默认的端口为80，启动后请在浏览器里面输入：<a href="http://youipaddr/">http://youipaddr/</a><h4 id="2-5-3-设置开机自启："><a href="#2-5-3-设置开机自启：" class="headerlink" title="2.5.3 设置开机自启："></a>2.5.3 设置开机自启：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-6-配置本地Repo："><a href="#2-6-配置本地Repo：" class="headerlink" title="2.6 配置本地Repo："></a>2.6 配置本地Repo：</h3><blockquote>
<p>告诉其他节点，若想下载Ambari和HDP都去yum.hdp源主机下载。</p>
</blockquote>
<h4 id="2-6-1-配置Ambari"><a href="#2-6-1-配置Ambari" class="headerlink" title="2.6.1 配置Ambari:"></a>2.6.1 配置Ambari:</h4><blockquote>
<p>主要是配置ambari.repo，让其他主机来yum.hdp下载ambari安装包。</p>
</blockquote>
<ul>
<li>提前下载好ambari.repo文件，或者wget去下载。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;ambari.repo http:&#x2F;&#x2F;public-repo-1.hortonworks.com&#x2F;ambari&#x2F;centos6&#x2F;2.x&#x2F;updates&#x2F;2.4.1.0&#x2F;ambari.repo</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="http://cdn.rongshen2020.com/ambarirepo.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/yum.repos.d/ambari.repo</span><br><span class="line">//这里的ip地址是yum.hdp这台主机的地址</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.rongshen2020.com/ambarirepo%E6%96%87%E4%BB%B6.png"></p>
<h4 id="2-6-2-配置HDP："><a href="#2-6-2-配置HDP：" class="headerlink" title="2.6.2 配置HDP："></a>2.6.2 配置HDP：</h4><blockquote>
<p>主要是配置HDP.repo，让其他主机来yum.hdp下载HDP和UTILS安装包。</p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/ambarirepo1.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch /etc/yum.repos.d/HDP.repo //新建文件，添加以下的内容</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/hdp.repo.png"></p>
<h4 id="2-6-3-配置HDP-UTILS："><a href="#2-6-3-配置HDP-UTILS：" class="headerlink" title="2.6.3 配置HDP-UTILS："></a>2.6.3 配置HDP-UTILS：</h4><ul>
<li>这一步，也是配置HDP.repo文件，我们在上面和HDP一起配置了。</li>
</ul>
<h4 id="2-6-4-分发Ambari-repo和HDP-repo："><a href="#2-6-4-分发Ambari-repo和HDP-repo：" class="headerlink" title="2.6.4 分发Ambari.repo和HDP.repo："></a>2.6.4 分发Ambari.repo和HDP.repo：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line">//没有scp命令时使用yum install openssh-clients</span><br><span class="line"></span><br><span class="line">scp ambari.repo HDP.repo nd-00.hdp:<span class="variable">$PWD</span></span><br><span class="line">scp ambari.repo HDP.repo nd-01.hdp:<span class="variable">$PWD</span></span><br><span class="line">scp ambari.repo HDP.repo nd-02.hdp:<span class="variable">$PWD</span></span><br><span class="line">scp ambari.repo HDP.repo nd-03.hdp:<span class="variable">$PWD</span></span><br><span class="line">scp ambari.repo HDP.repo nd-04.hdp:<span class="variable">$PWD</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-5-生成本地源："><a href="#2-6-5-生成本地源：" class="headerlink" title="2.6.5 生成本地源："></a>2.6.5 生成本地源：</h4><blockquote>
<p>使用createrepo生成本地源，每一台机器都需要。</p>
</blockquote>
<ul>
<li>createrepo用以创建yum源（软件仓库），即为存放于本地特定位置的众多rpm包建立索引，描述各包所需依赖信息，并形成元数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">createrepo /var/www/html/hdp/HDP/centos6</span><br><span class="line">createrepo /var/www/html/hdp/HDP-UTILS-1.1.0.21/</span><br></pre></td></tr></table></figure>

<h2 id="3-安装Ambari-Server"><a href="#3-安装Ambari-Server" class="headerlink" title="3. 安装Ambari-Server"></a>3. 安装Ambari-Server</h2><blockquote>
<p>ambari-server提供了类似安装向导的作用，所以先安装它。</p>
</blockquote>
<h3 id="3-1-nd-00-hdp节点安装："><a href="#3-1-nd-00-hdp节点安装：" class="headerlink" title="3.1 nd-00.hdp节点安装："></a>3.1 nd-00.hdp节点安装：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ambari-server <span class="comment">##安装</span></span><br><span class="line">ambari-server setup <span class="comment">##启动，第一次启动可以设置下它的初始化参数</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/ambari-server%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE1.png"></p>
<p><img src="http://cdn.rongshen2020.com/ambari-server%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE2.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//允许远程登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line">    GRANT ALL PRIVILEGES ON ambari.* TO <span class="string">&#x27;ambari&#x27;</span>@’localhost‘ IDENTIFIED BY <span class="string">&#x27;Ambari123&#x27;</span>;</span><br><span class="line">    GRANT ALL PRIVILEGES ON ambari.* TO <span class="string">&#x27;ambari&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;Ambari123&#x27;</span>;</span><br><span class="line">    FLUSH PRIVILEGES;</span><br><span class="line">    </span><br><span class="line">mysql -u ambari -p Ambari123 -hnd-00</span><br><span class="line">	use ambari;</span><br><span class="line">	<span class="built_in">source</span> /var/lib/ambari-server/resources/Ambari-DDL-Mysql-CREATE.SQL <span class="comment">#执行的ambari里初始化脚本文件</span></span><br><span class="line"></span><br><span class="line">ambari-server start <span class="comment">#启动ambari</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-安装Agent："><a href="#3-2-安装Agent：" class="headerlink" title="3.2 安装Agent："></a>3.2 安装Agent：</h3><ul>
<li>nd-00/01/02/03/04.hdp所有节点安装ambari-agent，代理脚本。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ambari-agent</span><br><span class="line">service ambari-agent start</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-登录Ambari"><a href="#3-3-登录Ambari" class="headerlink" title="3.3 登录Ambari:"></a>3.3 登录Ambari:</h3><p><a href="https://www.bilibili.com/video/BV1R4411a7hR?p=7">https://www.bilibili.com/video/BV1R4411a7hR?p=7</a></p>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>HDP,Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>Ambari2.7.3.0界面汉化</title>
    <url>/2020/06/02/Ambari2-7-3-0%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>主要手段并不是直接修改源码，而是修改编译后的文件，也就是app.js。修改对应的映射关系。</p>
</blockquote>
<span id="more"></span>

<h1 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h1><h2 id="1-1、环境准备："><a href="#1-1、环境准备：" class="headerlink" title="1.1、环境准备："></a>1.1、环境准备：</h2><ul>
<li>Amabri版本号：ambari-2.7.3.0-centos7.tar.gz</li>
</ul>
<h2 id="1-2、汉化文件位置："><a href="#1-2、汉化文件位置：" class="headerlink" title="1.2、汉化文件位置："></a>1.2、汉化文件位置：</h2><p><img src="http://cdn.rongshen2020.com/202062b1.png"></p>
<h2 id="1-3、说明："><a href="#1-3、说明：" class="headerlink" title="1.3、说明："></a>1.3、说明：</h2><ul>
<li>这里的汉化，主要针对的是安装后目录文件的汉化，所以在源码文件和编译文件中，代码并没有改动。个人感觉这也是治标不治本的一种汉化手段。</li>
</ul>
<h1 id="二、汉化登录页面举例"><a href="#二、汉化登录页面举例" class="headerlink" title="二、汉化登录页面举例"></a>二、汉化登录页面举例</h1><p>汉化前的登录界面：<br><img src="http://cdn.rongshen2020.com/202062b2.png"><br>cd /usr/lib/ambari-server/web/javascript<br><img src="http://cdn.rongshen2020.com/202062b3.png"><br>vi app.js<br>/Sign in #搜索关键词，再修改<br><img src="http://cdn.rongshen2020.com/202062b4.png"><br><img src="http://cdn.rongshen2020.com/202062b5.png"></p>
<p>汉化后的登录界面，记得刷新：<br><img src="http://cdn.rongshen2020.com/202062b6.png"></p>
<h1 id="三、app-js文件汉化"><a href="#三、app-js文件汉化" class="headerlink" title="三、app.js文件汉化"></a>三、app.js文件汉化</h1><h2 id="3-1、说明："><a href="#3-1、说明：" class="headerlink" title="3.1、说明："></a>3.1、说明：</h2><p>从上面的代码中，我们可以看到，这种简单的界面汉化，就是先找到编译后的js文件——》找到对应的映射关系——》修改——》刷新界面。</p>
<p>汉化前界面：<br><img src="http://cdn.rongshen2020.com/202062b7.png"></p>
<h2 id="3-2、文件准备："><a href="#3-2、文件准备：" class="headerlink" title="3.2、文件准备："></a>3.2、文件准备：</h2><p>建议汉化前先将其备份，防止汉化失败!<br>cd /usr/lib/ambari-server/web/javascript<br><img src="http://cdn.rongshen2020.com/202062b8.png"><br>汉化的文件：app.js<br>使用xftp软件下载在本地做好备份。<br><img src="http://cdn.rongshen2020.com/202062b9.png"></p>
<h2 id="3-3、汉化："><a href="#3-3、汉化：" class="headerlink" title="3.3、汉化："></a>3.3、汉化：</h2><p>用EditPlus软件打开，直接搜索：Em.I18n.translations<br>一共的代码行有3264行，接下来就是体力活，将对应的英文翻译成中文。<br><img src="http://cdn.rongshen2020.com/202062b10.png"><br><img src="http://cdn.rongshen2020.com/202062b11.png"><br><img src="http://cdn.rongshen2020.com/202062b12.png"></p>
<p>汉化后界面：<br><img src="http://cdn.rongshen2020.com/202062b13.png"><br><img src="http://cdn.rongshen2020.com/202062b14.png"></p>
<h1 id="四、github上项目"><a href="#四、github上项目" class="headerlink" title="四、github上项目"></a>四、github上项目</h1><p>项目地址：<a href="https://github.com/liuwenru/Apache-Ambari-ZH">https://github.com/liuwenru/Apache-Ambari-ZH</a><br>项目说明：<br>注意该项目是基于ambari2.7.4.0汉化的。</p>
<ul>
<li><p>以下是该开源项目的原话，这是本人转载的，未作为盈利目的。<br>当前Ambari的汉化版本为2.7.4.0.0,汉化采用对该版本的ambari源码直接修改的方式进行,如有翻译不当之处,请批评指正</p>
</li>
<li><p>使用方法如下：<br>message.js 因为ambari的前端是一个纯前端的工程，所以如果你要是想使用的话需要重新编译这个包去使用，在ambari-web上brunch build即可，然后把生成public文件夹覆盖到ambari-server的/usr/lib/ambari-server/web目录即可。 或者下载<a href="https://github.com/liuwenru/Apache-Ambari-ZH/releases/download/v0.1/public.tar.gz">https://github.com/liuwenru/Apache-Ambari-ZH/releases/download/v0.1/public.tar.gz</a> 直接使用。<br><img src="http://cdn.rongshen2020.com/202062b15.png"></p>
</li>
</ul>
<p>app-github.js文件上是第65080-68343行：<br><img src="http://cdn.rongshen2020.com/202062b16.png"><br>app.js文件上是第65030-68293行：<br><img src="http://cdn.rongshen2020.com/202062b17.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>ambari的汉化：<a href="https://blog.csdn.net/tancongcong/article/details/94382511">https://blog.csdn.net/tancongcong/article/details/94382511</a></li>
<li>github上已经汉化的项目：<a href="https://github.com/liuwenru/Apache-Ambari-ZH">https://github.com/liuwenru/Apache-Ambari-ZH</a></li>
<li>Ambari各版本兼容的组件查看路径：<a href="https://blog.csdn.net/fengfengchen95/article/details/93326440">https://blog.csdn.net/fengfengchen95/article/details/93326440</a></li>
<li>Ambari二次开发：<a href="https://blog.csdn.net/shirukai/article/details/80841927">https://blog.csdn.net/shirukai/article/details/80841927</a></li>
<li>Ambari多语言处理：<a href="https://blog.csdn.net/shirukai/article/details/80841925">https://blog.csdn.net/shirukai/article/details/80841925</a></li>
<li>Ambari的各版本下载：<a href="https://docs.cloudera.com/HDPDocuments/">https://docs.cloudera.com/HDPDocuments/</a></li>
</ol>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>HDP,Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>CDH平台快速搭建-准备和简介</title>
    <url>/2020/04/24/CDH%E5%B9%B3%E5%8F%B0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-%E5%87%86%E5%A4%87%E5%92%8C%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>说明：该文档主要是帮助大家快速搭建CDH（Cloudera’s Distribution Including Apache Hadoop）大数据分析平台，基于Hadoop的Cloudera发行版本。我们推荐离线安装，那么你就需要准备好离线安装包，关于安装包内的文件，我只是给出了一个大概，其中有些文件需要看你的配置情况。基本上我给出的是需要的。关于这些安装包和依赖包的版本号，请适配你所安装的CDH。</p>
</blockquote>
<span id="more"></span>

<h1 id="0、离线安装包准备："><a href="#0、离线安装包准备：" class="headerlink" title="0、离线安装包准备："></a>0、离线安装包准备：</h1><blockquote>
<p>这里面各种包的版本号，请自行百度。</p>
</blockquote>
<h2 id="0-1、Cloudera-Manager"><a href="#0-1、Cloudera-Manager" class="headerlink" title="0.1、Cloudera Manager"></a>0.1、Cloudera Manager</h2><ul>
<li><p>cloudera-manager-centos7-cm5.7.6_x86 _64.tar.gz</p>
<h2 id="0-2、CDH安装包"><a href="#0-2、CDH安装包" class="headerlink" title="0.2、CDH安装包"></a>0.2、CDH安装包</h2></li>
<li><p>CDH-5.7.x-x.cdhx.x.0.px.x-ex.parcel</p>
</li>
<li><p>CDH-5.7.x-x.cdhx.x.0.px.x-ex.parcel.sha1</p>
</li>
<li><p>manifest.json</p>
<h2 id="0-3、mysql数据库包"><a href="#0-3、mysql数据库包" class="headerlink" title="0.3、mysql数据库包"></a>0.3、mysql数据库包</h2></li>
<li><p>compat-db47-4.7.25-28.el7.x86_64.rpm</p>
</li>
<li><p>compat-db-headers-4.7.25-28.el7.noarch.rpm</p>
</li>
<li><p>net-tools-2.0-0.24.20131004git.el7.x86_64.rpm</p>
</li>
<li><p>cyrus-sasl-lib-2.1.23-15.el6_6.2.x86_64.rpm</p>
</li>
<li><p>mysql-community-client-5.7.20-1.el6.x86_64.rpm</p>
</li>
<li><p>mysql-community-common-5.7.20-1.el6.x86_64.rpm</p>
</li>
<li><p>mysql-community-libs-5.7.20-1.el6.x86_64.rpm</p>
</li>
<li><p>mysql-community-server-5.7.20-1.el6.x86_64.rpm</p>
<h2 id="0-4、jdk安装包"><a href="#0-4、jdk安装包" class="headerlink" title="0.4、jdk安装包"></a>0.4、jdk安装包</h2></li>
<li><p>jdk-8u144-linux-x64.tar.gz</p>
<h2 id="0-5、ntp服务所需软件包"><a href="#0-5、ntp服务所需软件包" class="headerlink" title="0.5、ntp服务所需软件包"></a>0.5、ntp服务所需软件包</h2></li>
<li><p>autogen-libopts-5.18-5.el7.x86_64.rpm</p>
</li>
<li><p>ntp-4.2.6p5-28.el7.centos.x86_64.rpm</p>
</li>
<li><p>ntpdate-4.2.6p5-28.el7.centos.x86_64.rpm</p>
<h2 id="0-6、CM安装部署时用的两个依赖包"><a href="#0-6、CM安装部署时用的两个依赖包" class="headerlink" title="0.6、CM安装部署时用的两个依赖包"></a>0.6、CM安装部署时用的两个依赖包</h2></li>
<li><p>libxslt-1.1.28-5.el7.x86_64.rpm</p>
</li>
<li><p>psmisc-22.20-15.el7.x86_64.rpm</p>
<h2 id="0-7、拷贝到了指定文件夹下"><a href="#0-7、拷贝到了指定文件夹下" class="headerlink" title="0.7、拷贝到了指定文件夹下"></a>0.7、拷贝到了指定文件夹下</h2></li>
<li><p>parcel.json（json文件）</p>
<blockquote>
<p>拷贝到/opt/cloudera/parcels/CDH-5.7.6-1.cdh5.7.6.p0.6/meta文件夹下，parcel.json是一个重要的描述性文件，这个文件记录了你的服务信息，如版本、所属用户、适用的CDH平台版本等。</p>
</blockquote>
</li>
<li><p>mysql-connection-java-xxx.bin.jar（jdbc）</p>
<h2 id="0-8、各种依赖包"><a href="#0-8、各种依赖包" class="headerlink" title="0.8、各种依赖包"></a>0.8、各种依赖包</h2></li>
<li><p>在perl文件夹下。</p>
<h2 id="0-9、便于快速安装的脚本文件"><a href="#0-9、便于快速安装的脚本文件" class="headerlink" title="0.9、便于快速安装的脚本文件"></a>0.9、便于快速安装的脚本文件</h2><blockquote>
<p>方便你快速搭建开发环境，强烈建议编写脚本文件。在之后的平台搭建时，具有很高的复制性。</p>
</blockquote>
<h1 id="1、环境准备："><a href="#1、环境准备：" class="headerlink" title="1、环境准备："></a>1、环境准备：</h1><h2 id="1-1、云主机准备"><a href="#1-1、云主机准备" class="headerlink" title="1.1、云主机准备"></a>1.1、云主机准备</h2><h3 id="云主机要求："><a href="#云主机要求：" class="headerlink" title="云主机要求："></a>云主机要求：</h3></li>
<li><p>这里主要使用Zstack进行物理机管理和配置。配置信息，主要看你对于数据平台的要求，使用Zstack的好处，就不言而喻了。</p>
<h2 id="1-2、快速安装包准备"><a href="#1-2、快速安装包准备" class="headerlink" title="1.2、快速安装包准备"></a>1.2、快速安装包准备</h2><h3 id="在云主机中操作："><a href="#在云主机中操作：" class="headerlink" title="在云主机中操作："></a>在云主机中操作：</h3><blockquote>
<p>CDH-QuickInstallation.tar压缩文件包是之前准备好的，里面有快速部署CDH的各种安装包和依赖文件，方便离线安装，请在安装之前制作好。关于怎么把安装包文件（CDH-QuickInstallation.tar）快速的导入到云主机中，推荐scp命令或者百度。</p>
</blockquote>
<p>  在tmp文件夹下创建cdh文件夹<br>  $ mkdir /tmp/cdh</p>
<p>  把CDH-5.7.6-QuickInstallation.tar解压到该目录<br>  $ tar -xvf CDH-QuickInstallation.tar -C /tmp/cdh</p>
<p>  再进入该文件夹<br>  $ cd /tmp/cdh</p>
</li>
</ul>
<h1 id="2、第一步安装（所有节点）："><a href="#2、第一步安装（所有节点）：" class="headerlink" title="2、第一步安装（所有节点）："></a>2、第一步安装（所有节点）：</h1><blockquote>
<p>你可以根据以下内容去写脚本文件。</p>
</blockquote>
<pre><code>#卸载自带的openjdk，安装jdk
#配置java的环境变量，将配置信息添加到profile文件中
#让配置信息生效

#修改hosts文件，配置网络，这一步往往很容易出错,网卡信息是关键
#重启云主机网络服务

#主节点的配置信息

#关闭selinux

#关闭防火墙

#配置网络时间同步协议(NTP)服务

#配置好之后，启动下网络服务

#产生SSH密钥，修改文件权限，集群节点之间相互访问

#卸载mariadb，安装mysql并启动
#mysql登录使用交互式设置密码

#CM安装部署
#在所有的节点创建用户
#解压cm安装包到指定的文件夹
#主节点的配置信息修改
#安装相应的依赖
#创建用户cloudera-scm
#配置cm-agent
#
</code></pre>
<h1 id="3、第二步安装："><a href="#3、第二步安装：" class="headerlink" title="3、第二步安装："></a>3、第二步安装：</h1><pre><code>#获取IP，之后通过看有几个节点，配置server-agent的节点信息

#网络服务启动

#从节点的ntp服务的配置和启动

#主节点的cloudera-scm-server服务启动

#主、从节点的cloudera-scm-agent服务启动
</code></pre>
<h1 id="4、说明："><a href="#4、说明：" class="headerlink" title="4、说明："></a>4、说明：</h1><ul>
<li>由于不是个人劳动成果，所以源码不上传和分享。而且本人处于接触阶段。上述方法只是本人对于快速搭建CDH平台的一些理解。之后，会写出更好的博客，共勉。</li>
</ul>
<h1 id="没有照片，没有解释，唉，好差劲的博客。可能是云游这么久之后的心理安慰，以后不可有"><a href="#没有照片，没有解释，唉，好差劲的博客。可能是云游这么久之后的心理安慰，以后不可有" class="headerlink" title="没有照片，没有解释，唉，好差劲的博客。可能是云游这么久之后的心理安慰，以后不可有~"></a>没有照片，没有解释，唉，好差劲的博客。可能是云游这么久之后的心理安慰，以后不可有~</h1>]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>CDH</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端开发学习路线-2020flag</title>
    <url>/2020/04/14/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-2020flag/</url>
    <content><![CDATA[<blockquote>
<p>整理自B站up主codesheep程序羊，语言只是一种手段，思想才是灵魂。</p>
</blockquote>
<span id="more"></span>

<h2 id="1、Java必读书籍推荐"><a href="#1、Java必读书籍推荐" class="headerlink" title="1、Java必读书籍推荐"></a>1、Java必读书籍推荐</h2><ul>
<li><input disabled="" type="checkbox"> 《java编程思想》 </li>
<li><input disabled="" type="checkbox"> 《java并发编程实战》 </li>
<li><input disabled="" type="checkbox"> 《深入理解java虚拟机》</li>
<li><input disabled="" type="checkbox"> 《函数式编程思维》</li>
<li><input disabled="" type="checkbox"> 《tcp/ip详解》</li>
<li><input disabled="" type="checkbox"> 《鸟哥的linux私房菜》 </li>
<li><input disabled="" type="checkbox"> 《spring mvc＋mybatis开发从入门到精通》 </li>
<li><input disabled="" type="checkbox"> 《spring技术内幕》</li>
<li><input disabled="" type="checkbox"> 《elasticsearch服务器开发》 </li>
<li><input disabled="" type="checkbox"> 《redis入门指南》</li>
</ul>
<h2 id="2、编程基础"><a href="#2、编程基础" class="headerlink" title="2、编程基础"></a><font color=#B22222>2、编程基础</font></h2><h3 id="2-1、java语言："><a href="#2-1、java语言：" class="headerlink" title="2.1、java语言："></a>2.1、java语言：</h3><h4 id="2-1-1、语言基础："><a href="#2-1-1、语言基础：" class="headerlink" title="2.1.1、语言基础："></a>2.1.1、语言基础：</h4><ul>
<li>基础语法、面向对象、接口、容器、异常、泛型、反射、注解、I/O、图形化（如Swing） </li>
</ul>
<h4 id="2-1-2、JVM："><a href="#2-1-2、JVM：" class="headerlink" title="2.1.2、JVM："></a>2.1.2、JVM：</h4><ul>
<li>类加载机制、字节码执行机制、JVM内存模型、GC垃圾回收、JVM性能监控与故障定位、JVM调优</li>
</ul>
<h4 id="2-1-3、并发-多线程："><a href="#2-1-3、并发-多线程：" class="headerlink" title="2.1.3、并发/多线程："></a>2.1.3、并发/多线程：</h4><ul>
<li>并发编程基础、线程池、锁、并发容器、原子类、JUC并发工具类</li>
</ul>
<h3 id="2-2、数据结构和算法："><a href="#2-2、数据结构和算法：" class="headerlink" title="2.2、数据结构和算法："></a>2.2、数据结构和算法：</h3><h4 id="2-2-1、数据结构："><a href="#2-2-1、数据结构：" class="headerlink" title="2.2.1、数据结构："></a>2.2.1、数据结构：</h4><ul>
<li>字符串、数组、链表、二叉树、堆/栈/队列、哈希</li>
</ul>
<h4 id="2-2-2、算法："><a href="#2-2-2、算法：" class="headerlink" title="2.2.2、算法："></a>2.2.2、算法：</h4><ul>
<li>查找、排序、贪心、分治、动态规划、回溯</li>
</ul>
<h3 id="2-3、计算机网络："><a href="#2-3、计算机网络：" class="headerlink" title="2.3、计算机网络："></a>2.3、计算机网络：</h3><ul>
<li>ARP协议、IP/ICMP协议、TCP/UDP协议、DNS/HTTP/HTTPS协议、Session/Cookie</li>
</ul>
<h3 id="2-4、数据库-SQL："><a href="#2-4、数据库-SQL：" class="headerlink" title="2.4、数据库/SQL："></a>2.4、数据库/SQL：</h3><ul>
<li>SQL语言书写、SQL语句优化、事务以及隔离级别、索引、锁</li>
</ul>
<h3 id="2-5、操作系统："><a href="#2-5、操作系统：" class="headerlink" title="2.5、操作系统："></a>2.5、操作系统：</h3><ul>
<li>进程/线程、并发/锁、内存管理和调度、I/O原理</li>
</ul>
<h3 id="2-6、设计模式："><a href="#2-6、设计模式：" class="headerlink" title="2.6、设计模式："></a>2.6、设计模式：</h3><ul>
<li>单例、工厂、代理、策略、模板方法、观察者、适配器、责任链、建造者</li>
</ul>
<h2 id="3、研发工具"><a href="#3、研发工具" class="headerlink" title="3、研发工具"></a><font color=#B22222>3、研发工具</font></h2><h3 id="3-1、集成开发环境："><a href="#3-1、集成开发环境：" class="headerlink" title="3.1、集成开发环境："></a>3.1、集成开发环境：</h3><ul>
<li>Eclipse、Intellij IDEA、VS Code</li>
</ul>
<h3 id="3-2、Linux系统："><a href="#3-2、Linux系统：" class="headerlink" title="3.2、Linux系统："></a>3.2、Linux系统：</h3><ul>
<li>Linux常用命令、基本Shell脚本</li>
</ul>
<h3 id="3-3、代码管理工具："><a href="#3-3、代码管理工具：" class="headerlink" title="3.3、代码管理工具："></a>3.3、代码管理工具：</h3><ul>
<li>Git、SVN</li>
</ul>
<h3 id="3-4、项目管理-构建工具："><a href="#3-4、项目管理-构建工具：" class="headerlink" title="3.4、项目管理/构建工具："></a>3.4、项目管理/构建工具：</h3><ul>
<li>Maven、Gradle</li>
</ul>
<h2 id="4、应用框架"><a href="#4、应用框架" class="headerlink" title="4、应用框架"></a>4、应用框架</h2><h3 id="4-1、后端："><a href="#4-1、后端：" class="headerlink" title="4.1、后端："></a>4.1、后端：</h3><h4 id="4-1-1、Spring家族："><a href="#4-1-1、Spring家族：" class="headerlink" title="4.1.1、Spring家族："></a><font color=#B22222>4.1.1、Spring家族：</font></h4><ol>
<li>Spring：<ul>
<li>IOC、AOP</li>
</ul>
</li>
<li>Spring MVC：</li>
<li>Spring boot：<ol>
<li>自动配置、开箱即用</li>
<li>整合web</li>
<li>整合数据库（事务问题）</li>
<li>整合权限：<ul>
<li>Shiro、Spring Security</li>
</ul>
</li>
<li>整合各种中间件：<ul>
<li>缓存、MQ、RPC框架、NIQ框架等</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="4-1-2、服务器软件："><a href="#4-1-2、服务器软件：" class="headerlink" title="4.1.2、服务器软件："></a><font color=#B22222>4.1.2、服务器软件：</font></h4><ol>
<li>Web服务器：<ul>
<li>Nginx</li>
</ul>
</li>
<li>应用服务器：<ul>
<li>Tomcat、Jetty、Undertow</li>
</ul>
</li>
</ol>
<h4 id="4-1-3、中间件："><a href="#4-1-3、中间件：" class="headerlink" title="4.1.3、中间件："></a>4.1.3、中间件：</h4><ol>
<li>缓存：<ol>
<li><font color=#B22222>Redis：</font><ul>
<li>5大数据类型、事务、消息通知、管道、持久化、集群</li>
</ul>
</li>
<li>memcache</li>
</ol>
</li>
<li><font color=#B22222>消息队列：</font><ul>
<li>RocketMQ、RabbitMQ、Kafka</li>
</ul>
</li>
<li>RPC框架：<ul>
<li>Dubbo、gRPC、Thrift、Spring Cloud、Netty</li>
</ul>
</li>
</ol>
<h4 id="4-1-4、数据库："><a href="#4-1-4、数据库：" class="headerlink" title="4.1.4、数据库："></a><font color=#B22222>4.1.4、数据库：</font></h4><ol>
<li>ORM框架：<ul>
<li>MyBatis、Hibernate、 JPA</li>
</ul>
</li>
<li>连接池：<ul>
<li>Druid、HikariCP、 C3P0</li>
</ul>
</li>
<li>分库分表：<ul>
<li>MyCat、Sharding-JDBC、 Sharding-Sphere</li>
</ul>
</li>
</ol>
<h4 id="4-1-5、搜索引擎："><a href="#4-1-5、搜索引擎：" class="headerlink" title="4.1.5、搜索引擎："></a>4.1.5、搜索引擎：</h4><ul>
<li>ElestaicSearch、Solr</li>
</ul>
<h4 id="4-1-6、分布式-微服务："><a href="#4-1-6、分布式-微服务：" class="headerlink" title="4.1.6、分布式/微服务："></a>4.1.6、分布式/微服务：</h4><ol>
<li>服务发现/注册：<ul>
<li>Eureka、Consul、Zookeeper、Nacos</li>
</ul>
</li>
<li>网关：<ul>
<li>Zuul、Gateway</li>
</ul>
</li>
<li>服务调用（负载均衡）：<ul>
<li>Ribbon、Feign</li>
</ul>
</li>
<li>熔断/降级：<ul>
<li>Hystrix</li>
</ul>
</li>
<li>配置中心：<ul>
<li>Config、Apollo、Nacos</li>
</ul>
</li>
<li>认证和鉴权：<ul>
<li>Shiro、Spring Security、OAuth2、SSO</li>
</ul>
</li>
<li>分布式事务：<ol>
<li>JTA接口：<ul>
<li>Atomikos组件</li>
</ul>
</li>
<li>2PC、3PC</li>
<li>XA模式</li>
<li>TCC模式：<ul>
<li>tcc-transaction、ByteTCC、EasyTransaction、seata</li>
</ul>
</li>
<li>SAGA模式：<ul>
<li>ServiceComb、Seata</li>
</ul>
</li>
<li>LCN模式：<ul>
<li>tx-lcn</li>
</ul>
</li>
</ol>
</li>
<li>任务调度：<ul>
<li>Quartz、Elestic-Job</li>
</ul>
</li>
<li>链路追踪与监控：<ul>
<li>Zipkin、Sleuth、Skywalking</li>
</ul>
</li>
<li>日志分析与监控：<ol>
<li>ELK：<ul>
<li>ElasticSearch、Logstash、Kibana</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="4-1-7、虚拟化-容器化："><a href="#4-1-7、虚拟化-容器化：" class="headerlink" title="4.1.7、虚拟化/容器化："></a>4.1.7、虚拟化/容器化：</h4><ol>
<li>容器技术：<ul>
<li>Docker</li>
</ul>
</li>
<li>容器编排技术：<ul>
<li>Kubernetes、Swarm</li>
</ul>
</li>
</ol>
<h3 id="4-2、前端："><a href="#4-2、前端：" class="headerlink" title="4.2、前端："></a>4.2、前端：</h3><h4 id="4-2-1、基础套餐："><a href="#4-2-1、基础套餐：" class="headerlink" title="4.2.1、基础套餐："></a>4.2.1、基础套餐：</h4><ol>
<li>三大件：<ul>
<li>HTML、JavaScript、CSS</li>
</ul>
</li>
<li>基础库：<ul>
<li>jQuery、Ajax</li>
</ul>
</li>
</ol>
<h4 id="4-2-2、模板框架："><a href="#4-2-2、模板框架：" class="headerlink" title="4.2.2、模板框架："></a>4.2.2、模板框架：</h4><ul>
<li>JSP/JSTL、Thymeleaf、FreeMarker</li>
</ul>
<h4 id="4-2-3、组件化框架："><a href="#4-2-3、组件化框架：" class="headerlink" title="4.2.3、组件化框架："></a>4.2.3、组件化框架：</h4><ul>
<li>Node、Vue、React、Angular</li>
</ul>
<h2 id="5、运维知识"><a href="#5、运维知识" class="headerlink" title="5、运维知识"></a>5、运维知识</h2><h3 id="5-1、Web服务器："><a href="#5-1、Web服务器：" class="headerlink" title="5.1、Web服务器："></a>5.1、Web服务器：</h3><ul>
<li>Nginx</li>
</ul>
<h3 id="5-2、应用服务器："><a href="#5-2、应用服务器：" class="headerlink" title="5.2、应用服务器："></a>5.2、应用服务器：</h3><ul>
<li>Tomcat、Jetty、Undertow</li>
</ul>
<h3 id="5-3、CDN加速"><a href="#5-3、CDN加速" class="headerlink" title="5.3、CDN加速"></a>5.3、CDN加速</h3><h3 id="5-4、持续集成-持续发布："><a href="#5-4、持续集成-持续发布：" class="headerlink" title="5.4、持续集成/持续发布："></a>5.4、持续集成/持续发布：</h3><ul>
<li>Jenkins</li>
</ul>
<h3 id="5-5、代码质量检查："><a href="#5-5、代码质量检查：" class="headerlink" title="5.5、代码质量检查："></a>5.5、代码质量检查：</h3><ul>
<li>Sonar</li>
</ul>
<h3 id="5-6、日志收集-分析："><a href="#5-6、日志收集-分析：" class="headerlink" title="5.6、日志收集/分析："></a>5.6、日志收集/分析：</h3><ul>
<li>ELK</li>
</ul>
<h2 id="6、成神之路"><a href="#6、成神之路" class="headerlink" title="6、成神之路"></a>6、成神之路</h2><ul>
<li>徒手撕源码、光脚造轮子、闭眼深度调优、吊打面试官</li>
</ul>
<h2 id="7、平稳降落"><a href="#7、平稳降落" class="headerlink" title="7、平稳降落"></a>7、平稳降落</h2><ul>
<li>调整心态、注意健康，飞的多高不重要，重要的是如何平稳降落</li>
</ul>
<h2 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h2><ul>
<li>LeetCode</li>
<li>英语</li>
<li>算法类知识</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>plan</tag>
      </tags>
  </entry>
  <entry>
    <title>eureka、zookeeper、consul与CAP理论</title>
    <url>/2020/09/25/eureka%E3%80%81zookeeper%E3%80%81consul%E4%B8%8ECAP%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>比较eureka、zookeeper、consul三种微服务注册中心。笔记整理自尚硅谷周阳老师。</p>
</blockquote>
<span id="more"></span>


<h2 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h2><p>CAP原则又称CAP定理，指的是在一个<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<p>一致性（C）：在<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
<p>可用性（A）：在集群中一部分节点故障后，<a href="https://baike.baidu.com/item/%E9%9B%86%E7%BE%A4/5486962">集群</a>整体是否还能响应<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081">客户端</a>的读写请求。（对数据更新具备高可用性）</p>
<p>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p>
<p>CAP原则的精髓就是要么AP，要么CP，要么AC，但是不存在CAP。</p>
<h2 id="三个注册中心的异同："><a href="#三个注册中心的异同：" class="headerlink" title="三个注册中心的异同："></a>三个注册中心的异同：</h2><p><img src="http://cdn.rongshen2020.com/2020925b1.png"></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求。因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：</p>
<ul>
<li>CA：单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP：满足一致性，分区容忍性的系统，通常性能不是特别高。</li>
<li>AP：满足可用性，分区容忍性的系统，通常可能对一致性要求低一点。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020925b2.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020925b3.png"></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>hdp和ambari版本速查</title>
    <url>/2020/06/02/hdp%E5%92%8Cambari%E7%89%88%E6%9C%AC%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<blockquote>
<p>怎么查看这个hdp，ambari版本是不是适配的？该hdp版本里面各组件是不是有？以及这些组件是什么版本的？怎么下载指定版本的ambari，hdp，hdp-utils？</p>
</blockquote>
<span id="more"></span>


<ul>
<li><p>网址1：<a href="https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.0/index.html">https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.0/index.html</a><br><img src="http://cdn.rongshen2020.com/202062a1.png"></p>
</li>
<li><p>网址2：<br><a href="https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.0/release-notes/content/comp_versions.html">https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.0/release-notes/content/comp_versions.html</a><br><img src="http://cdn.rongshen2020.com/202062a2.png"></p>
</li>
<li><p>网址3：<a href="https://supportmatrix.hortonworks.com/">https://supportmatrix.hortonworks.com/</a><br><img src="http://cdn.rongshen2020.com/202062a3.png"></p>
</li>
<li><p>网址4：<a href="https://docs.cloudera.com/HDPDocuments/index.html">https://docs.cloudera.com/HDPDocuments/index.html</a><br><img src="http://cdn.rongshen2020.com/202062a4.png"></p>
</li>
</ul>
<ul>
<li>网址5：<br><a href="https://docs.cloudera.com/HDPDocuments/Ambari-2.7.4.0/bk_ambari-installation/content/hdp_314_repositories.html">https://docs.cloudera.com/HDPDocuments/Ambari-2.7.4.0/bk_ambari-installation/content/hdp_314_repositories.html</a><br><img src="http://cdn.rongshen2020.com/202062a5.png"></li>
</ul>
<h1 id="查询ambari-hdp-hdp-utils步骤"><a href="#查询ambari-hdp-hdp-utils步骤" class="headerlink" title="查询ambari+hdp+hdp-utils步骤"></a>查询ambari+hdp+hdp-utils步骤</h1><ul>
<li>网址：<a href="https://docs.cloudera.com/HDPDocuments/Ambari/Ambari-2.7.4.0/index.html">https://docs.cloudera.com/HDPDocuments/Ambari/Ambari-2.7.4.0/index.html</a></li>
</ul>
<h2 id="1-选择ambari的版本："><a href="#1-选择ambari的版本：" class="headerlink" title="1.选择ambari的版本："></a>1.选择ambari的版本：</h2><p><img src="http://cdn.rongshen2020.com/202062a6.png"></p>
<h2 id="2-选择Installation："><a href="#2-选择Installation：" class="headerlink" title="2.选择Installation："></a>2.选择Installation：</h2><p><img src="http://cdn.rongshen2020.com/202062a7.png"></p>
<h2 id="3-选择安装amabri："><a href="#3-选择安装amabri：" class="headerlink" title="3.选择安装amabri："></a>3.选择安装amabri：</h2><p><img src="http://cdn.rongshen2020.com/202062a8.png"></p>
<h2 id="4-查找你需要下载的ambari和hdp和hdp-utils的版本："><a href="#4-查找你需要下载的ambari和hdp和hdp-utils的版本：" class="headerlink" title="4.查找你需要下载的ambari和hdp和hdp-utils的版本："></a>4.查找你需要下载的ambari和hdp和hdp-utils的版本：</h2><p><img src="http://cdn.rongshen2020.com/202062a9.png"><br><img src="http://cdn.rongshen2020.com/202062a10.png"></p>
<p><img src="http://cdn.rongshen2020.com/202062a11.png"></p>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>HDP,Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>java代理模式</title>
    <url>/2021/01/11/java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是一种比较好的理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理模式分为静态代理与动态代理。</p>
<p><img src="http://cdn.rongshen2020.com/20210111a1.png"></p>
<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">        SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send()</span><br><span class="line">send message:java</span><br><span class="line">after method send()</span><br></pre></td></tr></table></figure>

<p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h2 id="JDK动态代理："><a href="#JDK动态代理：" class="headerlink" title="JDK动态代理："></a>JDK动态代理：</h2><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<h3 id="JDK动态代理类使用步骤："><a href="#JDK动态代理类使用步骤：" class="headerlink" title="JDK动态代理类使用步骤："></a>JDK动态代理类使用步骤：</h3><ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<p><strong>代码示例：</strong></p>
<p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类，实现InvocationHandler接口并重写invoke方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类，Proxy.newProxyInstance创建代理对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> DebugInvocationHandler(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> SmsServiceImpl());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>



<h2 id="CGLIB动态代理："><a href="#CGLIB动态代理：" class="headerlink" title="CGLIB动态代理："></a>CGLIB动态代理：</h2><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Callback</span></span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">                               MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>methodProxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h3 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h3><ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliSmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器），实现该接口的intercept方法类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DebugMethodInterceptor());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.实际使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行上述代码之后，控制台打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>



<h2 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h2><ol>
<li><strong>JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ol>
<h1 id="静态代理与动态代理的对比"><a href="#静态代理与动态代理的对比" class="headerlink" title="静态代理与动态代理的对比"></a>静态代理与动态代理的对比</h1><ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
      <categories>
        <category>java理论</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射机制</title>
    <url>/2021/01/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h2 id="反射机制介绍："><a href="#反射机制介绍：" class="headerlink" title="反射机制介绍："></a>反射机制介绍：</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<h2 id="获取Class对象的四种方式："><a href="#获取Class对象的四种方式：" class="headerlink" title="获取Class对象的四种方式："></a>获取Class对象的四种方式：</h2><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象:</p>
<p><strong>1.知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取Class对象不会进行初始化</p>
<p><strong>2.通过 <code>Class.forName()</code>传入类的路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Class.forName(className)方法，内部实际调用的是一个native方法 forName0(className, true, ClassLoader.getClassLoader(caller), caller);</p>
<p>第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。</p>
<p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也会被再次初始化。</p>
<p><strong>3.通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">Class alunbarClass2 = e.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4.通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clazz</span> </span>= ClassLoader.LoadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一些列步骤，静态块和静态对象不会得到执行</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用反射操作这个类的方法以及参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取TargetObject类的Class对象并且创建TargetObject类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; tagetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        TargetObject targetObject = (TargetObject) tagetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取所有类中所有定义的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = tagetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method publicMethod = tagetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = tagetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查，这就是反射机制的安全隐患？</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method privateMethod = tagetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure>





<h2 id="静态编译和动态编译："><a href="#静态编译和动态编译：" class="headerlink" title="静态编译和动态编译："></a>静态编译和动态编译：</h2><ul>
<li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li>
</ul>
<h2 id="反射机制优缺点："><a href="#反射机制优缺点：" class="headerlink" title="反射机制优缺点："></a>反射机制优缺点：</h2><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>
</ul>
<h2 id="反射的应用场景："><a href="#反射的应用场景：" class="headerlink" title="反射的应用场景："></a>反射的应用场景：</h2><p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>java理论</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识疑难点梳理</title>
    <url>/2020/12/31/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%96%91%E9%9A%BE%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h1 id="与equals比较"><a href="#与equals比较" class="headerlink" title="==与equals比较"></a>==与equals比较</h1><ul>
<li><p>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">str.equals(<span class="string">&quot;SnailClimb&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码会抛出空指针异常。</p>
</li>
<li><p><code>==</code>是比较两个对象是否是同一个对象。<code>equals</code>比较的是两个对象是不是相等。</p>
</li>
</ul>
<h2 id="整形包装值的比较"><a href="#整形包装值的比较" class="headerlink" title="整形包装值的比较"></a>整形包装值的比较</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。</p>
<p>IDE(IDEA/Eclipse)上阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，很不错。</p>
<h1 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h1><p>Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。</p>
<p>阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如何解决以上代码出现的这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b); </span><br><span class="line">BigDecimal y = b.subtract(c); </span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>



<h2 id="BigDecimal的大小比较"><a href="#BigDecimal的大小比较" class="headerlink" title="BigDecimal的大小比较"></a>BigDecimal的大小比较</h2><p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1表示 <code>a</code> 大于 <code>b</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<h2 id="BigDecimal保留几位小数"><a href="#BigDecimal保留几位小数" class="headerlink" title="BigDecimal保留几位小数"></a>BigDecimal保留几位小数</h2><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure>



<h2 id="BigDecimal使用注意"><a href="#BigDecimal使用注意" class="headerlink" title="BigDecimal使用注意"></a>BigDecimal使用注意</h2><p>我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p>
<p><img src="http://cdn.rongshen2020.com/20201231a1.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p>
<p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p>
<h1 id="基本数据类型与包装数据类型的使用标准"><a href="#基本数据类型与包装数据类型的使用标准" class="headerlink" title="基本数据类型与包装数据类型的使用标准"></a>基本数据类型与包装数据类型的使用标准</h1><p>来源：《阿里巴巴开发手册》</p>
<ul>
<li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li>
<li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li>
<li>【推荐】所有的局部变量使用基本数据类型。</li>
</ul>
<p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p>
<p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p>
<p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p>
<p>NPE风险：<strong>NPE，指为基本类型的数据返回null值</strong>。例：下面的方法就会发生NPE错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Integer 对象；</span><br><span class="line"> &#125; </span><br><span class="line">如果为<span class="keyword">null</span>，自动解箱（拆箱）抛NPE。</span><br></pre></td></tr></table></figure>



<p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p>
<h1 id="集合List"><a href="#集合List" class="headerlink" title="集合List"></a>集合List</h1><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>将一个数组转换为一个List集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p>
<p><img src="http://cdn.rongshen2020.com/20201231a2.png"></p>
<h2 id="使用时注意事项"><a href="#使用时注意事项" class="headerlink" title="使用时注意事项"></a>使用时注意事项</h2><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p>
<p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span>[] array = (<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList); <span class="comment">//输出[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何正确的将数组转化为ArrayList"><a href="#如何正确的将数组转化为ArrayList" class="headerlink" title="如何正确的将数组转化为ArrayList"></a>如何正确的将数组转化为ArrayList</h2><p><strong>1. 自己动手实现（教育目的）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 最简便的方法(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用 Java8 的Stream(推荐)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用 Guava(推荐)</strong></p>
<p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code></a>工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用 Apache Commons Collections</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure>

<p><strong>6. 使用 Java9 的 <code>List.of()</code>方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 2, 3] */</span></span><br><span class="line"><span class="comment">/* 不支持基本数据类型 */</span></span><br></pre></td></tr></table></figure>



<h2 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code> T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list); <span class="comment">//对集合按照降序排序</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure>

<p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。</p>
<h2 id="不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove/add 操作"></a>不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove</code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p>
</blockquote>
<p>Java8开始，可以使用<code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p>
<p><img src="http://cdn.rongshen2020.com/20201231a3.png"></p>
<p>如果是1，其实还算正常的。如果是2，就会报错：</p>
<p><img src="http://cdn.rongshen2020.com/20201231a4.png"></p>
]]></content>
      <categories>
        <category>java理论</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用关键字总结</title>
    <url>/2021/01/03/java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h2 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h2><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p>
<p>Example</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//静态方法，属于类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;An example string that doesn&#x27;t depend on i (an instance variable)&quot;</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态方法，属于构造出的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.i + <span class="number">1</span>;  <span class="comment">//Depends on i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo bar = <span class="keyword">new</span> Foo(<span class="number">1</span>);</span><br><span class="line">bar.method2();  <span class="comment">//说明非静态方法是属于具体的实例对象的</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li><strong>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法）</strong>，而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ul>
<h3 id="static-静态代码块与-非静态代码块-构造代码块"><a href="#static-静态代码块与-非静态代码块-构造代码块" class="headerlink" title="static{}静态代码块与{}非静态代码块(构造代码块)"></a><code>static&#123;&#125;</code>静态代码块与<code>&#123;&#125;</code>非静态代码块(构造代码块)</h3><p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。</p>
<p>不同点： 静态代码块在非静态代码块之前执行(静态代码块 -&gt; 非静态代码块 -&gt; 构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p>
<blockquote>
<p>修正 <a href="https://github.com/Snailclimb/JavaGuide/issues/677">issue #677</a>：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p>
</blockquote>
<p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 <strong>静态代码块是自动执行的而静态方法是被调用的时候才执行的。</strong></p>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;默认构造方法！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;非静态代码块！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态代码块！--&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态方法中的内容! --&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;静态方法中的代码块！--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test.test();<span class="comment">//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure>

<p>当只执行 <code>Test.test();</code> 时输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure>

<p>当只执行 <code>Test test = new Test();</code> 时输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--</span><br></pre></td></tr></table></figure>

<p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p>
<ol>
<li><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></li>
<li><strong>final修饰的方法不能被重写；</strong></li>
<li><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></li>
</ol>
<p>说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p><strong>static 关键字主要有以下四种使用场景：</strong></p>
<ol>
<li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></li>
<li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>
<li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>
<h3 id="static-关键字主要有以下四种使用场景："><a href="#static-关键字主要有以下四种使用场景：" class="headerlink" title="static 关键字主要有以下四种使用场景："></a>static 关键字主要有以下四种使用场景：</h3><ol>
<li>修饰成员变量和成员方法</li>
<li>静态代码块</li>
<li>修饰类(只能修饰内部类)</li>
<li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li>
</ol>
<h3 id="1、修饰成员变量和成员方法-常用-："><a href="#1、修饰成员变量和成员方法-常用-：" class="headerlink" title="1、修饰成员变量和成员方法(常用)："></a>1、修饰成员变量和成员方法(常用)：</h3><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p>
<p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p>
<p>调用格式：</p>
<ul>
<li><code>类名.静态变量名</code></li>
<li><code>类名.静态方法名()</code></li>
</ul>
<p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello i am java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StaticBean&#123;&quot;</span>+</span><br><span class="line">                <span class="string">&quot;name=&quot;</span> + name + <span class="string">&quot;,age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBean staticBean = <span class="keyword">new</span> StaticBean(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        StaticBean staticBean2 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        StaticBean staticBean3 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        StaticBean staticBean4 = <span class="keyword">new</span> StaticBean(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        StaticBean.age = <span class="number">33</span>;</span><br><span class="line">        System.out.println(staticBean + <span class="string">&quot; &quot;</span> + staticBean2 + <span class="string">&quot; &quot;</span> + staticBean3 + <span class="string">&quot; &quot;</span> + staticBean4);</span><br><span class="line">        <span class="comment">//StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125;</span></span><br><span class="line">        StaticBean.sayHello();<span class="comment">//Hello i am java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、静态代码块："><a href="#2、静态代码块：" class="headerlink" title="2、静态代码块："></a>2、静态代码块：</h3><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块 —&gt; 非静态代码块 —&gt; 构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p>
<p>静态代码块的格式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;    </span><br><span class="line">语句体;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p><img src="http://cdn.rongshen2020.com/20210103a1.png"></p>
<p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。</p>
<h3 id="3、静态内部类："><a href="#3、静态内部类：" class="headerlink" title="3、静态内部类："></a>3、静态内部类：</h3><p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p>
<ol>
<li>它的创建是不需要依赖外围类的创建。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ol>
<p>Example（静态内部类实现单例模式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<h3 id="4、静态导包："><a href="#4、静态导包：" class="headerlink" title="4、静态导包："></a>4、静态导包：</h3><p>格式为：import static</p>
<p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span></span><br><span class="line"> <span class="comment">//如果只想导入单一某个静态方法，只需要将换成对应的方法名即可</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//换成import static java.lang.Math.max;具有一样的效果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> max = max(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this关键字用于引用类的当前实例。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例对象</span></span><br><span class="line">    Employees[] employees; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;Total employees: &quot;</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，this关键字用于两个地方：</p>
<ul>
<li>this.employees.length：访问类Manager的当前实例的变量。</li>
<li>this.report（）：调用类Manager的当前实例的方法。</li>
</ul>
<p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code> 方法。</p>
<p><strong>使用 this 和 super 要注意的问题：</strong></p>
<ul>
<li>在构造器中使用 <code>super()</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li>
<li><strong>this、super不能用在static方法中。</strong></li>
</ul>
<p><strong>简单解释一下：</strong></p>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p>
]]></content>
      <categories>
        <category>java理论</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之Redlcok分布式锁</title>
    <url>/2020/12/22/redis%E4%B9%8BRedlcok%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8CGuide%E5%93%A5">https://github.com/Snailclimb/JavaGuide，Guide哥</a></p>
</blockquote>
<ul>
<li>建议先阅读 Martin Kleppmann 的文章 《How to do distributed locking》</li>
</ul>
<h1 id="《How-to-do-distributed-locking》简介"><a href="#《How-to-do-distributed-locking》简介" class="headerlink" title="《How to do distributed locking》简介"></a>《How to do distributed locking》简介</h1><p>作者认为目前的业界将redis大量的应用于数据管理领域，这个领域需要非常强的数据的一致性和持久性。但这不是redis设计的初衷（程序员越来越把redis当成了数据库在使用）。而一致性最大的破坏者就是分布式锁。</p>
<ul>
<li>首先得了解为什么要用到分布式锁？<ol>
<li><strong>要性能的：</strong> 拥有这把锁使得你不会重复劳动（例如一个 job 做了两次），如果这把锁 fail 了（也就是失效了），两个节点同时做了这个 Job，那么这个 Job 增加了你的成本。</li>
<li><strong>要正确性的：</strong> 拥有锁可以防止并发操作污染你的系统或者数据，如果这把锁 fail 了，两个节点同时操作了一份数据，结果可能是数据不一致、数据丢失、file 冲突等，会导致严重的后果。</li>
</ol>
</li>
</ul>
<p>如果你只是为了性能，那没必要用 Redlock，它成本高且复杂，你只用一个 Redis 实例也够了，最多加个从节点防止主节点挂了。当然，你使用单节点的 Redis 那么断电或者一些情况下，你会丢失锁，但是你的目的只是加速性能且断电这种事情不会经常发生，这并不是什么大问题。并且如果你使用了单节点 Redis，那么很显然你这个应用需要的锁粒度是很模糊粗糙的，也不会是什么重要的服务。</p>
<p>所以从性能上，你可以尝试单节点redis（无非再加一个从节点）。那么单节点其实没必要再去使用分布式锁了。</p>
<p>那么是否redlock对于要求正确性的场景就合适呢？可以继续往下看。</p>
<h2 id="用锁保护资源："><a href="#用锁保护资源：" class="headerlink" title="用锁保护资源："></a>用锁保护资源：</h2><p>这节里 Martin 先将 Redlock 放在了一边而是仅讨论总体上一个分布式锁是怎么工作的。在分布式环境下，锁比 mutex（互斥锁） 这类复杂，因为涉及到不同节点、网络通信并且他们随时可能无征兆的 fail 。 Martin 假设了一个场景，一个 client 要修改一个文件，它先申请得到锁，然后修改文件写回，放锁。另一个 client 再申请锁 … 代码流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// THIS CODE IS BROKEN</span></span><br><span class="line"><span class="function">function <span class="title">writeData</span><span class="params">(filename, data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lock = lockService.acquireLock(filename);</span><br><span class="line">    <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Failed to acquire lock&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> file = storage.readFile(filename);</span><br><span class="line">        <span class="keyword">var</span> updated = updateContents(file, data);</span><br><span class="line">        storage.writeFile(filename, updated);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜即使你的锁服务非常完美，上述代码还是可能跪，下面的流程图会告诉你为什么：</p>
<p><img src="http://cdn.rongshen2020.com/20201222a1.png"></p>
<p>上述图中，得到锁的 client1 在持有锁的期间暂停了一段时间，例如 GC 停顿。锁有过期时间（一般叫租约，为了防止某个 client 崩溃之后一直占有锁），但是如果 GC 停顿太长超过了锁租约时间，此时锁已经被另一个 client2 所得到，原先的 client1 还没有感知到锁过期，那么奇怪的结果就会发生，曾经 HBase 就发生过这种 Bug。<strong>即使你在 client1 写回之前检查一下锁是否过期也无助于解决这个问题，因为 GC 可能在任何时候发生，即使是你非常不便的时候（在最后的检查与写操作期间）。</strong> 如果你认为自己的程序不会有长时间的 GC 停顿，还有其他原因会导致你的进程 pause。例如进程可能读取尚未进入内存的数据，所以它得到一个 page fault 并且等待 page 被加载进缓存；还有可能你依赖于网络服务；或者其他进程占用 CPU；或者其他人意外发生 SIGSTOP 等。</p>
<h2 id="使用-Fencing-（栅栏）使得锁变安全："><a href="#使用-Fencing-（栅栏）使得锁变安全：" class="headerlink" title="使用 Fencing （栅栏）使得锁变安全："></a>使用 Fencing （栅栏）使得锁变安全：</h2><p>修复问题的方法也很简单：你需要在每次写操作时加入一个 fencing token。这个场景下，fencing token 可以是一个递增的数字（lock service 可以做到），每次有 client 申请锁就递增一次：</p>
<p><img src="http://cdn.rongshen2020.com/20201222a2.png"></p>
<p>client1 申请锁同时拿到 token33，然后它进入长时间的停顿锁也过期了。client2 得到锁和 token34 写入数据，紧接着 client1 活过来之后尝试写入数据，自身 token33 比 34 小因此写入操作被拒绝。注意这需要存储层来检查 token，但这并不难实现。如果你使用 Zookeeper 作为 lock service 的话那么你可以使用 zxid 作为递增数字。 但是对于 Redlock 你要知道，没什么生成 fencing token 的方式，并且怎么修改 Redlock 算法使其能产生 fencing token 呢？好像并不那么显而易见。因为产生 token 需要单调递增，除非在单节点 Redis 上完成但是这又没有高可靠性，你好像需要引进一致性协议来让 Redlock 产生可靠的 fencing token。</p>
<h2 id="使用时间来解决一致性："><a href="#使用时间来解决一致性：" class="headerlink" title="使用时间来解决一致性："></a>使用时间来解决一致性：</h2><p>Redlock 无法产生 fencing token 早该成为在需求正确性的场景下弃用它的理由，但还有一些值得讨论的地方。</p>
<p>学术界有个说法，算法对时间不做假设：因为进程可能pause一段时间、数据包可能因为网络延迟延后到达、时钟可能根本就是错的。而可靠的算法依旧要在上述假设下做正确的事情。</p>
<p>对于 failure detector 失败的众多情况来说，timeout 超时只能作为猜测某个节点 fail 的依据，因为网络延迟、本地时钟不正确等其他原因的限制。考虑到 Redis 使用 gettimeofday，而不是单调的时钟，会受到系统时间的影响，可能会突然前进或者后退一段时间，这会导致一个 key 更快或更慢地过期。</p>
<p>可见，Redlock 依赖于许多时间假设，这是假设情况是不可能完全按照redis的设想来进行的。</p>
<h2 id="用不可靠的时间打破-Redlock："><a href="#用不可靠的时间打破-Redlock：" class="headerlink" title="用不可靠的时间打破 Redlock："></a>用不可靠的时间打破 Redlock：</h2><p><strong>举例1：</strong>时钟不可靠导致</p>
<ol>
<li>client1 从 ABC 三个节点处申请到锁，DE由于网络原因请求没有到达</li>
<li>C节点的时钟往前推了，导致 lock 过期</li>
<li>client2 在CDE处获得了锁，AB由于网络原因请求未到达</li>
<li>此时 client1 和 client2 都获得了锁</li>
</ol>
<p><strong>举例2：</strong>进程Pause导致</p>
<ol>
<li>client1 从 ABCDE 处获得了锁</li>
<li>当获得锁的 response 还没到达 client1 时 client1 进入 GC 停顿</li>
<li>停顿期间锁已经过期了</li>
<li>client2 在 ABCDE 处获得了锁</li>
<li>client1 GC 完成收到了获得锁的 response，此时两个 client 又拿到了同一把锁</li>
</ol>
<p>同时，网络延迟也会导致以上情况的发生。</p>
<h2 id="Redlock-的同步性假设："><a href="#Redlock-的同步性假设：" class="headerlink" title="Redlock 的同步性假设："></a>Redlock 的同步性假设：</h2><p>以上的例子说明了，如果想用Redlcok，那么你得在假设了一个同步性系统模型的基础上，Redlock 才能正常工作，也就是系统能满足以下属性：</p>
<ol>
<li>网络延时边界，即假设数据包一定能在某个最大延时之内到达</li>
<li>进程停顿边界，即进程停顿一定在某个最大时间之内</li>
<li>时钟错误边界，即不会从一个坏的 NTP 服务器处取得时间</li>
</ol>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>Martin 认为 Redlock 实在不是一个好的选择，对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。因为它对高危的时钟或者说其他上述列举的情况进行了不可靠的假设，如果你的应用只需要高性能的分布式锁不要求多高的正确性，那么单节点 Redis 够了；如果你的应用想要保住正确性，那么不建议 Redlock，建议使用一个合适的一致性协调系统，例如 Zookeeper，且保证存在 fencing token。</p>
<h1 id="Redlock使用简介"><a href="#Redlock使用简介" class="headerlink" title="Redlock使用简介"></a>Redlock使用简介</h1><p><strong>Redlock的几大特性：</strong></p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2 id="在单节点上实现分布式锁："><a href="#在单节点上实现分布式锁：" class="headerlink" title="在单节点上实现分布式锁："></a>在单节点上实现分布式锁：</h2><p>待续。。。</p>
<h2 id="redlock算法："><a href="#redlock算法：" class="headerlink" title="redlock算法："></a>redlock算法：</h2><p>待续。。。</p>
<h2 id="失败重试："><a href="#失败重试：" class="headerlink" title="失败重试："></a>失败重试：</h2><p>待续。。。</p>
<h2 id="放锁："><a href="#放锁：" class="headerlink" title="放锁："></a>放锁：</h2><p>待续。。。</p>
<h2 id="性能、崩溃恢复和-fsync："><a href="#性能、崩溃恢复和-fsync：" class="headerlink" title="性能、崩溃恢复和 fsync："></a>性能、崩溃恢复和 fsync：</h2><p>待续。。。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis持久化</title>
    <url>/2020/12/20/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<p>Redis不同于Memcached的很重一点就是，<strong>Redis支持持久化</strong>，而且支持两种不同的持久化操作。Redis的一种持久化方式叫<strong>快照（snapshotting，RDB）</strong>,另一种方式是<strong>只追加文件（append-only file,AOF）</strong>。</p>
<h2 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）:"></a>快照持久化（RDB）:</h2><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>redis默认的持久化方式就是快照持久化，在redis.conf配置文件中配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>



<p>但是这里面有个问题，就是创建不同的快照之间的间隔时间，如果很短则消耗硬件性能，如果太长则容易丢失数据。举例就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设Redis的上一个快照是<span class="number">2</span>：<span class="number">35</span>开始创建的，并且已经创建成功。下午<span class="number">3</span>：<span class="number">06</span>时，Redis又开始创建新的快照，并且在下午<span class="number">3</span>：08快照创建完毕之前，有<span class="number">35</span>个键进行了更新。如果在下午<span class="number">3</span>：<span class="number">06</span>到<span class="number">3</span>：08期间，系统发生了崩溃，导致Redis无法完成新快照的创建工作，那么Redis将丢失下午<span class="number">2</span>：<span class="number">35</span>之后写入的所有数据。另一方面，如果系统恰好在新的快照文件创建完毕之后崩溃，那么Redis将丢失<span class="number">35</span>个键的更新数据。</span><br></pre></td></tr></table></figure>

<p><strong>创建快照的办法有如下几种：</strong></p>
<ul>
<li><strong>BGSAVE命令：</strong> 客户端向Redis发送 <strong>BGSAVE命令</strong> 来创建一个快照。对于支持BGSAVE命令的平台来说（基本上所有平台支持，除了Windows平台），Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</li>
<li><strong>SAVE命令：</strong> 客户端还可以向Redis发送 <strong>SAVE命令</strong> 来创建一个快照，接到SAVE命令的Redis服务器在快照创建完毕之前不会再响应任何其他命令。SAVE命令不常用，我们通常只会在没有足够内存去执行BGSAVE命令的情况下，又或者即使等待持久化操作执行完毕也无所谓的情况下，才会使用这个命令。</li>
<li><strong>save选项：</strong> 如果用户设置了save选项（一般会默认设置），比如 <strong>save 60 10000</strong>，那么从Redis最近一次创建快照之后开始算起，当“60秒之内有10000次写入”这个条件被满足时，Redis就会自动触发BGSAVE命令。</li>
<li><strong>SHUTDOWN命令：</strong> 当Redis通过SHUTDOWN命令接收到关闭服务器的请求时，或者接收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端，不再执行客户端发送的任何命令，并在SAVE命令执行完毕之后关闭服务器。</li>
<li><strong>一个Redis服务器连接到另一个Redis服务器：</strong> 当一个Redis服务器连接到另一个Redis服务器，并向对方发送SYNC命令来开始一次复制操作的时候，如果主服务器目前没有执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，那么主服务器就会执行BGSAVE命令</li>
</ul>
<p>如果系统真的发生崩溃，用户将丢失最近一次生成快照之后更改的所有数据。因此，快照持久化只适用于即使丢失一部分数据也不会造成一些大问题的应用程序。不能接受这个缺点的话，可以考虑AOF持久化。</p>
<h2 id="AOF持久化（append-only-file）："><a href="#AOF持久化（append-only-file）：" class="headerlink" title="AOF持久化（append-only file）："></a>AOF持久化（append-only file）：</h2><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p><strong>appendfsync always</strong> 可以实现将数据丢失减到最少，不过这种方式需要对硬盘进行大量的写入而且每次只写入一个命令，十分影响Redis的速度。另外使用固态硬盘的用户谨慎使用appendfsync always选项，因为这会明显降低固态硬盘的使用寿命。</p>
<p>为了兼顾数据和写入性能，用户可以考虑 <strong>appendfsync everysec选项</strong> ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>appendfsync no</strong> 选项一般不推荐，这种方案会使Redis丢失不定量的数据而且如果用户的硬盘处理写入操作的速度不够的话，那么当缓冲区被等待写入的数据填满时，Redis的写入操作将被阻塞，这会导致Redis的请求速度变慢，这样1秒钟中如果丢失数据就会更少了。</p>
<p><strong>虽然AOF持久化非常灵活地提供了多种不同的选项来满足不同应用程序对数据安全的不同要求，但AOF持久化也有缺陷——AOF文件的体积太大。</strong></p>
<h2 id="重写-压缩AOF："><a href="#重写-压缩AOF：" class="headerlink" title="重写/压缩AOF："></a>重写/压缩AOF：</h2><p>如果出现极端情况（这些情况还是很容易出现的），AOF文件会很大，甚至超过快照文件。那么在还原操作，执行时间也会很长。</p>
<p>为了解决AOF体积过大的问题，用户可以向Redis发送 <strong>BGREWRITEAOF命令</strong> ，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件来减小AOF文件的体积。BGREWRITEAOF命令和BGSAVE创建快照原理十分相似，所以AOF文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件大好几倍。</p>
<p><strong>AOF持久化设置举例：</strong></p>
<p>假设用户对Redis设置了如下配置选项并且启用了AOF持久化。那么当AOF文件体积大于64mb，并且AOF的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis将执行BGREWRITEAOF命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage <span class="number">100</span>  </span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>



<h2 id="redis4-0对于持久化机制的优化："><a href="#redis4-0对于持久化机制的优化：" class="headerlink" title="redis4.0对于持久化机制的优化："></a>redis4.0对于持久化机制的优化：</h2><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群及应用场景</title>
    <url>/2020/12/21/redis%E9%9B%86%E7%BE%A4%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="主从复制："><a href="#主从复制：" class="headerlink" title="主从复制："></a>主从复制：</h2><p>两种结构：</p>
<p><img src="http://cdn.rongshen2020.com/20201221a1.png"></p>
<p><img src="http://cdn.rongshen2020.com/20201221a2.png"></p>
<p>复制模式：</p>
<ul>
<li>全量复制：Master 全部同步到 Slave</li>
<li>部分复制：Slave 数据丢失进行备份</li>
</ul>
<p>问题点：</p>
<ul>
<li><p>同步故障</p>
<ul>
<li>复制数据延迟(不一致)</li>
<li>读取过期数据(Slave 不能删除数据)</li>
<li>从节点故障</li>
<li>主节点故障</li>
</ul>
</li>
<li><p>配置不一致</p>
<ul>
<li>maxmemory 不一致:丢失数据</li>
<li>优化参数不一致:内存不一致.</li>
</ul>
</li>
<li><p>避免全量复制</p>
<ul>
<li>选择小主节点(分片)、低峰期间操作.</li>
<li>如果节点运行 id 不匹配(如主节点重启、运行 id 发送变化)，此时要执行全量复制，应该配合哨兵和集群解决.</li>
<li>主从复制挤压缓冲区不足产生的问题(网络中断，部分复制无法满足)，可增大复制缓冲区( rel_backlog_size 参数).</li>
</ul>
</li>
<li><p>复制风暴</p>
<p>举例：我们master重启，其master下的所有slave检测到RunID发生变化，导致所有从节点向主节点做全量复制。</p>
</li>
</ul>
<h2 id="哨兵机制sentinel："><a href="#哨兵机制sentinel：" class="headerlink" title="哨兵机制sentinel："></a>哨兵机制sentinel：</h2><p>redis Sentinel是一个分布式系统，为Redis提供高可用性解决方案。可以在一个架构中运行多个 Sentinel 进程(progress)， 这些进程使用流言协议(gossip protocols)来 接收关于主服务器是否下线的信息， 并使用投票协议(agreement protocols)来决定是否执行自动故 障迁移， 以及选择哪个从服务器作为新的主服务器。</p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器(instance) 该系统执行以下三个任务:</p>
<ul>
<li><strong>监控(Monitoring)</strong>: Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</li>
<li><strong>提醒(Notification)</strong>: 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移(Automaticfailover)</strong>: 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中 一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器; 当客 户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主 服务器代替失效服务器。</li>
</ul>
<p><strong>redis节点下线：</strong></p>
<ul>
<li>主观下线<ul>
<li>即 Sentinel 节点对 Redis 节点失败的偏见，超出超时时间认为 Master 已经宕机。</li>
<li>Sentinel 集群的每一个 Sentinel 节点会定时对 Redis 集群的所有节点发心跳包检测节点是否正常。如果一个节点在 <code>down-after-milliseconds</code> 时间内没有回复 Sentinel 节点的心跳包，则该 Redis 节点被该 Sentinel 节点主观下线。</li>
</ul>
</li>
<li>客观下线（每个sentinel进行投票）<ul>
<li>所有 Sentinel 节点对 Redis 节点失败要达成共识，即超过 quorum 个统一。</li>
<li>当节点被一个 Sentinel 节点记为主观下线时，并不意味着该节点肯定故障了，还需要 Sentinel 集群的其他 Sentinel 节点共同判断为主观下线才行。</li>
<li>该 Sentinel 节点会询问其它 Sentinel 节点，如果 Sentinel 集群中超过 quorum 数量的 Sentinel 节点认为该 Redis 节点主观下线，则该 Redis 客观下线。</li>
</ul>
</li>
</ul>
<p><strong>sentinel选举Leader：</strong></p>
<ul>
<li>选举出一个 Sentinel 作为 Leader，集群中至少要有三个 Sentinel 节点，通过以下选举流程可以进行失败判定或领导者选举。</li>
<li>选举流程<ol>
<li>每个主观下线的 Sentinel 节点向其他 Sentinel 节点发送命令，要求设置它为领导者.</li>
<li>收到命令的 Sentinel 节点如果没有同意通过其他 Sentinel 节点发送的命令，则同意该请求，否则拒绝。</li>
<li>如果该 Sentinel 节点发现自己的票数已经超过 Sentinel 集合半数且超过 quorum，则它成为领导者。</li>
<li>如果此过程有多个 Sentinel 节点成为领导者，则等待一段时间再重新进行选举。</li>
</ol>
</li>
</ul>
<p><strong>redis节点故障转移：</strong></p>
<ul>
<li>转移流程<ol>
<li>Sentinel 选出一个合适的 Slave 作为新的 Master(slaveof no one 命令)。</li>
<li>向其余 Slave 发出通知，让它们成为新 Master 的 Slave( parallel-syncs 参数)。</li>
<li>等待旧 Master 复活，并使之称为新 Master 的 Slave。</li>
<li>向客户端通知 Master 变化。</li>
</ol>
</li>
<li>从 Slave 中选择新 Master 节点的规则(slave 升级成 master 之后)<ol>
<li>选择 slave-priority（优先级） 最高的节点。</li>
<li>选择复制偏移量最大的节点(同步数据最多)。</li>
<li>选择 runId 最小的节点。runid是Redis 服务器的随机标识符，<strong>重启后就会改变</strong>；当复制时发现和之前的 run_id 不同时，将会对数据全量同步。</li>
</ol>
</li>
</ul>
<ul>
<li>sentinel的集群运行过程中故障转移完成之后，所有的sentinel又会恢复平等。sentinel选举的leader仅仅是在转移操作过程中起作用。</li>
</ul>
<p><strong>读写分离：</strong></p>
<p>云数据库Redis版不管主从版还是集群规格，replica作为备库不对外提供服务，只有在发生HA的时候，replica提升为master后才承担读写流量。这种架构读写请求都在master上完成，一致性较高，但性能受到master数量的限制。经常有用户数据较少，但因为流量或者并发太高而不得不升级到更大的集群规格。</p>
<p>为满足读多写少的业务场景，最大化节约用户成本，云数据库Redis版推出了读写分离规格，为用户提供透明、高可用、高性能、高灵活的读写分离服务。</p>
<p><strong>定时任务：</strong></p>
<ul>
<li>每 1s 每个 Sentinel 对其他 Sentinel 和 Redis 执行 ping，进行心跳检测。</li>
<li>每 2s 每个 Sentinel 通过 Master 的 Channel 交换信息(pub - sub)。</li>
<li>每 10s 每个 Sentinel 对 Master 和 Slave 执行 info，目的是发现 Slave 节点、确定主从关系。</li>
</ul>
<h2 id="分布式集群："><a href="#分布式集群：" class="headerlink" title="分布式集群："></a>分布式集群：</h2><p><strong>拓扑图：</strong></p>
<p><img src="http://cdn.rongshen2020.com/20201221a3.png"></p>
<p><strong>通讯方式：</strong></p>
<p>有<strong>集中式</strong>和<strong>gossip</strong>协议两种方式。</p>
<ol>
<li><p>集中式：</p>
<p>将集群中的某些数据放在某一个节点上。例如日志记录。这样的坏处就是数据集中存储，若发生灾难，一损俱损。</p>
</li>
<li><p>gossip协议：</p>
<p>从 gossip 单词就可以看到，其中文意思是八卦、流言等意思，我们可以想象下绯闻的传播（或者流行病的传播）；gossip 协议的工作原理就类似于这个。gossip 协议利用一种随机的方式将信息传播到整个网络中，并在一定时间内使得系统内的所有节点数据一致。Gossip 其实是一种去中心化思路的分布式协议，解决状态在集群中的传播和状态一致性的保证两个问题。<a href="https://www.iteblog.com/archives/2505.html">https://www.iteblog.com/archives/2505.html</a></p>
</li>
</ol>
<p><strong>寻址分片：</strong></p>
<p>​    <a href="https://www.cnblogs.com/liqbk/p/13510286.html">详解</a></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="热点数据："><a href="#热点数据：" class="headerlink" title="热点数据："></a>热点数据：</h2><p>存取数据优先从 Redis 操作，如果不存在再从文件（例如 MySQL）中操作，从文件操作完后将数据存储到 Redis 中并返回。同时有个定时任务后台定时扫描 Redis 的 key，根据业务规则进行淘汰，防止某些只访问一两次的数据一直存在 Redis 中。</p>
<ul>
<li>例如使用 Zset 数据结构，存储 Key 的访问次数/最后访问时间作为 Score，最后做排序，来淘汰那些最少访问的 Key。</li>
</ul>
<h2 id="会话维持-Session："><a href="#会话维持-Session：" class="headerlink" title="会话维持 Session："></a>会话维持 Session：</h2><p>会话维持 Session 场景，即使用 Redis 作为分布式场景下的登录中心存储应用。每次不同的服务在登录的时候，都会去统一的 Redis 去验证 Session 是否正确。但是在微服务场景，一般会考虑 Redis + JWT 做 Oauth2 模块。</p>
<ul>
<li>其中 Redis 存储 JWT 的相关信息主要是留出口子，方便以后做统一的防刷接口，或者做登录设备限制等。</li>
</ul>
<h2 id="分布式锁-SETNX："><a href="#分布式锁-SETNX：" class="headerlink" title="分布式锁 SETNX："></a>分布式锁 SETNX：</h2><p><strong>什么是分布式锁？</strong></p>
<p>要介绍分布式锁，首先要提到与分布式锁相对应的是线程锁、进程锁。</p>
<ul>
<li>线程锁：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。</li>
<li>进程锁：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。</li>
<li>分布式锁：当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</li>
</ul>
<p>命令格式：<code>SETNX key value</code>：当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<ol>
<li>超时时间设置：获取锁的同时，启动守护线程，使用 expire 进行定时更新超时时间。如果该业务机器宕机，守护线程也挂掉，这样也会自动过期。如果该业务不是宕机，而是真的需要这么久的操作时间，那么增加超时时间在业务上也是可以接受的，但是肯定有个最大的阈值。</li>
<li>但是为了增加高可用，需要使用多台 Redis，就增加了复杂性</li>
</ol>
<h2 id="表缓存："><a href="#表缓存：" class="headerlink" title="表缓存："></a>表缓存：</h2><p>Redis 缓存表的场景有黑名单、禁言表等。访问频率较高，即读高。根据业务需求，可以使用后台定时任务定时刷新 Redis 的缓存表数据。</p>
<h2 id="消息队列-list："><a href="#消息队列-list：" class="headerlink" title="消息队列 list："></a>消息队列 list：</h2><p>主要使用了 List 数据结构。<br>List 支持在头部和尾部操作，因此可以实现简单的消息队列。</p>
<ol>
<li>发消息：在 List 尾部塞入数据。</li>
<li>消费消息：在 List 头部拿出数据。</li>
</ol>
<p>同时可以使用多个 List，来实现多个队列，根据不同的业务消息，塞入不同的 List，来增加吞吐量。</p>
<h2 id="计数器-string："><a href="#计数器-string：" class="headerlink" title="计数器 string："></a>计数器 string：</h2><p>主要使用了 INCR、DECR、INCRBY、DECRBY 方法。</p>
<p>INCR key：给 key 的 value 值增加一 DECR key：给 key 的 value 值减去一</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存更新算法："><a href="#缓存更新算法：" class="headerlink" title="缓存更新算法："></a>缓存更新算法：</h2><ul>
<li>LRU(Least Recently Used,最近最少使用)、LFU(least frequently used,最不经常使用)、FIFO 算法自动清除：一致性最差，维护成本低。</li>
<li>超时自动清除(key expire)：一致性较差，维护成本低。</li>
<li>主动更新：代码层面控制生命周期，一致性最好，维护成本高。</li>
</ul>
<p>在 Redis 根据在 redis.conf 的参数 <code>maxmemory</code> 来做更新淘汰策略：</p>
<ol>
<li>noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外, 如?DEL?命令)。</li>
<li>allkeys-lru: 所有 key 通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。</li>
<li>volatile-lru: 只限于设置了?expire?的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。</li>
<li>allkeys-random: 所有key通用; 随机删除一部分 key。</li>
<li>volatile-random: 只限于设置了?expire?的部分; 随机删除一部分 key。</li>
<li>volatile-ttl: 只限于设置了?expire?的部分; 优先删除剩余时间(time to live,TTL) 短的key。</li>
</ol>
<h2 id="更新的一致性："><a href="#更新的一致性：" class="headerlink" title="更新的一致性："></a>更新的一致性：</h2><ul>
<li>读请求：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>写请求：先删除缓存，然后再更新数据库(避免大量地写、却又不经常读的数据导致缓存频繁更新)。</li>
</ul>
<h2 id="缓存的粒度："><a href="#缓存的粒度：" class="headerlink" title="缓存的粒度："></a>缓存的粒度：</h2><p>通俗来讲，缓存粒度问题就是我们在使用缓存时，是将所有数据缓存还是缓存部分数据？</p>
<p>需要从以下三个方面进行考虑：（通用性，空间占用，代码维护成本）</p>
<ul>
<li>通用性：全量属性更好。</li>
<li>占用空间：部分属性更好。</li>
<li>代码维护成本。</li>
</ul>
<h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><blockquote>
<p>当大量的请求无命中缓存、直接请求到后端数据库(业务代码的 bug、或恶意攻击)，同时后端数据库也没有查询到相应的记录、无法添加缓存。这种状态会一直维持，流量一直打到存储层上，无法利用缓存、还会给存储层带来巨大压力。</p>
</blockquote>
<p><strong>解决方案</strong></p>
<ol>
<li>请求无法命中缓存、同时数据库记录为空时在缓存添加该 key 的空对象(设置过期时间)，缺点是可能会在缓存中添加大量的空值键(比如遭到恶意攻击或爬虫)，而且缓存层和存储层数据短期内不一致；</li>
<li>使用布隆过滤器在缓存层前拦截非法请求、自动为空值添加黑名单(同时可能要为误判的记录添加白名单).但需要考虑布隆过滤器的维护(离线生成/ 实时生成)。</li>
</ol>
<h2 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h2><blockquote>
<p>缓存崩溃(例如，redis服务停止)时请求会直接落到数据库上，很可能由于无法承受大量的并发请求而崩溃，此时如果只重启数据库，或因为缓存重启后没有数据，新的流量进来很快又会把数据库击倒。</p>
</blockquote>
<p><strong>出现后应对：</strong></p>
<ul>
<li>事前：Redis 高可用，主从 + 哨兵，Redis Cluster，避免全盘崩溃。</li>
<li>事中：本地 ehcache 缓存 + hystrix 限流 &amp; 降级，避免数据库承受太多压力。</li>
<li>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li>
</ul>
<p><strong>请求过程：</strong></p>
<ol>
<li>用户请求先访问本地缓存，无命中后再访问 Redis，如果本地缓存和 Redis 都没有再查数据库，并把数据添加到本地缓存和 Redis；</li>
<li>由于设置了限流，一段时间范围内超出的请求走降级处理(返回默认值，或给出友情提示)。</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>rpc框架-负载均衡之一致性hash算法(仿Dubbo)</title>
    <url>/2021/06/21/rpc%E6%A1%86%E6%9E%B6-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95-%E4%BB%BFDubbo/</url>
    <content><![CDATA[<p>一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提供出的，算法提出之初是用于大规模缓存系统的负载均衡。本文仿Dubbo</p>
<span id="more"></span>

<blockquote>
<p>参考：<a href="http://tianxiaobo.com/2018/11/29/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E4%B9%8B-LoadBalance/#23-consistenthashloadbalance">http://tianxiaobo.com/2018/11/29/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E4%B9%8B-LoadBalance/#23-consistenthashloadbalance</a></p>
</blockquote>
<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提供出的，算法提出之初是用于大规模缓存系统的负载均衡。</p>
<p>它的工作过程是这样的，首先根据 ip 获取其他的信息为缓存节点生成一个 hash值，并将这个 hash 投射到 [0, 2^31^ -1] 的圆环上（那么这个hash值生成函数，当然要保证生成值在此区间中）。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后<strong>查找第一个大于或等于</strong>该 hash值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash值的缓存节点即可。大致效果如下，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash值，则到该缓存节点中存储或读取缓存项。</p>
<p><img src="https://cdn.rongshen2020.com/20210621a1.png"></p>
<p>如果我们的圆环上只有少数的缓存节点，且分布不均，那么就会出现大问题：</p>
<p><img src="https://cdn.rongshen2020.com/20210621a2.png"></p>
<p>缓存节点1会得到大量的写入和查询请求。</p>
<p>所以，引入<strong>虚拟节点概念</strong>，目的是通过引入虚拟节点，让缓存节点在圆环上分散开来，避免数据倾斜问题。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量的请求。</p>
<h2 id="hashCode-方法和identityHashCode-方法的关系："><a href="#hashCode-方法和identityHashCode-方法的关系：" class="headerlink" title="hashCode()方法和identityHashCode()方法的关系："></a>hashCode()方法和identityHashCode()方法的关系：</h2><blockquote>
<p><a href="https://www.cnblogs.com/godtrue/p/6341473.html">https://www.cnblogs.com/godtrue/p/6341473.html</a></p>
</blockquote>
<p>一个对象的hashCode和identityHashCode 的关系：</p>
<ol>
<li>对象的hashCode，一般是通过将该对象的内部地址转换成一个整数来实现的。</li>
<li>当一个类没有重写Object类的hashCode()方法时，它的hashCode和identityHashCode是一致的</li>
<li>当一个类重写了Object类的hashCode()方法时，它的hashCode则有重写的实现逻辑决定，此时的hashCode值一般就不再和对象本身的内部地址有相应的哈希关系了</li>
<li>当null调用hashCode方法时，会抛出空指针异常，但是调用System.identityHashCode(null)方法时能正常的返回0这个值</li>
<li>一个对象的identityHashCode能够始终和该对象的内部地址有一个相对应的关系，从这个角度来讲，它可以用于代表对象的引用地址，所以，在理解==这个操作运算符的时候是比较有用的</li>
</ol>
<h2 id="hash方法："><a href="#hash方法：" class="headerlink" title="hash方法："></a>hash方法：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private long hash(byte[] digest, int number) &#123;</span><br><span class="line">            return ((long)(digest[3 + number * 4] &amp; 255) &lt;&lt; 24 | (long)(digest[2 + number * 4] &amp; 255) &lt;&lt; 16 | (long)(digest[1 + number * 4] &amp; 255) &lt;&lt; 8 | (long)(digest[number * 4] &amp; 255)) &amp; 4294967295L;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<h1 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h1><p><img src="https://cdn.rongshen2020.com/20210621a3.png"></p>
<h2 id="首先看doSelect方法："><a href="#首先看doSelect方法：" class="headerlink" title="首先看doSelect方法："></a>首先看doSelect方法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> String <span class="title">doSelect</span><span class="params">(List&lt;String&gt; serviceAddresses, RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取serviceAddresses 的hashCode</span></span><br><span class="line">       <span class="keyword">int</span> identityHashCode = System.identityHashCode(serviceAddresses);</span><br><span class="line"></span><br><span class="line">       String rpcServiceName = rpcRequest.getRpcServiceName();</span><br><span class="line"></span><br><span class="line">       ConsistentHashSelector selector = selectors.get(rpcServiceName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果 serviceAddresses 是一个新的 List 对象，意味着服务提供者数量发生了变化，可能新增也可能减少了。</span></span><br><span class="line"><span class="comment">        * 此时 selector.identityHashCode != identityHashCode 条件成立</span></span><br><span class="line"><span class="comment">        * identityHashCode是之前List&lt;String&gt; serviceAddresses对象的identityHashCode</span></span><br><span class="line"><span class="comment">        * selector.identityHashCode是 ConsistentHashSelector类的identityHashCode</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">           <span class="comment">// 创建新的ConsistentHashSelector</span></span><br><span class="line">           selectors.put(rpcServiceName, <span class="keyword">new</span> ConsistentHashSelector(serviceAddresses, <span class="number">160</span>, identityHashCode));</span><br><span class="line">           selector = selectors.get(rpcServiceName);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用ConsistentHashSelector 的 select 方法选择serviceAddresses</span></span><br><span class="line">       <span class="keyword">return</span> selector.select(rpcServiceName + Arrays.stream(rpcRequest.getParameters()));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的selectors：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key:String类型的rpcServiceName，value:内部类ConsistentHashSelector类型的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="内部类ConsistentHashSelector："><a href="#内部类ConsistentHashSelector：" class="headerlink" title="内部类ConsistentHashSelector："></a>内部类ConsistentHashSelector：</h2><p>这个内部类的作用就是保存一个<code>TreeMap&lt;Long, String&gt; virtualInvokers</code>虚拟节点的集合（注意，这只是一个虚拟节点），以及一个该集合的    <code>identityHashCode</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 TreeMap 存储 serviceAddresses 虚拟节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, String&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是List&lt;String&gt; serviceAddresses对象的identityHashCode</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部类的构造方法</span></span><br><span class="line">        ConsistentHashSelector(List&lt;String&gt; invokers, <span class="keyword">int</span> replicaNumber, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">            <span class="comment">// invokers是String类型的serviceAddresses，一个serviceAddresses在virtualInvokers这个map中就有160个节点</span></span><br><span class="line">            <span class="keyword">for</span> (String invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 按照前面的传参replicaNumber=160,那么就是进行了40次运算</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 对invoker+i进行md5运算，得到一个长度为16个字节数组</span></span><br><span class="line">                    <span class="keyword">byte</span>[] digest = md5(invoker + i);</span><br><span class="line">                    <span class="comment">// 对digest部分字节进行4次hash运算，得到四个不同的long型正整数</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                        <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 2 时，取 digest 中下标为 8 ~ 11 的4个字节进行位运算</span></span><br><span class="line">                        <span class="comment">// h = 3 时，取 digest 中下标为 12 ~ 15 的4个字节进行位运算</span></span><br><span class="line">                        <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                        <span class="comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中，</span></span><br><span class="line">                        <span class="comment">// virtualInvokers 中的元素要有序，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                        <span class="comment">// 得到了160个虚拟节点，存储到了virtualInvokers这个TreeMap中</span></span><br><span class="line">                        virtualInvokers.put(m, invoker);<span class="comment">//virtualInvokers这个TreeMap中应该有serviceAddresses.size * 160个节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">(String rpcServiceKey)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(rpcServiceKey);</span><br><span class="line">            <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">            <span class="comment">// 寻找合适的 serviceAddresses</span></span><br><span class="line">            <span class="keyword">long</span> hashCode1 = hash(digest, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> selectForKey(hashCode1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hashCode)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * tailMap()方法与firstEntry()方法表示：</span></span><br><span class="line"><span class="comment">             *      到virtualInvokers这个TreeMap中查找第一个节点值大于或等于当前hashCode的节点entry</span></span><br><span class="line"><span class="comment">             * virtualInvokers中第一个大于或等于hashCode的节点entry，对应的数据结构是&lt;Long, String&gt;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Map.Entry&lt;Long, String&gt; entry = virtualInvokers.tailMap(hashCode, <span class="keyword">true</span>).firstEntry();</span><br><span class="line">            <span class="comment">// 如果hashCode 大于 圆环上最大的位置，此时节点entry = null，需要将 TreeMap 的头结点赋值给 entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回的是String类型的serviceAddresses</span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要知道它是在做运算，返回的是字节数组。模仿dubbo里面的</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">byte</span>[] md5(String key) &#123;</span><br><span class="line">            MessageDigest md;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                md.update(bytes);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> md.digest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要知道它是在做运算。dubbo里面的</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">long</span>) (digest[<span class="number">3</span> + idx * <span class="number">4</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">24</span> | (<span class="keyword">long</span>) (digest[<span class="number">2</span> + idx * <span class="number">4</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">16</span> | (<span class="keyword">long</span>) (digest[<span class="number">1</span> + idx * <span class="number">4</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">8</span> | (<span class="keyword">long</span>) (digest[idx * <span class="number">4</span>] &amp; <span class="number">255</span>)) &amp; <span class="number">4294967295L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h1><p>假设从zk下取出的address集合中有两个服务地址</p>
<p><img src="https://cdn.rongshen2020.com/20210621a4.png"></p>
<p>那么virtualInvokers这个集合就可以映射得到 160*2=320个虚拟节点，</p>
<p><img src="https://cdn.rongshen2020.com/20210621a5.png"></p>
<p>所以此时圆环上有320个节点，其中160个指向地址1，160个指向地址2。</p>
<p>使用内部类ConsistentHashSelector的方法其就可以快速找到地址（String类型）：</p>
<p><img src="https://cdn.rongshen2020.com/20210621a6.png"></p>
<p><img src="https://cdn.rongshen2020.com/20210621a7.png"></p>
]]></content>
      <categories>
        <category>RPC框架</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>rpc框架之SPI机制源码分析</title>
    <url>/2021/05/27/rpc%E6%A1%86%E6%9E%B6%E4%B9%8BSPI%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>基于dubbo实现rpc框架，分析SPI机制，并实现一个</p>
<span id="more"></span>


<blockquote>
<p>参考：<a href="http://tianxiaobo.com/2018/10/01/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SPI-%E6%9C%BA%E5%88%B6/">http://tianxiaobo.com/2018/10/01/Dubbo-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SPI-%E6%9C%BA%E5%88%B6/</a></p>
<p>javaguide-rpc</p>
</blockquote>
<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。<strong>这样可以在运行时，动态为接口加载实现类。</strong> 正因此特性，我们可以很容易的通过SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。</p>
<h1 id="本框架SPI示例："><a href="#本框架SPI示例：" class="headerlink" title="本框架SPI示例："></a>本框架SPI示例：</h1><p>并未使用 Java SPI，而是重新实现了一套SPI 机制。SPI 的相关逻辑被封装在了<br>ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。<strong>我们将接口的实现类的全限定名配置在文件中，</strong> 放置在META-INF/extensions路径下，下面来看一下配置内容。</p>
<p><img src="https://cdn.rongshen2020.com/20210527a1.png"></p>
<p><img src="https://cdn.rongshen2020.com/20210527a2.png"></p>
<ul>
<li>还需要在接口上使用<code>@SPI</code>注解。</li>
</ul>
<p><img src="https://cdn.rongshen2020.com/20210527a3.png"></p>
<h1 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h1><p>那么在<code>RpcMessageDecoder.java</code>中就可以直接创建一个<code>Compress</code>类了，使用对象中的方法。<code>compressName=gzip</code></p>
<p><img src="https://cdn.rongshen2020.com/20210527a4.png"></p>
<h1 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h1><p>我们首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader<br>实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。</p>
<p>那我们稍微了解下SPI机制，实现下大致功能。</p>
<p><img src="https://cdn.rongshen2020.com/20210527a5.png"></p>
<h2 id="Holder-java"><a href="#Holder-java" class="headerlink" title="Holder.java:"></a><code>Holder.java</code>:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.extension;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Holder仅用于持有对象目标，没有其他逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile修饰一个对象的话其实是保证这个对象的引用的可见性，而不是保证这个对象的内容的可见性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ExtensionLoader-java："><a href="#ExtensionLoader-java：" class="headerlink" title="ExtensionLoader.java："></a><code>ExtensionLoader.java</code>：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.extension;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.nio.charset.StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参考的是dubbo spi机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensionLoader</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 配置文件path</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_DIRECTORY = <span class="string">&quot;META-INF/extensions/&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存的是ExtensionLoader实例，一个拓展类就有一个ExtensionLoader实例吗？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// Extension对象，就是拓展类，key:接口类型，value:实例化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 某个接口类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">    <span class="comment">// 实例化的拓展对象，key:String,  value:Holder&lt;Object&gt;对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 缓存中保存了实例化的拓展类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ExtensionLoader实例</span></span><br><span class="line"><span class="comment">     * 首先从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ExtensionLoader&lt;S&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;S&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查看这个类要获取实例时（也就是拓展类），符不符合规则。</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type should not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type must be an interface.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.getAnnotation(SPI.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension type must be annotated by @SPI&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先在cache中查找，与之对应的实例化对象</span></span><br><span class="line">        ExtensionLoader&lt;S&gt; extensionLoader = (ExtensionLoader&lt;S&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        <span class="comment">// 如果cache没有命中，那么就创建一个新的实例。创建完成之后，再在EXTENSION_LOADERS中获取。</span></span><br><span class="line">        <span class="comment">// putIfAbsent()方法：如果传入key对应的value已经存在，就返回存在的value，不进行替换。如果不存在，就添加key和value，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;S&gt;(type));</span><br><span class="line">            extensionLoader = (ExtensionLoader&lt;S&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> extensionLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ExtensionLoader实例 的getExtension方法获取拓展类对象.</span></span><br><span class="line"><span class="comment">     * 首先检查缓存，缓存未命中则创建拓展对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入的参数就是：全限定的接口名</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Extension name should not be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Holder仅用于持有目标对象，没其他什么逻辑</span></span><br><span class="line">        Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;&gt;());</span><br><span class="line">            holder = cachedInstances.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有拓展实例不存在的话，就创建一个实例</span></span><br><span class="line">        Object instance = holder.get();</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">                instance = holder.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建拓展实例</span></span><br><span class="line">                    instance = createExtension(name);</span><br><span class="line">                    holder.set(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建拓展对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从配置文件中加载所有的拓展类，形成配置项名称到配置类的映射关系。得到的是类型</span></span><br><span class="line">        Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No such extension of name &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在缓存中判断是否有这个拓展类对象实例</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建实例</span></span><br><span class="line">                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">                <span class="comment">// 创建完再获取</span></span><br><span class="line">                instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们在通过名称获取拓展类之前，</span></span><br><span class="line"><span class="comment">     * 首先需要根据配置文件解析出名称到拓展类的映射，也就是 Map&lt;名称, 拓展类&gt;。</span></span><br><span class="line"><span class="comment">     * 之后再从 Map 中取出相应的拓展类即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。</span></span><br><span class="line">    <span class="comment">// 加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则加载拓展类。以上代码的写法是典型的双重检查锁.</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取  拓展类（class）</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        <span class="comment">// double check</span></span><br><span class="line">        <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    classes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    <span class="comment">// load all extensions from our extensions directory</span></span><br><span class="line">                    <span class="comment">// 从指定文件夹配置文件中 加载所有的拓展类</span></span><br><span class="line">                    loadDirectory(classes);</span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定文件夹配置文件中 加载所有的拓展类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// fileName = 文件夹路径 + type 全限定名。所以文件名必须以type的全限定名命名</span></span><br><span class="line">        String fileName = ExtensionLoader.SERVICE_DIRECTORY + type.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls;</span><br><span class="line">            ClassLoader classLoader = ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="comment">// 根据文件名加载所有的同名文件</span></span><br><span class="line">            urls = classLoader.getResources(fileName);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                    URL resourceUrl = urls.nextElement();</span><br><span class="line">                    <span class="comment">// 加载资源</span></span><br><span class="line">                    loadResource(extensionClasses, classLoader, resourceUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载资源，读取所有的配置文件信息，并全部加载到extensionClasses中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, URL resourceUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceUrl.openStream(), UTF_8))) &#123;</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// read every line，按行读取配置内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// get index of comment</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 截取#之前的字符串，#之后的内容为注释,忽略</span></span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 去除首位空格</span></span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> ei = line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="comment">// 以 = 为界，截取键与值。比如 dubbo=com.alibaba.compress.DubboProtocol</span></span><br><span class="line">                        String name = line.substring(<span class="number">0</span>, ei).trim();</span><br><span class="line">                        String clazzName = line.substring(ei + <span class="number">1</span>).trim();</span><br><span class="line">                        <span class="comment">// 我们的SPI使用键值对，因此它们两个都不能是空的</span></span><br><span class="line">                        <span class="keyword">if</span> (name.length() &gt; <span class="number">0</span> &amp;&amp; clazzName.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Class&lt;?&gt; clazz = classLoader.loadClass(clazzName);</span><br><span class="line">                            extensionClasses.put(name, clazz);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        log.error(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RPC框架</category>
      </categories>
      <tags>
        <tag>SPI机制</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud alibaba</title>
    <url>/2020/10/02/springcloud-alibaba/</url>
    <content><![CDATA[<blockquote>
<p>springcloud alibaba，它是由一些阿里巴巴的开源组件和云产品组成的，为了给使用阿里巴巴产品的 Java 开发者带来使用 Spring Boot 和 Spring Cloud 的更多便利。</p>
</blockquote>
<span id="more"></span>


<h2 id="为什么会出现springcloud-alibaba："><a href="#为什么会出现springcloud-alibaba：" class="headerlink" title="为什么会出现springcloud alibaba："></a>为什么会出现springcloud alibaba：</h2><p>​    之所以有Spring CloudAlibaba,是因为Spring Cloud Netflix项目进入维护模式。也就是,就是不更新了,不会开发新组件了。所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等。</p>
<p><img src="http://cdn.rongshen2020.com/2020102a1.png"></p>
<p>​    2018年10月31日，SpringCloudAlibaba 正式入驻 SpringCloud 官方孵化器，并在 Maven 中央库发布第一个版本。</p>
<p><img src="http://cdn.rongshen2020.com/2020102a2.png"></p>
<h3 id="什么是维护模式："><a href="#什么是维护模式：" class="headerlink" title="什么是维护模式："></a>什么是维护模式：</h3><p>​    将模块置于维护模式，意味着springcloud团队将不会再向模块添加新功能。我们将修复block级别的bug以及安全问题，我们也会考虑并审查社区的小型pull request。</p>
<h3 id="进入维护模式意味着："><a href="#进入维护模式意味着：" class="headerlink" title="进入维护模式意味着："></a>进入维护模式意味着：</h3><p><img src="http://cdn.rongshen2020.com/2020102a3.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020102a4.png"></p>
<h2 id="springcloud-alibaba能干什么？"><a href="#springcloud-alibaba能干什么？" class="headerlink" title="springcloud alibaba能干什么？"></a>springcloud alibaba能干什么？</h2><p>官网：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<p><img src="http://cdn.rongshen2020.com/2020102a5.png"></p>
<h3 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h3><h4 id="Sentinel："><a href="#Sentinel：" class="headerlink" title="Sentinel："></a>Sentinel：</h4><p>​    把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<h4 id="Nacos："><a href="#Nacos：" class="headerlink" title="Nacos："></a>Nacos：</h4><p>​    一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<h4 id="RocketMQ："><a href="#RocketMQ：" class="headerlink" title="RocketMQ："></a>RocketMQ：</h4><p>​    一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p>
<h4 id="Dubbo："><a href="#Dubbo：" class="headerlink" title="Dubbo："></a>Dubbo：</h4><p>​    Apache Dubbo™ 是一款高性能 Java RPC 框架。</p>
<h4 id="Seata："><a href="#Seata：" class="headerlink" title="Seata："></a>Seata：</h4><p>​    阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p>
<h4 id="Alibaba-Cloud-ACM："><a href="#Alibaba-Cloud-ACM：" class="headerlink" title="Alibaba Cloud ACM："></a>Alibaba Cloud ACM：</h4><p>​    一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p>
<h4 id="Alibaba-Cloud-OSS："><a href="#Alibaba-Cloud-OSS：" class="headerlink" title="Alibaba Cloud OSS："></a>Alibaba Cloud OSS：</h4><p>​    阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
<h4 id="Alibaba-Cloud-SchedulerX："><a href="#Alibaba-Cloud-SchedulerX：" class="headerlink" title="Alibaba Cloud SchedulerX："></a>Alibaba Cloud SchedulerX：</h4><p>​    阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p>
<h4 id="Alibaba-Cloud-SMS："><a href="#Alibaba-Cloud-SMS：" class="headerlink" title="Alibaba Cloud SMS："></a>Alibaba Cloud SMS：</h4><p>​    覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p>
<h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p><strong>springcloud alibaba的依赖：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p><strong>接下来的博客主要是学习Nacos/Sentinel/Seata。</strong></p>
<h4 id="see-you"><a href="#see-you" class="headerlink" title="see you"></a>see you</h4>]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud alibaba之Nacos服务注册配置中心</title>
    <url>/2020/10/03/springcloud-alibaba%E4%B9%8BNacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第十二章，Nacos服务注册、配置中心。</p>
</blockquote>
<span id="more"></span>



<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><h3 id="为什么叫Nacos："><a href="#为什么叫Nacos：" class="headerlink" title="为什么叫Nacos："></a>为什么叫Nacos：</h3><p>Dynamic Naming and Configuration Service，前四个字母分别为Naming和Configuration的前两个字母，最后的s为service。</p>
<p>它是一个更易于构建云原生应用的动态服务发现，配置管理和服务管理中心。</p>
<p><strong>简单的来说就是注册中心+配置中心的组合：Nacos=Eureka+Config+Bus</strong></p>
<h3 id="能干嘛："><a href="#能干嘛：" class="headerlink" title="能干嘛："></a>能干嘛：</h3><p>替代eureka做服务注册中心，替代config做服务配置中心。</p>
<h3 id="各注册中心比较："><a href="#各注册中心比较：" class="headerlink" title="各注册中心比较："></a>各注册中心比较：</h3><p><img src="http://cdn.rongshen2020.com/2020103a1.png"></p>
<p>Nacos这么优秀，我想也是经过了阿里巴巴大流量的测试。</p>
<h2 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos:"></a>安装Nacos:</h2><p>需要java8 和 Maven环境已经ok了。</p>
<p><strong>1,到github上下载安装包</strong></p>
<p>​        解压安装包</p>
<p><strong>2,启动Nacos</strong></p>
<p>​        在bin目录下。运行./startup.cmd</p>
<p>​    nacos一直启动失败，我觉得是数据库的问题，所以要配置下数据库。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a2.png"></p>
<p>​    可以看到文件夹下也有一些sql文件，初始化数据库：</p>
<p>​    <img src="http://cdn.rongshen2020.com/2020103a3.png"></p>
<p>​    在application.properties文件里还有，修改db.user和db.password：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a4.png"></p>
<p><strong>3,访问Nacos</strong></p>
<p>​        Nacos默认监听8848。直接访问<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p>
<p>​        账号密码:默认都是nacos</p>
<p>我的一直没有启动成功。</p>
<h2 id="使用Nacos作为服务注册中心："><a href="#使用Nacos作为服务注册中心：" class="headerlink" title="使用Nacos作为服务注册中心："></a>使用Nacos作为服务注册中心：</h2><h3 id="基于Nacos的服务提供者："><a href="#基于Nacos的服务提供者：" class="headerlink" title="基于Nacos的服务提供者："></a>基于Nacos的服务提供者：</h3><ol>
<li><p>新建pay模块，<code>cloudalibaba-provider-payment9001</code></p>
</li>
<li><p>pom，父管理里alibaba的依赖。</p>
<ol>
<li><p>父POM：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--spring cloud alibaba <span class="number">2.1</span><span class="number">.0</span>.RELEASE--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子模块的POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--springcloud alibaba nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 # 配置nacos地址</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure></li>
<li><p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;nacos registry, serverPort: &quot;</span>+ serverPort+<span class="string">&quot;\t id&quot;</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<p>启动nacos，再启动9001。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a5.png"></p>
<p>nacos服务注册中心+服务提供者9001都ok了。</p>
</li>
</ol>
<h3 id="为了下一章的演示nacos的负载均衡，参照9001新建9002。"><a href="#为了下一章的演示nacos的负载均衡，参照9001新建9002。" class="headerlink" title="为了下一章的演示nacos的负载均衡，参照9001新建9002。"></a>为了下一章的演示nacos的负载均衡，参照9001新建9002。</h3><h3 id="基于Nacos的服务消费者的注册与负载："><a href="#基于Nacos的服务消费者的注册与负载：" class="headerlink" title="基于Nacos的服务消费者的注册与负载："></a>基于Nacos的服务消费者的注册与负载：</h3><ol>
<li><p>新建pay模块，<code>cloudalibaba-consumer-nacos-order83</code></p>
</li>
<li><p>pom：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--springcloud alibaba nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>为什么nacos支持负载均衡？因为nacos集成了Netflix的ribbon。</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020103a6.png"></p>
</li>
<li><p>yml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">83</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line"></span><br><span class="line"># 消费者去访问的微服务名称（注册成功进nacos的微服务提供者）</span><br><span class="line">server-url:</span><br><span class="line">  nacos-user-service: http:<span class="comment">//nacos-payment-provider</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类：</p>
<ol>
<li><p>config配置类ApplicationContextBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller控制类OrderNacosController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderNacosController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/&quot;</span>+id,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>测试：</p>
<p>nacos控制台。<code>http://localhost:83/consumer/payment/nacos/13</code></p>
</li>
</ol>
<h2 id="Nacos与其他服务注册中心的对比："><a href="#Nacos与其他服务注册中心的对比：" class="headerlink" title="Nacos与其他服务注册中心的对比："></a>Nacos与其他服务注册中心的对比：</h2><h3 id="Nacos全景图："><a href="#Nacos全景图：" class="headerlink" title="Nacos全景图："></a>Nacos全景图：</h3><p><img src="http://cdn.rongshen2020.com/2020103a7.png"></p>
<h3 id="Nacos和CAP："><a href="#Nacos和CAP：" class="headerlink" title="Nacos和CAP："></a>Nacos和CAP：</h3><p><img src="http://cdn.rongshen2020.com/2020103a8.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a9.png"></p>
<h3 id="NACOS支持AP和CP模式的切换："><a href="#NACOS支持AP和CP模式的切换：" class="headerlink" title="NACOS支持AP和CP模式的切换："></a>NACOS支持AP和CP模式的切换：</h3><p>C是所有节点在同一时间看到的数据是一致的，而A的定义是所有的请求都会收到响应。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a10.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X PUT <span class="string">&#x27;$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP&#x27;</span></span><br></pre></td></tr></table></figure>





<h2 id="使用Nacos作为服务配置中心："><a href="#使用Nacos作为服务配置中心：" class="headerlink" title="使用Nacos作为服务配置中心："></a>使用Nacos作为服务配置中心：</h2><ol>
<li><p>新建moudle,<code>cloudalibaba-config-nacos-client3377</code></p>
</li>
<li><p>pom：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<p>这里需要配置两个配置文件,application.ymk和bootstrap.yml。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a11.png"></p>
<p>主要是为了可以与spring cloud config无缝迁移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3377</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-config-client</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      config:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">        file-extension: yaml</span><br></pre></td></tr></table></figure>

<p>所以将重要的配置信息放在bootstrap.yml，自己的配置信息放在application.yml。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure></li>
<li><p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Nacos的web界面添加配置信息（dataId）：</p>
<p>**Nacos的配置规则:**就是我们在客户端如何指定读取配置文件,配置文件的命名的规则</p>
<p>默认的命名方式:</p>
<p><img src="http://cdn.rongshen2020.com/2020103a12.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prefix:</span><br><span class="line">		默认就是当前服务的服务名称</span><br><span class="line"> 		也可以通过spring.cloud.nacos.config.prefix配置</span><br><span class="line">spring.profile.active:</span><br><span class="line">		就是我们在application.yml中指定的,当前是开发环境还是测试等环境</span><br><span class="line">    这个可以不配置,如果不配置,那么前面的 -  也会没有</span><br><span class="line">file-extension</span><br><span class="line">     就是当前文件的格式(后缀),目前只支持yml和properties</span><br></pre></td></tr></table></figure>

<p>所以上面的命名规则导致下面的Data ID就应该是：<code>nacos-config-client-dev.yaml</code></p>
<p>在web UI上创建配置文件：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a13.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a14.png"></p>
<p>注意,DataId就是配置文件名字：名字一定要按照上面的规则命名,否则客户端会读取不到配置文件。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a15.png"></p>
</li>
<li><p>测试：</p>
<p>重启3377客户端</p>
<p>访问3377</p>
<p><img src="http://cdn.rongshen2020.com/2020103a16.png"></p>
</li>
<li><p>注意默认就开启了自动刷新：</p>
<p>此时我们修改了配置文件，客户端是可以立即更新的。因为Nacos支持Bus总线,会自动发送命令更新所有客户端。</p>
</li>
</ol>
<h2 id="Nacos配置中心之分类配置："><a href="#Nacos配置中心之分类配置：" class="headerlink" title="Nacos配置中心之分类配置："></a>Nacos配置中心之分类配置：</h2><h3 id="两个问题："><a href="#两个问题：" class="headerlink" title="两个问题："></a>两个问题：</h3><p><img src="http://cdn.rongshen2020.com/2020103a17.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a18.png"></p>
<h3 id="Nacos的图形化管理界面："><a href="#Nacos的图形化管理界面：" class="headerlink" title="Nacos的图形化管理界面："></a>Nacos的图形化管理界面：</h3><p><img src="http://cdn.rongshen2020.com/2020103a19.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a20.png"></p>
<h3 id="namespace、group和data-id三者的关系？"><a href="#namespace、group和data-id三者的关系？" class="headerlink" title="namespace、group和data id三者的关系？"></a>namespace、group和data id三者的关系？</h3><p>NameSpace默认有一个:public名称空间</p>
<p>这三个类似java的: 包名 + 类名 + 方法名</p>
<p><img src="http://cdn.rongshen2020.com/2020103a21.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a22.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a23.png"></p>
<h3 id="配置不同DataID："><a href="#配置不同DataID：" class="headerlink" title="配置不同DataID："></a>配置不同DataID：</h3><p>指定spring.profile.active和配置文件的DataID来使不同环境读取不同的配置。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a24.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a25.png"></p>
<p>此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件</p>
<h3 id="配置不同的GroupID："><a href="#配置不同的GroupID：" class="headerlink" title="配置不同的GroupID："></a>配置不同的GroupID：</h3><p>直接在新建配置文件时指定组</p>
<p><img src="http://cdn.rongshen2020.com/2020103a26.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a27.png"></p>
<p><strong>在客户端配置,使用指定组的配置文件bootstrap.yml和application.yml都要修改：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020103a28.png"></p>
<p>重启服务,即可。</p>
<h3 id="配置不同的namespace："><a href="#配置不同的namespace：" class="headerlink" title="配置不同的namespace："></a>配置不同的namespace：</h3><p>新建dev/test的Namespace：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a29.png"></p>
<p>回到服务管理-服务列表查看：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a30.png"></p>
<p>按照域名配置填写：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a31.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a32.png"></p>
<p><strong>要通过命名空间id指定</strong></p>
<p>OK,测试。</p>
<h2 id="Nacos集群和持久化配置：-重要"><a href="#Nacos集群和持久化配置：-重要" class="headerlink" title="Nacos集群和持久化配置：(重要)"></a>Nacos集群和持久化配置：(重要)</h2><p>在实际生产中，当然不止一台nacos服务注册和配置中心。所以nacos集群和持久化配置非常重要。</p>
<p>Nacos默认有自带嵌入式数据库,derby,但是如果做集群模式的话,就不能使用自己的数据库。不然每个节点一个数据库,那么数据就不统一了,需要使用外部的mysql。</p>
<p>真实情况是以下这种情况：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a33.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a34.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a35.png"></p>
<h3 id="单机版（mysql数据库）："><a href="#单机版（mysql数据库）：" class="headerlink" title="单机版（mysql数据库）："></a>单机版（mysql数据库）：</h3><p>nacos本来是是自带一个嵌入式数据库derby的。但是我们想使用mysql数据库来存储Nacos中的数据。</p>
<p><img src="http://cdn.rongshen2020.com/2020103a36.png"></p>
<ol>
<li>nacos默认自带了一个sql文件,在nacos安装目录下，在数据库中初始化他。</li>
<li>修改Nacos安装目录下的application.properties，用户名和密码。</li>
<li>此时可以重启nacos,那么就会改为使用我们自己的mysql。</li>
</ol>
<h3 id="集群版（mysql数据库）："><a href="#集群版（mysql数据库）：" class="headerlink" title="集群版（mysql数据库）："></a>集群版（mysql数据库）：</h3><p>环境要求：1个nginx+3个nacos注册中心+1个mysql。nacos下载linux版。</p>
<ol>
<li><p>在linux主机上安装nacos。</p>
</li>
<li><p>进入nacos安装包下的自带的sql文件，mysql中执行该sql文件。</p>
</li>
<li><p>修改nacos安装目录下的application.properties：</p>
</li>
<li><p>linux服务器上nacos的集群配置cluster.conf：</p>
<p><img src="http://cdn.rongshen2020.com/2020103a37.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020103a38.png"></p>
<p>这些ip必须是hostname -i 能够识别的IP。</p>
</li>
<li><p>我们这里就不将nacos配置在不同节点上了,就放在一个linux节点上。既然要在一个节点上启动不同Nacos实例,就要修改startup.sh,使其根据不同端口启动不同Nacos实例。</p>
</li>
<li><p>配置nginx：</p>
<ol>
<li><p>修改nginx.conf</p>
<p><img src="http://cdn.rongshen2020.com/2020103a39.png"></p>
</li>
</ol>
</li>
<li><p>启动nacos：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./startup.sh -p <span class="number">3333</span></span><br><span class="line"></span><br><span class="line">./startup.sh -p <span class="number">4444</span></span><br><span class="line"></span><br><span class="line">./startup.sh -p <span class="number">5555</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动nginx</p>
</li>
<li><p>测试：</p>
<p>访问192.168.111.144:1111。如果可以进入nacos的web界面,就证明安装成功了</p>
</li>
<li><p>将一个payment微服务注册到nacos集群</p>
<p><img src="http://cdn.rongshen2020.com/2020103a40.png"></p>
</li>
<li><p>进入nacos的web界面：可以看到我们刚启动的微服务。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之Gateway</title>
    <url>/2020/09/28/springcloud%E4%B9%8BGateway/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第7章，Gateway微服务网关。</p>
</blockquote>
<span id="more"></span>


<p>gateway：n.大门口; 门道; 出入口; (通往其他地区的) 门户; 途径; 方法; 手段;</p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Gateway 是一个基于HTTP协议的restful的API网关。可以作为统一的API接入层。</p>
<p>SpringCloud Gateway是Spring cloud的一个全新项目，基于spring 5.0+springboot 2.0 和project reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的API路由管理模式。</p>
<p>springcloud gateway作为spring cloud生态系统中的网关，目标是替代Zuul，在spring cloud 2.0 以上版本中，没有对新版本的zuul 2.0以上最新高性能版本进行集成，任然是使用的zuul 1.x非reactor模式的老版本。而为了提升网关的性能，springcloud gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架netty。</p>
<p>springcloud gateway的目标是统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>
<h3 id="源码架构："><a href="#源码架构：" class="headerlink" title="源码架构："></a>源码架构：</h3><p><img src="http://cdn.rongshen2020.com/2020928a1.png"></p>
<h3 id="能干什么？"><a href="#能干什么？" class="headerlink" title="能干什么？"></a>能干什么？</h3><ol>
<li>反向代理</li>
<li>鉴权</li>
<li>流量控制</li>
<li>熔断</li>
<li>日志监控</li>
</ol>
<h3 id="gateway在那一层呢？"><a href="#gateway在那一层呢？" class="headerlink" title="gateway在那一层呢？"></a>gateway在那一层呢？</h3><p><img src="http://cdn.rongshen2020.com/2020928a2.png"></p>
<h3 id="Gateway与Zuul的区别："><a href="#Gateway与Zuul的区别：" class="headerlink" title="Gateway与Zuul的区别："></a>Gateway与Zuul的区别：</h3><h4 id="我们为什么选择Gateway："><a href="#我们为什么选择Gateway：" class="headerlink" title="我们为什么选择Gateway："></a>我们为什么选择Gateway：</h4><ol>
<li><p>Netflix不太靠谱，zuul2.0一直跳票，迟迟不发布</p>
<p><img src="http://cdn.rongshen2020.com/2020928a3.png"></p>
</li>
<li><p>Spingcloud gateway具有如下特性：</p>
<p><img src="http://cdn.rongshen2020.com/2020928a4.png"></p>
</li>
<li><p>springcloud gateway与zuul的区别：</p>
<p><img src="http://cdn.rongshen2020.com/2020928a5.png"></p>
</li>
</ol>
<h4 id="zuul1-x模型："><a href="#zuul1-x模型：" class="headerlink" title="zuul1.x模型："></a>zuul1.x模型：</h4><p><img src="http://cdn.rongshen2020.com/2020928a6.png"></p>
<h4 id="webFlux是什么："><a href="#webFlux是什么：" class="headerlink" title="webFlux是什么："></a>webFlux是什么：</h4><p><img src="http://cdn.rongshen2020.com/2020928a7.png"></p>
<h2 id="Gateway的三大核心概念："><a href="#Gateway的三大核心概念：" class="headerlink" title="Gateway的三大核心概念："></a>Gateway的三大核心概念：</h2><p><strong>route路由</strong></p>
<p>路由是构建网关的基本模块，他由ID，目标URI(统一资源标识符)一系列的断言和过滤器组成，如果断言为true则匹配该路由。就是根据某些规则将请求发送到指定服务上。</p>
<p><strong>predicate断言</strong></p>
<p>参考的是java8.util.function.Predicate。开发人员可以匹配HTTP请求中所有内容（例如请求头和请求参数），如果请求与断言相匹配则进行路由。</p>
<p><strong>filter过滤</strong></p>
<p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者后，对该请求进行修改。路由前后，过滤请求的。</p>
<p><strong>总体来说就是：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020928a8.png"></p>
<h2 id="Gateway工作流程："><a href="#Gateway工作流程：" class="headerlink" title="Gateway工作流程："></a>Gateway工作流程：</h2><p><img src="http://cdn.rongshen2020.com/2020928a9.png"></p>
<p><strong>解释上图：</strong>客户端spring cloud gateway发出请求。然后gateway handler mapping中找到与请求相匹配的路由，将其发送到gateway web handler。</p>
<p>​    handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。过滤器之间用虚线分开是因为过滤器可能会发送代理请求之前的（“pre”）或之后的（”post“）执行业务逻辑。</p>
<p>​            Filter在pre类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等。在post类型的过滤器可以做响应内容、响应头的修改，日志输出，流量监控等有非常重要的作用。</p>
<p><strong>核心逻辑就是：路由转发+执行过滤器链</strong></p>
<h2 id="使用Gateway入门配置："><a href="#使用Gateway入门配置：" class="headerlink" title="使用Gateway入门配置："></a>使用Gateway入门配置：</h2><h3 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h3><p><img src="http://cdn.rongshen2020.com/2020928a10.png"></p>
<h3 id="新建实例："><a href="#新建实例：" class="headerlink" title="新建实例："></a>新建实例：</h3><ol>
<li><p>建moudle，<code>cloud-gateway-gateway9527</code></p>
</li>
<li><p>POM</p>
<p><strong>不要web依赖模块，否则不能正常启动</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--不要web依赖模块--&gt;</span><br><span class="line">&lt;!--gateway--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--引入自己的api通用包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--一般基础通用配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9527</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-gateway</span><br><span class="line">  # 这些网关配置就是在配置8001的端口访问</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: payment_routh</span><br><span class="line">          uri: http:<span class="comment">//localhost:8001</span></span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/payment/get<span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - id: payment_routh2</span></span><br><span class="line"><span class="comment">          uri: http://localhost:8001</span></span><br><span class="line"><span class="comment">          predicates:</span></span><br><span class="line"><span class="comment">            - Path=/payment/create</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">eureka:</span></span><br><span class="line"><span class="comment">  instance:</span></span><br><span class="line"><span class="comment">    hostname: cloud-gateway-service</span></span><br><span class="line"><span class="comment">  client:</span></span><br><span class="line"><span class="comment">    register-with-eureka: true  #false表示不向注册中心注册自己</span></span><br><span class="line"><span class="comment">    fetch-registry: true #false表示自己端就是注册中心</span></span><br><span class="line"><span class="comment">    service-url:</span></span><br><span class="line"><span class="comment">      defaultZone: http://localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020928a11.png"></p>
</li>
<li><p>主启动类</p>
</li>
<li><p>9527网关如何做路由映射？</p>
<ul>
<li><p>cloud-provider-payment8001看看controller的访问地址</p>
</li>
<li><p>我们目前不想暴露8001端口，希望在8001外面套一层9527</p>
</li>
</ul>
</li>
<li><p>YML新增网关配置</p>
<p><img src="http://cdn.rongshen2020.com/2020928a12.png"></p>
</li>
<li><p>测试</p>
<ol>
<li>启动7001，启动8001，启动9527网关</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020928a13.png"></p>
<p><strong>那么这样就可以通过9527网关端口去访问8001里面的服务了。</strong></p>
</li>
</ol>
<h2 id="Gateway配置路由的两种配置方式："><a href="#Gateway配置路由的两种配置方式：" class="headerlink" title="Gateway配置路由的两种配置方式："></a>Gateway配置路由的两种配置方式：</h2><ol>
<li>在配置文件yml中配置。前面使用的就是这种方式</li>
<li>代码中注入RouteLocator的Bean<ul>
<li>配置一个id为route-name的路由规则，当访问地址为<code>http://localhost:9527/guonei</code>时会自动转发到地址：<code>http://news.baidu.com/guonei</code></li>
</ul>
</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020928a14.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span></span>&#123;</span><br><span class="line">        RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line">        routes.route(<span class="string">&quot;path_routh1&quot;</span>,</span><br><span class="line">                r -&gt; r.path(<span class="string">&quot;/guonei&quot;</span>).uri(<span class="string">&quot;http://news.baidu.com/guonei&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> routes.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://cdn.rongshen2020.com/2020928a15.png"></p>
<h2 id="Gateway配置动态路由："><a href="#Gateway配置动态路由：" class="headerlink" title="Gateway配置动态路由："></a>Gateway配置动态路由：</h2><h3 id="通过微服务名实现动态路由。"><a href="#通过微服务名实现动态路由。" class="headerlink" title="通过微服务名实现动态路由。"></a>通过微服务名实现动态路由。</h3><ol>
<li><p>默认情况下gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能。</p>
<p><img src="http://cdn.rongshen2020.com/2020928a16.png"></p>
</li>
<li><p>YML</p>
</li>
</ol>
<ul>
<li>需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。lb://serviceName是spring cloud geteway在微服务中自动为我们创建的负载均衡的uri。</li>
</ul>
<ol start="3">
<li><p>测试：</p>
<ul>
<li>这时我们在写一个服务提供者8002模块，同样注册进eureka。这时我们使用微服务名进行调用：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020928a17.png"></p>
<ul>
<li>可以发现，这里也实现了负载均衡。</li>
</ul>
</li>
</ol>
<h2 id="Gateway中的Predicate断言："><a href="#Gateway中的Predicate断言：" class="headerlink" title="Gateway中的Predicate断言："></a>Gateway中的Predicate断言：</h2><p>spring cloud gateway将路由匹配作为spring webflux handlerMapping基础架构的一部分。spring cloud gateway包括许多的内置route predicate工厂。所有这些predicate都与HTTP请求的不同属性匹配。多个predicate工厂可以进行组合。</p>
<p>spring cloud gateway创建route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以赋值给Route。Spring cloud Gateway包括许多内置的Route predicate factories。</p>
<p>所有这些route都匹配HTTP请求的不同属性。多种工厂可以组合，并通过逻辑and。</p>
<p>我们之前配置的path就是断言的一种：</p>
<p><img src="http://cdn.rongshen2020.com/2020928a18.png"></p>
<p><strong>这个断言表示，如果外部访问路径是指定路径，就路由到指定的微服务上</strong></p>
<p>可以看到，这里有一个Path，这个就是断言的一种，以下是断言的类型也可以在输出台找到：</p>
<p><img src="http://cdn.rongshen2020.com/2020928a19.png"></p>
<ol>
<li><p>After Route Predicate：</p>
<p>可以指定，只有在指定时间后，才可以路由到指定微服务。</p>
<p>获取当前时区和时间：</p>
<p><img src="http://cdn.rongshen2020.com/2020928a20.png"></p>
<ul>
<li>如果访问时间早于这个时间，那么就访问失败。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020928a21.png"></p>
</li>
<li><p>Before：与After类似，指定时间之前才可以访问。</p>
</li>
<li><p>Between：需要指定两个时间，逗号隔开，在他们之间的时间才可以访问。</p>
</li>
<li><p>Cookie：只有包含某些指定cookie(key,value)的请求才可以路由。</p>
</li>
<li><p>Header：只有包含指定请求头的请求,才可以路由。</p>
</li>
<li><p>host：只有指定主机的才可以访问。</p>
</li>
<li><p>method：只有指定请求才可以路由,比如get请求…</p>
</li>
<li><p>path：只有访问指定路径,才进行路由。比如访问,/abc才路由</p>
</li>
<li><p>Query：必须带有请求参数才可以访问。</p>
</li>
</ol>
<h2 id="Gateway中的Filter过滤器："><a href="#Gateway中的Filter过滤器：" class="headerlink" title="Gateway中的Filter过滤器："></a>Gateway中的Filter过滤器：</h2><p><img src="http://cdn.rongshen2020.com/2020928a22.png"></p>
<p>**生命周期:**在请求进入路由之前,和处理请求完成,再次到达路由之前。</p>
<p><strong>种类：</strong>GatewayFilter和GlobalFilter。</p>
<ol>
<li><p>GateWayFilter,单一的过滤器：</p>
<p>与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤。官网上有31个。</p>
</li>
<li><p>GlobalFilter,全局过滤器：</p>
<p>官网上有10个。</p>
<p><img src="http://cdn.rongshen2020.com/2020928a23.png"></p>
</li>
</ol>
<p><strong>自定义过滤器：</strong></p>
<p>实现两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>,<span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;*********come in MyLogGateWayFilter: &quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(username))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****用户名为Null 非法用户,(┬＿┬)&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);<span class="comment">//给人家一个回应</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试链接：<code>localhost:9527/payment/lb?uname=z3</code></p>
<p>这个自定义过滤器能干嘛？可以全局日志记录和统一网关鉴权。</p>
<p>然后启动服务,即可,因为过滤器通过@Componet已经加入到容器了。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之OpenFeign</title>
    <url>/2020/09/27/springcloud%E4%B9%8BOpenFeign/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第五章，OpenFeign服务调用</p>
</blockquote>
<span id="more"></span>


<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul>
<li><p>feign翻译：v.假装，装作，佯装(有某种感觉或生病、疲倦等)</p>
</li>
<li><p>feign已经停止更新了，openFeign成为替代。</p>
<p>feign是一个声明式webService客户端。使用feign能让编写的web service客户端更加简单。它的使用方法是定义一个服务接口，在上面添加注解。</p>
</li>
<li><p>feign让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。</p>
<p>主要是利用了OpenFeign的声明式方式定义Web服务客户端；其次，通过集成Ribbon或Eureka实现负载均衡的HTTP客户端。</p>
</li>
</ul>
<h2 id="Feign能干什么？"><a href="#Feign能干什么？" class="headerlink" title="Feign能干什么？"></a>Feign能干什么？</h2><p><img src="http://cdn.rongshen2020.com/2020927a1.png"></p>
<h3 id="Feign与OpenFeign的区别："><a href="#Feign与OpenFeign的区别：" class="headerlink" title="Feign与OpenFeign的区别："></a>Feign与OpenFeign的区别：</h3><p><img src="http://cdn.rongshen2020.com/2020927a2.png"></p>
<h2 id="OpenFeign使用示例："><a href="#OpenFeign使用示例：" class="headerlink" title="OpenFeign使用示例："></a>OpenFeign使用示例：</h2><p>总体模块：</p>
<p><img src="http://cdn.rongshen2020.com/2020927a3.png"></p>
<p><strong>解释：</strong>两个服务生产者provider，一个消费者。eureka继续作为服务注册中心。</p>
<p>provider生产者模块没有特别之处，重点在consumer消费者模块。</p>
<h3 id="consumer消费者模块："><a href="#consumer消费者模块：" class="headerlink" title="consumer消费者模块："></a>consumer消费者模块：</h3><ul>
<li>Feign是在消费端调用的。rest风格的client端，也就是消费侧。</li>
</ul>
<ol>
<li><p>POM依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--openFeign--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-order-service</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #表示是否将自己注册进eureka,本consumer不需要注册</span><br><span class="line">    fetch-registry: true #这是貌似不是关键点，表示从eureka中获取服务的注册信息</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类，添加注解<code>@EnableFeignClients</code></p>
</li>
<li><p>业务类：</p>
<p><img src="http://cdn.rongshen2020.com/2020927a4.png"></p>
<ol>
<li><p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这里的<code>@FeignClient(value = &quot;CLOUD-PAYMENT-SERVICE&quot;)</code>调用的就是eureka中注册的两个payment服务。</li>
</ul>
</li>
<li><p>测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020927a5.png"></p>
</li>
<li><p>总结：</p>
<p>feign使用默认的ribbon负载轮询算法实现负载均衡的功能。</p>
<p><img src="http://cdn.rongshen2020.com/2020927a6.png"></p>
</li>
</ol>
<h2 id="OpeFeign超时控制："><a href="#OpeFeign超时控制：" class="headerlink" title="OpeFeign超时控制："></a>OpeFeign超时控制：</h2><p><strong>OpenFeign默认等待服务端处理的时间是1秒,超过1秒,直接报错。为了避免这种情况，我们需要设置feign客户端的超时控制。</strong></p>
<p>主要在配置文件中修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 设置feign客户端超时时间（openFeign默认支持ribbon）</span><br><span class="line"># 一个是建立连接时间，一个是连接后到取到可用资源的时间</span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">5000</span></span><br><span class="line">  ConnectTimeout: <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p><strong>因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制</strong></p>
<ol>
<li><p>增加下provider的controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理正确，但是需要耗费3秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serverPort;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增加下consumer的controller和service：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// OpenFeign客户端一般默认等待1秒钟</span></span><br><span class="line">       <span class="keyword">return</span> paymentFeignService.paymentFeignTimeout();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentFeignTimeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>如果不写ribbon的超时控制，那么就会报错。</p>
</li>
<li><p>测试：多刷新下就会发现使用的是轮询算法。</p>
<p><img src="http://cdn.rongshen2020.com/2020927a7.png"></p>
</li>
</ul>
<h2 id="OpenFeign日志打印功能："><a href="#OpenFeign日志打印功能：" class="headerlink" title="OpenFeign日志打印功能："></a>OpenFeign日志打印功能：</h2><p>feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中HTTP请求的细节。说白了就是对Feign接口的调用情况进行监控和输出。</p>
<p><strong>Feign的日志级别：</strong></p>
<ol>
<li>NONE：默认的，不显示任何日志。</li>
<li>BASIC：仅记录请求方法、url、响应状态码及执行时间。</li>
<li>HEADERS：除了BASIC中定义的信息之外，还有请求的和响应的头信息。</li>
<li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li>
</ol>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><img src="http://cdn.rongshen2020.com/2020927a8.png"></p>
<ol>
<li><p>编写配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为指定的类设置日志级别，在配置文件中：</p>
<p><img src="http://cdn.rongshen2020.com/2020927a9.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.aaron.springcloud.service.PaymentFeignService: debug</span><br></pre></td></tr></table></figure></li>
<li><p>测试，那么你就可以在控制台查看：</p>
<p><img src="http://cdn.rongshen2020.com/2020927a10.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之Ribbon</title>
    <url>/2020/09/26/springcloud%E4%B9%8BRibbon/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第四章，ribbon负载均衡。</p>
</blockquote>
<span id="more"></span>

<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>ribbon翻译：n. (用于捆绑或装饰的)带子;丝带;带状物;狭长的东西;绶带;勋带。</p>
<p>基于Netflix Ribbon实现的一套客户端 负载均衡的工具。主要功能是提供客户端的软件负载均衡算法和服务调用。我们也可以使用自定义的负载均衡算法。</p>
<p>ribbon目前进入了维护模式，估计很难更新了。</p>
<h3 id="LB-load-balance-负载均衡是什么？"><a href="#LB-load-balance-负载均衡是什么？" class="headerlink" title="LB(load balance)负载均衡是什么？"></a>LB(load balance)负载均衡是什么？</h3><p>简单来说就是将用户的请求平摊到多个服务器上，从而达到系统的HA(高可用)。常见的负载均衡软件有Nginx，LVS等。</p>
<h3 id="Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别："><a href="#Ribbon本地负载均衡客户端VS-Nginx服务端负载均衡区别：" class="headerlink" title="Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别："></a>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别：</h3><p>nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。</p>
<p>Ribbon本地均衡负载，在调用微服务接口的时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</p>
<h3 id="进程内LB："><a href="#进程内LB：" class="headerlink" title="进程内LB："></a>进程内LB：</h3><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择一个合适的服务器。</p>
<p>Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方地址。</p>
<p><strong>一句话就是：ribbon=负载 均衡+RestTemplate调用</strong></p>
<h2 id="Ribbon负载均衡演示："><a href="#Ribbon负载均衡演示：" class="headerlink" title="Ribbon负载均衡演示："></a>Ribbon负载均衡演示：</h2><ul>
<li><p>架构说明：</p>
<p>Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p>
<p><img src="http://cdn.rongshen2020.com/2020926b1.png"></p>
</li>
</ul>
<ul>
<li><p>之前我们没有引入ribbon，但是仍可以使用eureka实现负载均衡。这是因为spring-cloud-starter-netflix-eureka-client自带了ribbon的引用。</p>
<p><img src="http://cdn.rongshen2020.com/2020926b2.png"></p>
</li>
</ul>
<ul>
<li><p>二说RestTemplate的使用：</p>
<p><img src="http://cdn.rongshen2020.com/2020926b3.png"></p>
<ul>
<li>restTemplate里面的getForObject和getForEntity方法返回的是不一样的，但是显示在前端都是一样的。如果想要看到更详细的信息，建议使用getForEntity。如果只是要一个json字符串，那么使用getForObject就可以了。</li>
</ul>
</li>
</ul>
<h2 id="Ribbon核心组件IRule："><a href="#Ribbon核心组件IRule：" class="headerlink" title="Ribbon核心组件IRule："></a>Ribbon核心组件IRule：</h2><ul>
<li><p>IRule：根据特定算法从服务列表中选取一个要访问的服务。</p>
<p><img src="http://cdn.rongshen2020.com/2020926b4.png"></p>
</li>
<li><p>ribbon自带的7种负载均衡算法，由IRule来负责调用，你还可以自定义：</p>
<ol>
<li>RoundRobinRule：轮询；</li>
<li>RandomRule：随机；</li>
<li>AvailabilityFilteringRule：会先过滤掉由于多次访问故障而处于断路器状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问；</li>
<li>WeightedResponseTimeRule：根据平均响应时间计算所有服务的权重，响应时间越快的服务权重越大被选中的概率越大。刚启动时如果统计信息不足，则使用RoundRobinRule（轮询）策略，等统计信息足够，会切换到WeightedResponseTimeRule；</li>
<li>RetryRule：先按照RoundRobinRule（轮询）策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务；</li>
<li>BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务；</li>
<li>ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择服务器；</li>
</ol>
</li>
</ul>
<h2 id="Ribbon负载均衡算法如何切换："><a href="#Ribbon负载均衡算法如何切换：" class="headerlink" title="Ribbon负载均衡算法如何切换："></a>Ribbon负载均衡算法如何切换：</h2><ol>
<li><p>修改<code>cloud-consumer-order80</code></p>
</li>
<li><p>注意配置细节</p>
<p><img src="http://cdn.rongshen2020.com/2020926b5.png"></p>
<ul>
<li>所以要跳出主启动类所在的包<code>com.aaron.springcloud</code>包。</li>
</ul>
</li>
<li><p>新建package，<code>com.aaron.myrule</code></p>
</li>
<li><p>上面包下新建MySelfRule规则类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<ol>
<li>eureka注册中心：</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020926b6.png"></p>
<ol start="2">
<li>可以看到，之前的轮询算法变成了随机算法。</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020926b7.png"></p>
</li>
</ol>
<h2 id="深刻理解Ribbon负载均衡算法："><a href="#深刻理解Ribbon负载均衡算法：" class="headerlink" title="深刻理解Ribbon负载均衡算法："></a>深刻理解Ribbon负载均衡算法：</h2><p>负载均衡算法：rest接口第几次请求数%服务器集群总数量=实际调用服务器位置下标，每次服务重启后rest接口数从1开始。</p>
<p><img src="http://cdn.rongshen2020.com/2020926b8.png"></p>
<p>最后两点就是：IRule源码与手写轮询算法。这里我不懂，所以就不写了。。。涉及到JUC、自旋锁和CAS。</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之bus微服务消息总线</title>
    <url>/2020/09/30/springcloud%E4%B9%8Bbus%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第9章，Bus服务总线。</p>
</blockquote>
<span id="more"></span>


<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>我们前一章学习了config配置中心，需要去探索如何实现分布式自动刷新配置功能？spring cloud bus配合spring cloud config使用可实现配置的自动动态刷新。</p>
<p><strong>bus支持两种消息代理中间件：RabbitMQ和kafka</strong></p>
<p><strong>下面两张图实现原理并不同，注意看</strong></p>
<p>图一如下：利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置。</p>
<p><img src="http://cdn.rongshen2020.com/2020930a1.png"></p>
<p>springcloud bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当做微服务间的通信通道。</p>
<p>图二如下：利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。</p>
<p><img src="http://cdn.rongshen2020.com/2020930a2.png"></p>
<h3 id="为什么会被称为消息总线？"><a href="#为什么会被称为消息总线？" class="headerlink" title="为什么会被称为消息总线？"></a>为什么会被称为消息总线？</h3><p><img src="http://cdn.rongshen2020.com/2020930a3.png"></p>
<p>所以要结合消息中间件一起使用。</p>
<hr>
<h2 id="进行实例演示之前，需要先安装好RabbitMQ或kafka消息中间件，配置好环境。"><a href="#进行实例演示之前，需要先安装好RabbitMQ或kafka消息中间件，配置好环境。" class="headerlink" title="进行实例演示之前，需要先安装好RabbitMQ或kafka消息中间件，配置好环境。"></a><strong>进行实例演示之前，需要先安装好RabbitMQ或kafka消息中间件，配置好环境。</strong></h2><h2 id="springcloud-Bus动态刷新全局广播："><a href="#springcloud-Bus动态刷新全局广播：" class="headerlink" title="springcloud Bus动态刷新全局广播："></a>springcloud Bus动态刷新全局广播：</h2><h3 id="新建一个3366客户端模块："><a href="#新建一个3366客户端模块：" class="headerlink" title="新建一个3366客户端模块："></a>新建一个3366客户端模块：</h3><ol>
<li><p>新建模块，<code>cloud-config-client-3366</code></p>
</li>
<li><p>POM</p>
</li>
<li><p>bootstrap.yml</p>
</li>
<li><p>主启动</p>
</li>
<li><p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;serverPort:&quot;</span>+serverPort+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;configInfo:&quot;</span>+configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="设计思想："><a href="#设计思想：" class="headerlink" title="设计思想："></a>设计思想：</h3><p>之前的图一利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置。</p>
<p>图二利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。</p>
<p>图二的架构显然更加适合该动态刷新全局广播，图一不适合的原因如下：</p>
<p><img src="http://cdn.rongshen2020.com/2020930a4.png"></p>
<h3 id="给cloud-config-center-3344配置中心服务端添加消息总线支持："><a href="#给cloud-config-center-3344配置中心服务端添加消息总线支持：" class="headerlink" title="给cloud-config-center-3344配置中心服务端添加消息总线支持："></a>给cloud-config-center-3344配置中心服务端添加消息总线支持：</h3><ol>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--添加消息总线RabbitMQ支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># rabbitMQ相关配置</span><br><span class="line">rabbitmq:</span><br><span class="line">  host: localhost</span><br><span class="line">  port: <span class="number">5672</span></span><br><span class="line">  username: guest</span><br><span class="line">  password: guest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rabbitMQ相关配置，暴露bus刷新配置的端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;bus-refresh&#x27;</span></span><br></pre></td></tr></table></figure>



<p><img src="http://cdn.rongshen2020.com/2020930a5.png"></p>
</li>
</ol>
<h3 id="给cloud-config-client-3355客户端添加消息总线支持："><a href="#给cloud-config-client-3355客户端添加消息总线支持：" class="headerlink" title="给cloud-config-client-3355客户端添加消息总线支持："></a>给cloud-config-client-3355客户端添加消息总线支持：</h3><ol>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--添加消息总线RabbitMQ支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020930a6.png"></p>
</li>
</ol>
<h3 id="给cloud-config-client-3366客户端添加消息总线支持："><a href="#给cloud-config-client-3366客户端添加消息总线支持：" class="headerlink" title="给cloud-config-client-3366客户端添加消息总线支持："></a>给cloud-config-client-3366客户端添加消息总线支持：</h3><p>和3355一致。</p>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><ol>
<li><p>修改github上的版本号，给3344发送<code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;</code></p>
<p><img src="http://cdn.rongshen2020.com/2020930a7.png"></p>
<p>就不用还给3355和3366发了。</p>
</li>
<li><p>浏览器测试：<code>http://localhost:3344/config-dev.yml</code></p>
</li>
<li><p>客户端测试：<code>http://localhost:3355/configInfo</code>和<code>http://localhost:3366/configInfo</code></p>
</li>
<li><p>获取配置，发现都已经刷新了。</p>
</li>
</ol>
<p><strong>实现一次修改、广播通知，处处生效。</strong></p>
<p>所以这里就是运维人员给3344推送一次刷新就可以实现全部的刷新。完美解决了config的动态刷新问题。</p>
<h2 id="springcloud-Bus动态刷新定点通知："><a href="#springcloud-Bus动态刷新定点通知：" class="headerlink" title="springcloud Bus动态刷新定点通知："></a>springcloud Bus动态刷新定点通知：</h2><p>要求：还是以上述实验为例，我们不想通知3366，只通知3355更新信息。</p>
<p><img src="http://cdn.rongshen2020.com/2020930a8.png"></p>
<p>那么上述的话实现就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;</span></span><br></pre></td></tr></table></figure>





<p><strong>下一篇博客讲解stream消息驱动模块，见！</strong></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之config分布式配置中心</title>
    <url>/2020/09/29/springcloud%E4%B9%8Bconfig%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第8章，Config微服务配置中心</p>
</blockquote>
<span id="more"></span>


<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><h3 id="分布式系统面临的配置问题："><a href="#分布式系统面临的配置问题：" class="headerlink" title="分布式系统面临的配置问题："></a>分布式系统面临的配置问题：</h3><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的颗粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p>
<p>springcloud提供了configServer来解决这个问题，我们每一个微服务自己带一个application.yml，那么上百个配置文件的管理就是一个大问题了。</p>
<p>就像我们之前学的：可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库。那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以。</p>
<h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p><img src="http://cdn.rongshen2020.com/2020929a1.png"></p>
<p>springcloud config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供一个中心化的外部配置。</p>
<p><img src="http://cdn.rongshen2020.com/2020929a2.png"></p>
<h3 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h3><ol>
<li><p>集中管理配置文件</p>
</li>
<li><p>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release</p>
</li>
<li><p>运行期间动态调整配置，不在需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</p>
</li>
<li><p>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</p>
</li>
<li><p>将配置信息以REST接口的形式暴露，post/curl访问刷新即可</p>
</li>
</ol>
<h2 id="Config服务端配置与测试："><a href="#Config服务端配置与测试：" class="headerlink" title="Config服务端配置与测试："></a>Config服务端配置与测试：</h2><ol>
<li><p>使用github作为配置中心的仓库：</p>
<ul>
<li><p>在github上创建一个配置中心仓库，注意得是公共仓库。不然会有密码问题。</p>
</li>
<li><p>从github上将仓库代码拷贝至本地</p>
</li>
</ul>
</li>
<li><p>新建config模块：</p>
<p><code>cloud-config-center-3344</code>，它即为cloud的配置中心模块cloudConfig Center。</p>
</li>
<li><p>pom：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--config--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--web--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--一般基础通用配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3344</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-config-center</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https:<span class="comment">//github.com/Aaron-boom/springcloud-config.git # git@github.com:Aaron-boom/springcloud-config.git,测试不通git的,使用https的。https://github.com/Aaron-boom/springcloud-config.git</span></span><br><span class="line">          search-paths:</span><br><span class="line">            - springcloud-config</span><br><span class="line">      label: master</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p>主启动类注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改hosts（可选）：</p>
<p>windows下修改host文件的映射，可以使用主机名进行访问。</p>
</li>
<li><p>配置完成：</p>
<p>启动eureka7001和config3344</p>
<p><img src="http://cdn.rongshen2020.com/2020929a3.png"></p>
</li>
<li><p>读取配置文件的3种规则：</p>
<ul>
<li>第一种</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020929a4.png"></p>
<ul>
<li>第二种</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020929a5.png"></p>
<ul>
<li>第三种</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020929a6.png"></p>
<ul>
<li><p>总结：</p>
<p><img src="http://cdn.rongshen2020.com/2020929a7.png"></p>
</li>
</ul>
</li>
</ol>
<h2 id="Config客户端配置与测试："><a href="#Config客户端配置与测试：" class="headerlink" title="Config客户端配置与测试："></a>Config客户端配置与测试：</h2><p>使用3355客户端去访问3344服务端的配置信息。</p>
<ol>
<li><p>创建Config客户端项目：<code>cloud-config-client-3355</code></p>
</li>
<li><p>pom：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--config的客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件：</p>
<ul>
<li><p>bootstrap.yml是什么：</p>
<p><img src="http://cdn.rongshen2020.com/2020929a8.png"></p>
</li>
<li><p>内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">3355</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-client</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master # 分支名称</span><br><span class="line">      name: config # 配置文件名称</span><br><span class="line">      profile: dev # 读取后缀名称 上述三个综合：master分支上config-dev.yml的配置文件被读取为http://config-3344.com/master/conf</span><br><span class="line">      uri: http:<span class="comment">//localhost:3344 # 配置中心地址</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientMain3355</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientMain3355.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/configInfo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020929a9.png"></p>
<ul>
<li>注意，读取的是config的info信息。</li>
</ul>
<h2 id="Config客户端之动态刷新："><a href="#Config客户端之动态刷新：" class="headerlink" title="Config客户端之动态刷新："></a>Config客户端之动态刷新：</h2><p>上面3355确实获取到了配置文件,但是如果此时配置文件修改了,3355是获取不到的。3344可以实时获取到最新配置文件,但是3355却获取不到，除非重启服务。</p>
<p><img src="http://cdn.rongshen2020.com/2020929a10.png"></p>
<p>springcloud bus配合springcloud config使用可以实现配置的动态刷新~</p>
<ol>
<li><p>修改3355模块</p>
</li>
<li><p>POM引入actuator监控</p>
</li>
<li><p>修改Yml，暴露监控端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>@RefreshScope</code>业务类Controller修改</p>
<p><img src="http://cdn.rongshen2020.com/2020929a11.png"></p>
</li>
<li><p>此时再修改github–》3344–》3355，再次测试：</p>
<ol>
<li><code>http://localhost:3344/master/config-dev.yml</code></li>
<li><code>http://localhost:3355/configInfo</code></li>
<li>这里是没有生效的，3344访问到变化了，3355没有访问到</li>
</ol>
</li>
<li><p>补救</p>
<ul>
<li>需要运维人员发送post请求（必须是post）刷新3355。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020929a12.png"></p>
<ul>
<li>此时再访问：<code>http://localhost:3355/configInfo</code>成功修改。</li>
</ul>
</li>
</ol>
<p><strong>此时新的问题又出现了，就是：</strong></p>
<ol>
<li>假如有多个微服务客户端。。。。怎么可能去手动刷新？每个微服务都post请求一次？</li>
<li>可否广播。一次通知，处处生效？</li>
<li>我们想大范围的刷新，怎么办？</li>
</ol>
<h3 id="其实这就是下一章笔记要讲的，使用springcloud-bus配合springcloud-config使用可以实现配置的动态刷新"><a href="#其实这就是下一章笔记要讲的，使用springcloud-bus配合springcloud-config使用可以实现配置的动态刷新" class="headerlink" title="其实这就是下一章笔记要讲的，使用springcloud bus配合springcloud config使用可以实现配置的动态刷新~"></a>其实这就是下一章笔记要讲的，使用springcloud bus配合springcloud config使用可以实现配置的动态刷新~</h3>]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之consul</title>
    <url>/2020/09/25/springcloud%E4%B9%8Bconsul/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第三章，consul分布式服务发现和配置管理系统。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>consul的安装和之前一样，放在linux虚拟机上。同样写一个服务提供者和消费者，查看是否注册进consul，再测试下服务调用，结束。</li>
<li>consul版本：consul_1.8.3_linux_amd64.zip</li>
</ul>
<h2 id="consul简介："><a href="#consul简介：" class="headerlink" title="consul简介："></a>consul简介：</h2><ul>
<li><p>之前的博客已经介绍了两种微服务发现与注册的框架，一个是eureka（翻译：int. 我发现了，我找到了），一个是zookeeper（直译为动物园管理员），以及最后的这个consul（翻译：n. 领事；（古罗马的）两执政官之一）。他们三个取名或多或少都有发现与管理的意思，很有趣。</p>
<p>不过在我写这篇博客的时候，无意中在OSCHINA看到了关于consul的这句话：</p>
</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020925a1.png"></p>
<ul>
<li>或许有其他的原因，他们也给了个合理的解释。但是咋们还是得继续努力。</li>
</ul>
<h2 id="consul的安装："><a href="#consul的安装：" class="headerlink" title="consul的安装："></a>consul的安装：</h2><ul>
<li><p>因为需要unzip命令，结果yum下载不了。这里踩了很多坑，网卡配置需要严谨。我在虚拟机创建时网卡设置为的是桥接模式。之前由于未和物理主机设置同一网段，导致ping不同外网。但是可以ping通物理主机，物理主机也可以ping通它，好奇怪。</p>
<p><img src="http://cdn.rongshen2020.com/2020925a2.png"></p>
</li>
<li><p>安装consul：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unzip  consul_1<span class="number">.8</span>.3_linux_amd64.zip</span><br><span class="line">    </span><br><span class="line">#解压之后只有一个consul文件，将该文件复制到bin目录下</span><br><span class="line">cp -rp consul /bin/</span><br><span class="line"></span><br><span class="line">#执行一下</span><br><span class="line">consul</span><br><span class="line"></span><br><span class="line">我就直接去看UI 界面</span><br><span class="line">[root@localhost consul]# consul agent -dev -ui</span><br><span class="line">游览器本地：http:<span class="comment">//ip地址:8500/</span></span><br><span class="line"></span><br><span class="line">我在虚拟机中为了其他机器能访问 加参数-client</span><br><span class="line">[root@localhost consul]# consul agent -dev -ui -client 0.0.0.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="服务提供者注册进consul："><a href="#服务提供者注册进consul：" class="headerlink" title="服务提供者注册进consul："></a>服务提供者注册进consul：</h2><ol>
<li><p>建module，<code>cloud-provider-consul-payment8006</code></p>
</li>
<li><p>pom：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--consul--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--web开发依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>yml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8006</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consul-provider-payment</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line">      port: <span class="number">8500</span></span><br><span class="line">      discovery:</span><br><span class="line">        service-name: $&#123;spring.application.name&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类：</p>
<p>无特别。</p>
</li>
<li><p>controller，随便写一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentConsul</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with consul：&quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020925a3.png"></p>
</li>
<li><p>这时，consul的ui界面这里出现了一个错误（大致意思我理解为服务检查错误）：</p>
<p><img src="http://cdn.rongshen2020.com/2020925a4.png"></p>
<p>百度解决方案时，说是主机映射的问题。</p>
<p>修改主机映射文件hosts之后，完美解决服务未发现问题。</p>
<p><img src="http://cdn.rongshen2020.com/2020925a5.png"></p>
</li>
</ol>
<h2 id="服务消费者注册进consul："><a href="#服务消费者注册进consul：" class="headerlink" title="服务消费者注册进consul："></a>服务消费者注册进consul：</h2><ol>
<li><p>建model，<code>cloud-consumer-consul-order80</code></p>
</li>
<li><p>pom</p>
</li>
<li><p>yml</p>
</li>
<li><p>主启动类</p>
</li>
<li><p>RestTemplate和之前都是一样的</p>
</li>
<li><p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsulController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://consul-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/consul&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020925a6.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之eureka集群</title>
    <url>/2020/09/23/springcloud%E4%B9%8Beureka%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<blockquote>
<p>简介：springcloud微服务架构的笔记。第一章，使用Eureka微服务发现与注册测试。</p>
</blockquote>
<span id="more"></span>

<h2 id="环境版本："><a href="#环境版本：" class="headerlink" title="环境版本："></a>环境版本：</h2><p>maven：3.6.3</p>
<p>jdk：1.8.0_151</p>
<h2 id="Eureka简介："><a href="#Eureka简介：" class="headerlink" title="Eureka简介："></a>Eureka简介：</h2><p>Eureka是Netflix（网飞公司）开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。</p>
<p>Eureka包含两个组件：Eureka Server和Eureka Client。</p>
<p>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</p>
<p>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p>
<h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><p><img src="http://cdn.rongshen2020.com/2020923a1.png"></p>
<h2 id="项目简介："><a href="#项目简介：" class="headerlink" title="项目简介："></a>项目简介：</h2><p><img src="http://cdn.rongshen2020.com/2020923a2.png"></p>
<ul>
<li><code>cloud-api-commons</code>主要是抽离出实体类，后期方便各模块进行调用。减少代码的冗余。</li>
<li><code>cloud-provider-payment8001</code>与<code>cloud-provider-payment8002</code>作为微服务的提供者。</li>
<li><code>cloud-consumer-order80</code>作为微服务的消费者。</li>
<li><code>cloud-eureka-server7001</code>和<code>cloud-eureka-server7002</code>作为微服务的服务注册中心。</li>
</ul>
<h2 id="代码简介："><a href="#代码简介：" class="headerlink" title="代码简介："></a>代码简介：</h2><h3 id="父项目的pom依赖："><a href="#父项目的pom依赖：" class="headerlink" title="父项目的pom依赖："></a>父项目的pom依赖：</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;modules&gt;</span><br><span class="line">      &lt;module&gt;cloud-api-commons&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;cloud-provider-payment8001&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;cloud-provider-payment8002&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;cloud-consumer-order80&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;cloud-eureka-server7001&lt;/module&gt;</span><br><span class="line">      &lt;module&gt;cloud-eureka-server7002&lt;/module&gt;</span><br><span class="line">  &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 统一管理jar包版本 --&gt;</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">      &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">      &lt;junit.version&gt;4.12&lt;/junit.version&gt;</span><br><span class="line">      &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;</span><br><span class="line">      &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;</span><br><span class="line">      &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;</span><br><span class="line">      &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;</span><br><span class="line">      &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version  --&gt;</span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line">          &lt;!--spring boot <span class="number">2.2</span><span class="number">.2</span>--&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">              &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">              &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;!--spring cloud Hoxton.SR1--&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;Hoxton.SR1&lt;/version&gt;</span><br><span class="line">              &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">              &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;!--spring cloud alibaba <span class="number">2.1</span><span class="number">.0</span>.RELEASE--&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">              &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">              &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">              &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">      &lt;/dependencies&gt;</span><br><span class="line">  &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">      &lt;plugins&gt;</span><br><span class="line">          &lt;plugin&gt;</span><br><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">              &lt;configuration&gt;</span><br><span class="line">                  &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">                  &lt;addResources&gt;true&lt;/addResources&gt;</span><br><span class="line">              &lt;/configuration&gt;</span><br><span class="line">          &lt;/plugin&gt;</span><br><span class="line">      &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure>



<h3 id="公用api模块："><a href="#公用api模块：" class="headerlink" title="公用api模块："></a>公用api模块：</h3><p>后面各模块引用时记得在他们的pom中加入依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h3 id="服务提供者模块："><a href="#服务提供者模块：" class="headerlink" title="服务提供者模块："></a>服务提供者模块：</h3><p>分为3层，dao/service/controller层，记得写接口是一个好习惯。。。</p>
<p>这三层的代码没有特别之处。主启动类上记得加上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span>  <span class="comment">//表示该主启动类作为eureka的client进行注册</span></span><br></pre></td></tr></table></figure>

<p>pom主要是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- eureka-client客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--实体类的api公用依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt; </span><br></pre></td></tr></table></figure>

<p>这里主要介绍配置文件的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-payment-service</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: org.gjt.mm.mysql.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/db2019?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    druid:</span><br><span class="line">      validation-query: select <span class="number">1</span></span><br><span class="line">      test-<span class="keyword">while</span>-idle: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">  type-aliases-package: com.aaron.springcloud.entities</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">eureka:</span></span><br><span class="line"><span class="comment">  client:</span></span><br><span class="line"><span class="comment">    register-with-eureka: true #表示是否将自己注册进eureka</span></span><br><span class="line"><span class="comment">    fetch-registry: true # 表示自己端不是注册中心</span></span><br><span class="line"><span class="comment">    service-url:</span></span><br><span class="line"><span class="comment">      defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka #集群版</span></span><br><span class="line"><span class="comment">#      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka #集群版，配置本地host映射</span></span><br></pre></td></tr></table></figure>

<p>两个服务提供者可以在eureka中注册一样的服务名，因为后期order模块可以使用常量写死。方便做负载均衡。</p>
<h3 id="服务消费者模块："><a href="#服务消费者模块：" class="headerlink" title="服务消费者模块："></a>服务消费者模块：</h3><p>自写配置类，做一个负载均衡，这也是eureka自带的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务消费者的重点在于controller模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>; <span class="comment">//这个就是eureka注册里面的大写</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/payment/create&quot;</span>,payment, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到将服务提供者一侧的url写死，这里就是其在eureka中注册的名，全大写。使用RestTemplate进行调用。</p>
<h3 id="Eureka模块："><a href="#Eureka模块：" class="headerlink" title="Eureka模块："></a>Eureka模块：</h3><p>首先主启动类的注解：<code>@EnableEurekaServer</code>注意！！！</p>
<p>主要在yml配置文件处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7001</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka7001.com  #eureka服务端的实例名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false  #表示不向注册中心注册自己</span><br><span class="line">    fetch-registry: false #false表示自己端就是注册中心</span><br><span class="line">    #设置与eureka server交互地址，查询服务和注册服务都需要依赖该地址,这里写依赖的兄弟server主机</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7002/eureka/    # 集群版就是指向其他的主机</span></span><br></pre></td></tr></table></figure>



<p>项目至此大致介绍了各模块的重点，但是其中的细节问题可能需要自己去摸索。项目的启动顺序也需要注意下：依次启动eureka，payment模块，order模块。</p>
<p>测试时可以看到实现了eureka自带的轮询负载。</p>
<p><img src="http://cdn.rongshen2020.com/2020923a3.png"></p>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><h3 id="Eureka的web界面修饰："><a href="#Eureka的web界面修饰：" class="headerlink" title="Eureka的web界面修饰："></a>Eureka的web界面修饰：</h3><p>修改主机名和显示服务主机IP在配置文件中配置即可。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#  instance:</span><br><span class="line">#    instance-id: payment8001 # 修改服务主机名</span><br><span class="line">#    prefer-ip-address: true # 显示服务主机IP地址</span><br></pre></td></tr></table></figure>

<p>主要修改的是如下的信息：</p>
<p><img src="http://cdn.rongshen2020.com/2020923a4.png"></p>
<h3 id="服务发现discovery："><a href="#服务发现discovery：" class="headerlink" title="服务发现discovery："></a>服务发现discovery：</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息。</p>
<p>使用方法主要是一个注解和一个注解标签：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">privet DiscoveryClient discoverClient;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020923a5.png"></p>
<p>还需要在主启动类上添加：<code>@EnableDiscoveryClient</code></p>
<h3 id="Eureka自我保护："><a href="#Eureka自我保护：" class="headerlink" title="Eureka自我保护："></a>Eureka自我保护：</h3><p>也就是服务界面的这句话：</p>
<p><img src="http://cdn.rongshen2020.com/2020923a6.png"></p>
<p>自我保护简介：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Eureka的自我保护机制用最通俗的语言说就是：好死不如赖活着。</span><br><span class="line">长时间没有访问、检测不到心跳，或者修改实例名称，eureka启动自我保护机制.即：某一个时刻，某一个微服务不可用了，eureka不会立即清理，依旧会对该微服务的信息进行保存.</span><br><span class="line">    </span><br><span class="line">一句话：某时刻某一个微服不可用了，eureka不会立刻清理，依旧会对改微服的信息进行保存。</span><br></pre></td></tr></table></figure>

<p>关闭这个很简单，配置里添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server: </span><br><span class="line">	enable-self-preservation: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>也可以设置eureka心跳检测与续约时间.</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之sleuth微服务链路跟踪</title>
    <url>/2020/10/01/springcloud%E4%B9%8Bsleuth%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第十一章，sleuth微服务链路跟踪。</p>
</blockquote>
<span id="more"></span>

<p>sleuth:侦探。</p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求的最后失败。</p>
<p>springcloud sleuth提供了一套完整的服务跟踪解决方案，在分布式系统中提供追踪解决方案并且兼容支持zipkin。</p>
<h2 id="搭建链路监控步骤："><a href="#搭建链路监控步骤：" class="headerlink" title="搭建链路监控步骤："></a>搭建链路监控步骤：</h2><h3 id="安装zipkin："><a href="#安装zipkin：" class="headerlink" title="安装zipkin："></a>安装zipkin：</h3><p>springcloud从F版起已经不需要自己构建Zipkin server了，只需要调用jar包即可。</p>
<p>下载地址：<code>https://zipkin.io/pages/quickstart.html</code></p>
<p>运行下载的jar包：<code>java -jar zipkin-server-2.21.7-exec.jar</code></p>
<p>监控端口是：9411</p>
<p><img src="http://cdn.rongshen2020.com/2020101b1.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020101b2.png"></p>
<h3 id="使用sleuth："><a href="#使用sleuth：" class="headerlink" title="使用sleuth："></a>使用sleuth：</h3><p><img src="http://cdn.rongshen2020.com/2020101b3.png"></p>
<p>可以将之前的服务提供者8001和order80即可测试下。</p>
<ol>
<li><p>引入POM：</p>
<p>这个包虽然叫zipkin但是,里面包含了zpikin与sleuth。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--包含了sleuth+zipkin--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件：</p>
<p><img src="http://cdn.rongshen2020.com/2020101b4.png"></p>
</li>
<li><p>修改80：</p>
<p>添加pom。与上面是一样的</p>
<p>添加配置。与上面也是一样的</p>
</li>
<li><p>测试：</p>
<p>启动7001，8001,80,9411。访问：<code>http://localhost;9411</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之stream消息驱动</title>
    <url>/2020/10/01/springcloud%E4%B9%8Bstream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第十章，Stream消息驱动。</p>
</blockquote>
<span id="more"></span>


<p>消息中间件有：ActiveMQ，RabbitMQ，RocketMQ，Kafka。</p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。</p>
<p><img src="http://cdn.rongshen2020.com/2020101a1.png"></p>
<p>消息中间件有很多，如果一个项目用到了很多的消息中间件，那么在日常的<strong>切换、维护和开发</strong>上会很复杂。</p>
<p>一句话就是：屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。</p>
<h3 id="设计思想："><a href="#设计思想：" class="headerlink" title="设计思想："></a>设计思想：</h3><h4 id="标准MQ："><a href="#标准MQ：" class="headerlink" title="标准MQ："></a>标准MQ：</h4><p><img src="http://cdn.rongshen2020.com/2020101a2.png"></p>
<ul>
<li>生产者、消费者之间靠消息媒介传递信息Message内容</li>
<li>消息必须走特定的通道。消息通道MessageChannel</li>
<li>消息通道里的消息如何被消费，谁负责收发处理？，消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器订阅</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020101a3.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020101a4.png"></p>
<h4 id="Spring-Cloud-Stream是怎么屏蔽底层差异的"><a href="#Spring-Cloud-Stream是怎么屏蔽底层差异的" class="headerlink" title="Spring Cloud Stream是怎么屏蔽底层差异的?"></a>Spring Cloud Stream是怎么屏蔽底层差异的?</h4><p><img src="http://cdn.rongshen2020.com/2020101a5.png"></p>
<p>绑定器Binder：</p>
<p><img src="http://cdn.rongshen2020.com/2020101a6.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020101a7.png"></p>
<p>通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件之间的隔离。</p>
<p><img src="http://cdn.rongshen2020.com/2020101a8.png"></p>
<h4 id="Spring-Cloud-Stream的业务流程"><a href="#Spring-Cloud-Stream的业务流程" class="headerlink" title="Spring Cloud Stream的业务流程:"></a>Spring Cloud Stream的业务流程:</h4><p><img src="http://cdn.rongshen2020.com/2020101a9.png"></p>
<p>类似flume中的channel,source,sink  估计是借鉴(抄袭)的source用于获取数据(要发送到mq的数据)。channel类似SpringCloudStream中的中间件,用于存放source接收到的数据,或者是存放binder拉取的数据。</p>
<h4 id="Stream的编码API和常用注解："><a href="#Stream的编码API和常用注解：" class="headerlink" title="Stream的编码API和常用注解："></a>Stream的编码API和常用注解：</h4><p><img src="http://cdn.rongshen2020.com/2020101a10.png"></p>
<h2 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h2><ul>
<li><strong>首先RabbitMQ环境已经OK了</strong></li>
<li>工程中新建三个子模块：<ul>
<li><code>cloud-stream-rabbitmq-provider8801</code>,作为生成者进行发消息模块。</li>
<li><code>cloud-stream-rabbitmq-consumer8802</code>,作为生成者进行发消息模块。</li>
<li><code>cloud-stream-rabbitmq-consumer8803</code>,作为生成者进行发消息模块。</li>
</ul>
</li>
</ul>
<h2 id="消息驱动之生产者："><a href="#消息驱动之生产者：" class="headerlink" title="消息驱动之生产者："></a>消息驱动之生产者：</h2><ol>
<li><p>新建moudle，<code>cloud-stream-rabbitmq-provider8801</code></p>
</li>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--stream,rabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8801</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-stream-provider</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      binders: # 在此处配置要绑定的rabbitmq的服务信息；</span><br><span class="line">        defaultRabbit: # 表示定义的名称，用于于binding整合</span><br><span class="line">          type: rabbit # 消息组件类型</span><br><span class="line">          environment: # 设置rabbitmq的相关的环境配置</span><br><span class="line">            spring:</span><br><span class="line">              rabbitmq:</span><br><span class="line">                host: localhost</span><br><span class="line">                port: <span class="number">5672</span></span><br><span class="line">                username: guest</span><br><span class="line">                password: guest</span><br><span class="line">      bindings: # 服务的整合处理</span><br><span class="line">        output: # 这个名字是一个通道的名称</span><br><span class="line">          destination: studyExchange # 表示要使用的Exchange名称定义</span><br><span class="line">          content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain”</span><br><span class="line">          binder: defaultRabbit # 设置要绑定的消息服务的具体设置</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client: # 客户端进行Eureka注册的配置</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka</span></span><br><span class="line">  instance:</span><br><span class="line">    lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒）</span><br><span class="line">    lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒）</span><br><span class="line">    instance-id: send-8801.com  # 在信息列表时显示主机名称</span><br><span class="line">    prefer-ip-address: true     # 访问的路径变为IP地址</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类StreamMQMain8801：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMQMain8801</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SpringApplication.run(StreamMQMain8801.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务类：</p>
<ul>
<li>service：写一个接口与实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(Source.class)</span> <span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output; <span class="comment">// 消息发送管道</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build());</span><br><span class="line">        System.out.println(<span class="string">&quot;*****serial: &quot;</span>+serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>controller：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/sendMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<ul>
<li>启动eureka，rabbitMQ<code>rabbitmq-server.bat</code>，stream8801。访问<code>http://localhost:8801/sendMessage</code></li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020101a11.png"></p>
</li>
</ol>
<h2 id="消息驱动之消费者："><a href="#消息驱动之消费者：" class="headerlink" title="消息驱动之消费者："></a>消息驱动之消费者：</h2><h3 id="消费者8802："><a href="#消费者8802：" class="headerlink" title="消费者8802："></a>消费者8802：</h3><ol>
<li><p>新建moudle，<code>cloud-stream-rabbitmq-consumer8802</code></p>
</li>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--stream,rabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<p><img src="http://cdn.rongshen2020.com/2020101a12.png"></p>
</li>
<li><p>主启动类StreamMQMain8802：</p>
</li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageListenerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1号,-----&gt;接受到的消息: &quot;</span>+message.getPayload()+<span class="string">&quot;\t  port: &quot;</span>+serverPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：测试8801发送，8802接受消息，<code>localhost:8801/sendMessage</code>,8802控制台输出：</p>
<p><img src="http://cdn.rongshen2020.com/2020101a13.png"></p>
</li>
</ol>
<h3 id="Stream之消息重复消费："><a href="#Stream之消息重复消费：" class="headerlink" title="Stream之消息重复消费："></a>Stream之消息重复消费：</h3><p>依照8802，clone一份8803，<code>cloud-stream-rabbitmq-consumer8803</code></p>
<ol>
<li>启动RabbitMQ，7001进行服务注册，8801进行消息生产。</li>
<li>8802在消息消费</li>
<li>8803也在消息消费</li>
</ol>
<p>那么，运行后就有两个问题：<strong>重复消费和消息持久化问题。</strong></p>
<h4 id="如何解决重复消费问题："><a href="#如何解决重复消费问题：" class="headerlink" title="如何解决重复消费问题："></a>如何解决重复消费问题：</h4><p><img src="http://cdn.rongshen2020.com/2020101a14.png"></p>
<h2 id="分组消费与持久化："><a href="#分组消费与持久化：" class="headerlink" title="分组消费与持久化："></a>分组消费与持久化：</h2><p>将众多消费者放进同一个消费者组，那么就可以解决重复消费的问题。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次，不同的组是可以消费的，同一个组发生竞争关系，只有其中一个会被消费。那么我们来试验下以下两种情况：</p>
<h3 id="8802和8803分成不同的组："><a href="#8802和8803分成不同的组：" class="headerlink" title="8802和8803分成不同的组："></a>8802和8803分成不同的组：</h3><ol>
<li><p>8802改YML：</p>
<p><img src="http://cdn.rongshen2020.com/2020101a15.png"></p>
</li>
<li><p>8803改YML：</p>
<p><img src="http://cdn.rongshen2020.com/2020101a16.png"></p>
</li>
<li><p>结论</p>
<ul>
<li>当8801发送消息时，消费者同时在接受消息。出现了消息的重复消费。</li>
</ul>
</li>
</ol>
<h3 id="8802和8803在相同的组："><a href="#8802和8803在相同的组：" class="headerlink" title="8802和8803在相同的组："></a>8802和8803在相同的组：</h3><ol>
<li><p>都在aaron组</p>
</li>
<li><p>结论</p>
<ul>
<li>当8801发送消息时，只有一个消费者会接受消息，且是轮询接收的。</li>
</ul>
</li>
</ol>
<h3 id="消息持久化："><a href="#消息持久化：" class="headerlink" title="消息持久化："></a>消息持久化：</h3><p>那么消息持久化怎么实现？看例子：</p>
<ol>
<li>停止8802/8803并去掉8802分组的group: aarona，8803的不用去。</li>
<li>8801先发送4条消息到rabbitmq</li>
<li>先启动8802.无分组属性配置，后台没有打印出来消息</li>
<li>先启动8803，有分组属性配置，后台打印出来了MQ上的消息。</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之zookeeper</title>
    <url>/2020/09/24/springcloud%E4%B9%8Bzookeeper/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第二章，zookeeper，作为微服务注册中心。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>在前一章中，学习了eureka。由于eureka停止更新，使用zookeeper代替eureka。</li>
</ul>
<p>zookeeper是一个分布式协调工具，可以实现注册中心功能。需要关闭linux服务器防火墙后启动zookeeper服务器。zookeeper取代eureka，作为服务注册中心。这一次，我在本地使用linux虚拟机来运行zookeeper，请提前安装好jdk和zookeeper。</p>
<h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><ul>
<li>环境说明：<ul>
<li>jdk：1.8.0_121</li>
<li>zookeeper：3.5.6</li>
</ul>
</li>
<li>请先保证在虚拟机上启动了zookeeper：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020924a1.png"></p>
<h2 id="服务的提供者模块："><a href="#服务的提供者模块：" class="headerlink" title="服务的提供者模块："></a>服务的提供者模块：</h2><ol>
<li><p>新建<code>cloud-provider-payment8004</code></p>
</li>
<li><p>POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"># 服务别名，注册zookeeper到注册中心的名称</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-payment</span><br><span class="line">  cloud:</span><br><span class="line">    zookeeper:</span><br><span class="line">      connect-string: <span class="number">10.10</span><span class="number">.2</span><span class="number">.70</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8004</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8004.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentzk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper:&quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动8004注册进zookeeper</p>
<p>查看zookeeper的状态：<code>./zkServer.sh status</code></p>
<p>启动zookeeper：<code>./zkServer.sh start</code></p>
<p>启动客户端：<code>./zkCli.sh</code></p>
<p>查看zookeeper的链接数：<code>ls /</code></p>
</li>
<li><p>测试：</p>
<ol>
<li><p>先启动zookeeper的客户端，此时微服务已经注册进去zookeeper了：</p>
<p><img src="http://cdn.rongshen2020.com/2020924a2.png"></p>
</li>
<li><p>在测试访问：</p>
<p><img src="http://cdn.rongshen2020.com/2020924a3.png"></p>
</li>
</ol>
</li>
</ol>
<ol start="8">
<li><p>如果你继续访问zookeeper客户端的话，你也可以得到一个json格式的字符串，这里面就是微服务的信息：</p>
<p><img src="http://cdn.rongshen2020.com/2020924a4.png"></p>
</li>
</ol>
<h2 id="zookeeper实行临时节点策略："><a href="#zookeeper实行临时节点策略：" class="headerlink" title="zookeeper实行临时节点策略："></a>zookeeper实行临时节点策略：</h2><ul>
<li>当你关闭该服务节点时，该节点在zookeeper中不会马上消失，需要等待一段时间，就是“心跳”：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020924a5.png"></p>
<ul>
<li>最后，zookeeper将该节点移除了。证明该节点是临时节点。</li>
</ul>
<h2 id="服务的消费者模块："><a href="#服务的消费者模块：" class="headerlink" title="服务的消费者模块："></a>服务的消费者模块：</h2><ol>
<li><p>新建module：<code>cloud-consumerzk-order80</code></p>
</li>
<li><p>POM</p>
</li>
<li><p>YML</p>
</li>
<li><p>主启动类：</p>
</li>
<li><p>业务类：</p>
<ol>
<li><p>cloud-consumerzk-order80去调用8004服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderZKController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL = <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/zk&quot;</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>测试，同时启动80与8004和zookeeper：</p>
<ol>
<li><p>查看zookeeper，可以看到所有的微服务：</p>
<p><img src="http://cdn.rongshen2020.com/2020924a6.png"></p>
</li>
</ol>
<ol start="2">
<li><p>同时测试下服务调用：</p>
<p><img src="http://cdn.rongshen2020.com/2020924a7.png"></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>spring分析-spring自定义注解扫描机制</title>
    <url>/2021/07/01/spring%E5%88%86%E6%9E%90-spring%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>spring如何自定义注解扫描？</p>
<span id="more"></span>



<blockquote>
<p>参考：</p>
<p><a href="https://my.oschina.net/u/131091/blog/1637898">https://my.oschina.net/u/131091/blog/1637898</a></p>
<p><a href="https://www.jianshu.com/p/2b993ced6a4c">https://www.jianshu.com/p/2b993ced6a4c</a></p>
</blockquote>
<h1 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h1><p>扫描自定义注解，自定义注解集成Component</p>
<p><img src="https://cdn.rongshen2020.com/20210701a1.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyServiceTest &#123;</span><br><span class="line">    <span class="comment">// 继承了@Component的功能</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 他们的基本作用和 <span class="doctag">@Component</span> 完全一样都是标明某个类是</span></span><br><span class="line"><span class="comment">     * Spring的Bean，需要 Spring容器 进行管理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">( )</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyServiceTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefintionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String[] beanDefintionNames = beanDefinitionRegistry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String beanDefinitonName : beanDefintionNames)&#123;</span><br><span class="line">            BeanDefinition beanDefinition = beanDefinitionRegistry.getBeanDefinition(beanDefinitonName);</span><br><span class="line">            System.out.println(beanDefinition.getAttribute(<span class="string">&quot;key&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个扫描器</span></span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(beanDefinitionRegistry);</span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(MyServiceTest.class));</span><br><span class="line">        scanner.scan(<span class="string">&quot;com.aaron.springScan.annotation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext appcationContext = <span class="keyword">new</span></span><br><span class="line">                AnnotationConfigApplicationContext(<span class="string">&quot;com.aaron.springScan.service&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到这个类</span></span><br><span class="line">        UserService userService = (UserService)appcationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>如果不想让自定义注解集成Component可以实现吗？答案是肯定可以的，就是要自定义包与类扫描。</strong></p>
<h1 id="rpc项目解析："><a href="#rpc项目解析：" class="headerlink" title="rpc项目解析："></a>rpc项目解析：</h1><p>以下代码在本rpc项目中，<a href="https://gitee.com/AARONRONG/aaron_RpcFramework">https://gitee.com/AARONRONG/aaron_RpcFramework</a></p>
<p>先了解PostProcessor（增强器，后置处理器）：</p>
<p><img src="https://cdn.rongshen2020.com/20210701a2.png"></p>
<h2 id="CustomScannerRegistrar作用："><a href="#CustomScannerRegistrar作用：" class="headerlink" title="CustomScannerRegistrar作用："></a>CustomScannerRegistrar作用：</h2><p>实现<code>ImportBeanDefinitionRegistrar</code>，同时可以继承一些Aware接口，获得spring的一些数据</p>
<ul>
<li>BeanFactoryAware</li>
<li>ResourceLoaderAware</li>
<li>EnvironmentAware</li>
</ul>
<p>但是有一个问题，我们并不知道需要register哪些bean。这里我们还需要借助一个类<code>ClassPathBeanDefinitionScanner</code>，也就是扫描器，通过扫描器获取我们需要注册的bean。</p>
<h3 id="CustomScanner作用："><a href="#CustomScanner作用：" class="headerlink" title="CustomScanner作用："></a>CustomScanner作用：</h3><p><code>CustomScanner作用</code>：就是实现<code>ClassPathBeanDefinitionScanner</code>，通过扫描器获取我们需要注册的bean。</p>
<p>继承的<code>ClassPathBeanDefinitionScanner</code>又继承了<code>ClassPathScanningCandidateComponentProvider</code>类，<code>ClassPathScanningCandidateComponentProvider</code>中有两个TypeFilter集合，includeFilters、excludeFilters。满足任意includeFilters会被加载，同样的满足任意excludeFilters不会被加载。</p>
<p><img src="https://cdn.rongshen2020.com/20210701a3.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自己的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomScanner</span><span class="params">(BeanDefinitionRegistry registry, Class&lt;? extends Annotation&gt; annoType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父类的构造方法,默认调用是this(registry, true);</span></span><br><span class="line">        <span class="keyword">super</span>(registry);</span><br><span class="line">        <span class="comment">// 调用父类的方法addIncludeFilter()方法，注册过滤器，需要扫描的,指定扫描包中的类</span></span><br><span class="line">        <span class="keyword">super</span>.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(annoType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回扫描到添加了某个注解的类的个数，扫描包的路径（basePackages就是路径），</span></span><br><span class="line">    <span class="comment">// String...表示可变参数，就是scan()方法可以接收0到任意个的String类型的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.scan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="SpringBeanPostProcessor作用："><a href="#SpringBeanPostProcessor作用：" class="headerlink" title="SpringBeanPostProcessor作用："></a>SpringBeanPostProcessor作用：</h2><p>经历过以上两步骤之后，bean已经实例化完成了，但初始化还没完成，在初始化bean的前后我们还可以做一些操作，这个时候就用到了<code>BeanPostProcessor</code>这个增强器。</p>
<p><img src="https://cdn.rongshen2020.com/20210701a2.png"></p>
<p><img src="https://cdn.rongshen2020.com/20210701a4.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册服务，添加服务，获取服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line">    <span class="comment">// 选择通信的方式，netty或socket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestTransport rpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取serviceProvider对象，其实现了ServiceProviderImpl接口</span></span><br><span class="line">        <span class="keyword">this</span>.serviceProvider = SingletonFactory.getInstance(ZkServiceProviderImpl.class);</span><br><span class="line">        <span class="comment">// 获取拓展类实例，SPI拓展机制</span></span><br><span class="line">        <span class="keyword">this</span>.rpcClient = ExtensionLoader.getExtensionLoader(RpcRequestTransport.class).getExtension(<span class="string">&quot;netty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring bean实例化之前调用，</span></span><br><span class="line">    <span class="comment">// 去判断类上是否有RpcService注解。如果有的话，就取出group 和version的值。</span></span><br><span class="line">    <span class="comment">// 然后，再调用ServiceProvider的publishService()方法发布服务即可</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcService.class)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with  [&#123;&#125;]&quot;</span>, bean.getClass().getName(), RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// get RpcService annotation</span></span><br><span class="line">            RpcService rpcService = bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            <span class="comment">// build RpcServiceProperties</span></span><br><span class="line"><span class="comment">//            RpcServiceProperties rpcServiceProperties = RpcServiceProperties.builder()</span></span><br><span class="line"><span class="comment">//                    .group(rpcService.group()).version(rpcService.version()).build();</span></span><br><span class="line">            RpcServiceConfig rpcServiceConfig = RpcServiceConfig.builder()</span><br><span class="line">                    .group(rpcService.group())</span><br><span class="line">                    .version(rpcService.version())</span><br><span class="line">                    .service(bean).build();</span><br><span class="line">            <span class="comment">// 注解了@RpcService，发布这个服务</span></span><br><span class="line">            serviceProvider.publishService(rpcServiceConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring bean实例化之后调用</span></span><br><span class="line">    <span class="comment">// 去遍历类上是否有RpcReference注解。如果有的话，我们就通过反射 将这个属性赋值。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = bean.getClass();</span><br><span class="line">        Field[] declaredFields = targetClass.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            RpcReference rpcReference = declaredField.getAnnotation(RpcReference.class);</span><br><span class="line">            <span class="keyword">if</span> (rpcReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//                RpcServiceProperties rpcServiceProperties = RpcServiceProperties.builder()</span></span><br><span class="line"><span class="comment">//                        .group(rpcReference.group()).version(rpcReference.version()).build();</span></span><br><span class="line">                RpcServiceConfig rpcServiceConfig = RpcServiceConfig.builder()</span><br><span class="line">                        .group(rpcReference.group())</span><br><span class="line">                        .version(rpcReference.version()).build();</span><br><span class="line"></span><br><span class="line">                RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(rpcClient, rpcServiceConfig);</span><br><span class="line">                <span class="comment">// 获取代理对象</span></span><br><span class="line">                Object clientProxy = rpcClientProxy.getProxy(declaredField.getType());</span><br><span class="line">                <span class="comment">// setAccessible(true)是Java语言访问检查，可以达到提升反射速度的目的</span></span><br><span class="line">                declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    declaredField.set(bean, clientProxy);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>“虚拟机上部署一个前后端分离项目（若依-ruoyi）实验”</title>
    <url>/2020/06/30/%E2%80%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%8B%A5%E4%BE%9D-ruoyi%EF%BC%89%E5%AE%9E%E9%AA%8C%E2%80%9D/</url>
    <content><![CDATA[<blockquote>
<p>来源于B站UP主CodeSheep。</p>
</blockquote>
<span id="more"></span>

<h1 id="若依（ruoyi）项目部署"><a href="#若依（ruoyi）项目部署" class="headerlink" title="若依（ruoyi）项目部署"></a><center>若依（ruoyi）项目部署</center></h1><blockquote>
<p>该项目是B站UP主程序羊CodeSheep的一个开源在gitee上的项目，参照他的讲解，将这个项目部署在本地的虚拟机上。</p>
</blockquote>
<h1 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h1><ul>
<li><p>这是个一个前后端分离的权限管理系统。</p>
</li>
<li><p>项目来源于：<a href="https://gitee.com/y_project/RuoYi-Vue/blob/master/README.md#only_comment_project">https://gitee.com/y_project/RuoYi-Vue/blob/master/README.md#only_comment_project</a></p>
</li>
<li><p>前端采用Vue、Element UI。</p>
</li>
<li><p>后端采用Spring Boot、Spring Security、Redis &amp; Jwt。</p>
</li>
<li><p>权限认证使用Jwt，支持多终端认证系统。</p>
</li>
<li><p>支持加载动态权限菜单，多方式轻松权限控制。</p>
<p><img src="http://cdn.rongshen2020.com/2020630a1.jpg"></p>
</li>
</ul>
<h1 id="2-虚拟机与环境准备"><a href="#2-虚拟机与环境准备" class="headerlink" title="2. 虚拟机与环境准备"></a>2. 虚拟机与环境准备</h1><ul>
<li><p>准备3台虚拟机，做好一些简单的配置，网卡、防火墙等等。。。</p>
</li>
<li><p>虚拟机的环境配置可以参考下图：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a2.png"></p>
</li>
</ul>
<h1 id="3-代码下载"><a href="#3-代码下载" class="headerlink" title="3. 代码下载"></a>3. 代码下载</h1><ul>
<li>网址：<a href="https://gitee.com/y_project/RuoYi-Vue/blob/master/README.md#only_comment_project">https://gitee.com/y_project/RuoYi-Vue/blob/master/README.md#only_comment_project</a></li>
<li>使用git软件克隆到本地，因为我们还要用编译器做一些修改，之后再上传到服务器上：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/y_project/RuoYi-Vue.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-使用IDEA进行本地导入"><a href="#4-使用IDEA进行本地导入" class="headerlink" title="4. 使用IDEA进行本地导入"></a>4. 使用IDEA进行本地导入</h1><ul>
<li>上述步骤中下载好的代码，现在可以使用IDEA软件打开：</li>
</ul>
<p>  <img src="http://cdn.rongshen2020.com/2020630a3.png"></p>
<h1 id="5-修改配置"><a href="#5-修改配置" class="headerlink" title="5. 修改配置"></a>5. 修改配置</h1><h2 id="5-1-修改数据库配置"><a href="#5-1-修改数据库配置" class="headerlink" title="5.1. 修改数据库配置"></a>5.1. 修改数据库配置</h2><ol>
<li>在IDEA中修改项目src目录下的resource下的application-druid.yml中的数据库配置，分别是数据库所在主机的ip地址，数据库用户名和密码：<br> <img src="http://cdn.rongshen2020.com/2020630a4.png"></li>
<li>在Navicat中创建ry-vue数据库：<br> <img src="http://cdn.rongshen2020.com/2020630a5.png"></li>
<li>将项目中的sql文件导入ry-vue数据库，创建表：<ul>
<li>对应的sql文件位于：<br><img src="http://cdn.rongshen2020.com/2020630a6.png"></li>
<li>导入成功后，ry-vue数据库中有30张表：<br> <img src="http://cdn.rongshen2020.com/2020630a7.png"></li>
</ul>
</li>
</ol>
<h2 id="5-2-修改Redis配置"><a href="#5-2-修改Redis配置" class="headerlink" title="5.2. 修改Redis配置"></a>5.2. 修改Redis配置</h2><ul>
<li>主要修改reids的ip地址和密码：<br><img src="http://cdn.rongshen2020.com/2020630a8.png"></li>
</ul>
<h2 id="5-3-修改日志配置"><a href="#5-3-修改日志配置" class="headerlink" title="5.3. 修改日志配置"></a>5.3. 修改日志配置</h2><ul>
<li>修改日志存放路径（本地路径）和日志的编码格式：<br> <img src="http://cdn.rongshen2020.com/2020630a9.png"></li>
</ul>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><ul>
<li>跑一下，看是否还有故障：</li>
</ul>
<h1 id="6-项目上传、构建、打包"><a href="#6-项目上传、构建、打包" class="headerlink" title="6. 项目上传、构建、打包"></a>6. 项目上传、构建、打包</h1><h2 id="6-1-上传项目"><a href="#6-1-上传项目" class="headerlink" title="6.1. 上传项目"></a>6.1. 上传项目</h2><ul>
<li>借助Xftp工具将前端代码传到/root/ruoyi文件夹下（这里我使用先在本地压缩的方式，防止出现错误）：<br><img src="http://cdn.rongshen2020.com/2020630a10.png"><br>使用<code>unzip</code>命令进行解压。</li>
<li>同理，借助Xftp将后端代码也上传到其他的两台主机上。<br><img src="http://cdn.rongshen2020.com/2020630a11.png"></li>
</ul>
<h2 id="6-2-前端项目构建与打包"><a href="#6-2-前端项目构建与打包" class="headerlink" title="6.2. 前端项目构建与打包"></a>6.2. 前端项目构建与打包</h2><ul>
<li>先安装依赖，需要node.js的支持：<code>npm install --unsafe-perm --registry=https://registry.npm.taobao.org</code></li>
</ul>
<p>  <img src="http://cdn.rongshen2020.com/2020630a12.png"></p>
<ul>
<li>会多出两个文件：<br><img src="http://cdn.rongshen2020.com/2020630a13.png"></li>
<li>开始打包：<br><code>npm run build:prod</code></li>
<li>打包完成之后，会在当前前端项目的目录下生成一个dist目录：<br><img src="http://cdn.rongshen2020.com/2020630a14.png"></li>
</ul>
<h2 id="6-3-后端项目构建与打包（jar包）"><a href="#6-3-后端项目构建与打包（jar包）" class="headerlink" title="6.3. 后端项目构建与打包（jar包）"></a>6.3. 后端项目构建与打包（jar包）</h2><ul>
<li><p>进入到后端代码文件中<code>cd </code>,<br><code>mvn package</code></p>
</li>
<li><p>打包完成之后，会在当前目录下生成一个target文件，里面有我们需要的jar包：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a15.png"></p>
</li>
</ul>
<h2 id="6-4-后端项目构建与打包（war包）"><a href="#6-4-后端项目构建与打包（war包）" class="headerlink" title="6.4. 后端项目构建与打包（war包）"></a>6.4. 后端项目构建与打包（war包）</h2><ul>
<li><p>打war包之前需要先在本地修改一些后端代码。主要有修改pom文件中的打包形式、spring boot容器里面的内置tomcat服务器要去除、添加一个启动类。</p>
</li>
<li><p>pom文件中的打包形式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;com.ruoyi&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;ruoyi&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>pom文件中修改打包时的内置容器tomcat:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringBoot Web容器 --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!--添加如下代码--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">       &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加启动类：<br>创建SpringBootStartApplication.class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruoyi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStartApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources( RuoYiApplication.class );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>我们主要修改了这两个文件，那么我们只要将这两个文件重新上传到后端服务器上。</p>
</li>
</ul>
<p>  <img src="http://cdn.rongshen2020.com/2020630a16.png"></p>
<ul>
<li><p>开始打war包：<br>先执行下清理<code>mvn clean</code>将之前打jar包时的target文件清理掉。记得先将jar包拷贝出来。<br>开始打包<code>mvn package</code>，之后生成target文件，里面有ruoyi.war了。war包需要放入tomcat中才可以运行的。</p>
<p><img src="http://cdn.rongshen2020.com/2020630a17.png"></p>
</li>
</ul>
<h1 id="7-项目服务器部署"><a href="#7-项目服务器部署" class="headerlink" title="7. 项目服务器部署"></a>7. 项目服务器部署</h1><h2 id="7-1-前端项目部署"><a href="#7-1-前端项目部署" class="headerlink" title="7.1. 前端项目部署"></a>7.1. 前端项目部署</h2><ul>
<li><p>在前端代码的主机上配置nginx，我的nginx是在/usr/local/nginx/conf/nginx.conf下，前端代码所在目录为/ruoyi/dist，修改如下代码：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a18.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020630a19.png"></p>
</li>
<li><p>启动nginx（nginx -s quit 正常停止或关闭Nginx），之后通过ip地址即可访问。</p>
</li>
</ul>
<p>  <img src="http://cdn.rongshen2020.com/2020630a20.png"></p>
<h2 id="7-2-后端项目部署"><a href="#7-2-后端项目部署" class="headerlink" title="7.2. 后端项目部署"></a>7.2. 后端项目部署</h2><h3 id="7-2-1-jar包部署"><a href="#7-2-1-jar包部署" class="headerlink" title="7.2.1. jar包部署"></a>7.2.1. jar包部署</h3><ul>
<li><p>进入后端文件夹，执行jar包<code>nohup java -jar ruoyi.jar &amp;</code></p>
</li>
<li><p>连接前后端，在前端随便输入验证码点击登录，F12查看页面代码：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a21.png"></p>
</li>
<li><p>重新进入nginx.conf文件中修改下配置，添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">location /prod-api/ &#123;</span><br><span class="line">	proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">	proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;</span><br><span class="line">	proxy_set_header Host $http_host;</span><br><span class="line">	proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">	proxy_pass http:<span class="comment">//192.168.3.23:8080/;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.rongshen2020.com/2020630a22.png"></p>
</li>
<li><p>重新加载下nginx：<code>/nginx -s reload</code>，之后便可以登录进入后台。</p>
</li>
</ul>
<h3 id="7-2-2-war包部署"><a href="#7-2-2-war包部署" class="headerlink" title="7.2.2. war包部署"></a>7.2.2. war包部署</h3><ul>
<li><p>先杀死之前的jar包进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux | grep java</span><br><span class="line"><span class="built_in">kill</span> -9 进程号</span><br></pre></td></tr></table></figure></li>
<li><p>查看tomcat的部署路径，拷贝ruoyi.war到该tomcat的webapps路径下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tomcat/webapps</span><br><span class="line">cp /ruoyi/ruoyi.war ./</span><br></pre></td></tr></table></figure></li>
<li><p>重启tomcat：<code>tomcat.service restart</code>，其自动生成了ruoyi文件夹。</p>
</li>
</ul>
<p>  <img src="http://cdn.rongshen2020.com/2020630a23.png"></p>
<ul>
<li><p>但是，访问后端主机的该端口，还是如下图所示，不能直接以根目录进行访问：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a24.png"></p>
</li>
<li><p>进入tomcat安装包的配置文件server.xml中修改配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;Context path=<span class="string">&quot;/&quot;</span> docBase=<span class="string">&quot;/usr/local/tomcat/webapps/ruoyi&quot;</span> reloadable=<span class="string">&quot;false&quot;</span>&gt;&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020630a25.png"></p>
</li>
<li><p>再重新启动下tomcat。</p>
</li>
</ul>
<h3 id="7-2-3-配置Nginx代理和转发"><a href="#7-2-3-配置Nginx代理和转发" class="headerlink" title="7.2.3. 配置Nginx代理和转发"></a>7.2.3. 配置Nginx代理和转发</h3><ul>
<li><p>配置前端中的nginx.conf：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a26.png"></p>
</li>
<li><p>代理转发也配置一下：</p>
<p><img src="http://cdn.rongshen2020.com/2020630a27.png"></p>
</li>
<li><p>重启nginx。</p>
</li>
</ul>
<h3 id="7-2-4-多实例集群部署"><a href="#7-2-4-多实例集群部署" class="headerlink" title="7.2.4. 多实例集群部署"></a>7.2.4. 多实例集群部署</h3><ul>
<li><p>安装之前的7.2.2中war包部署的方式，将所有的后端主机中全部使用war包部署。之后通过设置前端主机的nginx的代理和转发，实现多集群部署和负载均衡。也就是之前的这张图片设想的那样。</p>
<p><img src="http://cdn.rongshen2020.com/2020630a2.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
      </categories>
      <tags>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>《The Irishman》-电影分享</title>
    <url>/2020/04/14/%E3%80%8AThe-Irishman%E3%80%8B-%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>如果你也喜欢:马丁·斯科塞斯，艾尔·帕西诺，罗伯特·德尼罗，乔·佩西。可以看看这部，不知道你是否能感觉到一个黑帮电影时代的终结。</p>
</blockquote>
<span id="more"></span> 

<p>故事来自那本非虚构小说《听说你刷房子了》（I Heard You Paint Houses），书中的故事来自作者对晚年弗兰克·希兰的采访与研究，弗兰克曾是美国黑手党布法利诺犯罪家族的杀手。书名的听说你又刷房子了，则是杀人时，血溅得满墙的意思，非常黑帮了。  </p>
<p>对于黑帮电影的喜爱，是源于《教父》里面的马龙·白兰度，当电影的前奏《The Godfather (Love Theme)》响起时，脑海里浮现的是坐在旋转皮质黑色椅子上的维托·柯里昂，他背对着你，用浓厚的意大利西西里口音说着：“我会给他一个无法拒绝的理由”。  </p>
<p>哈哈，写到这，浑身都是鸡皮疙瘩，对于偶像的喜爱。  </p>
<p>观影感受更像《美国往事》，时间跨度很大。里面有两个慢镜头的感觉，非常奇妙，可以自行去体会。一个是暗杀的慢镜头，一个是结婚的慢镜头。如果一块小小的屏幕上挤满了那么多的面孔，并且每个面孔的表情又是那么夸张，虽然不知道用什么语言形容。但这种观影感受确实让人记忆犹新。  </p>
<p>看懂这部电影，不仅需要对于美国的黑帮历史有着很强的好奇心（或者说对于黑帮历史有着迷恋），其实更重要的是对于导演和演员的崇敬和fans之情。我能想到喜欢他的人，见证过斯科塞斯的电影年代的辉煌，有着自己阅历和青春里电影故事的“中年大叔”。你也能想到多年以后和别人谈论起《古惑仔》的自己吗？  </p>
<p><img src="http://cdn.rongshen2020.com/irishman1.png"></p>
<p>影片主要是围绕这三个人展开，基于不要剧透，观影前可以看看这段历史。对于我自己，这段历史是次要的，演员和导演一直都是最吸引我的。虽然电影使用了减龄技术，但三位影帝的老态还是掩盖不了，德尼罗最甚，让人唏嘘。不过我觉得丝毫没有减分，仿佛每一个迟缓的动作都在诉说时代的终结。其实这部片子还是要看个人对于黑帮电影历史的了解，以及自己的观影经历。我相信那些厉害的影评家能写出非常棒，让人啧啧称奇的影评。《赌城风云》、《好家伙》、《出租车司机》、《好莱坞往事》等等，这些没看过的，我想以后自己可以补补了~  </p>
<p>下面是我关注的博主的一篇微博，我很喜欢去看这些老男人（old man）说的话，当然由于经历问题，所以理解不深也理解不了。  </p>
<p><img src="http://cdn.rongshen2020.com/irishman2.jpg"></p>
<p>电影算不上“深度”上的好电影，但是它的气场确实那么的大。成为了一个电影时代的标志，甚至是一个电影时代的墓碑，这是多么的伟大~</p>
<p>最后分享一个特别喜欢的影评：</p>
<p><img src="http://cdn.rongshen2020.com/irishman3.png"></p>
]]></content>
      <categories>
        <category>movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title>《一一》</title>
    <url>/2021/05/05/%E3%80%8A%E4%B8%80%E4%B8%80%E3%80%8B/</url>
    <content><![CDATA[<p>“电影发明以后，人类的生命至少比以前延长了三倍”</p>
<span id="more"></span>

<p>已经看了两部杨德昌的电影，《牯岭街少年杀人事件》和这次的《一一》。许久没有看过这种慢节奏的文艺片了，这种电影还是挺适合半夜来看的，慢节奏让你有了可以一边看一边思考的时间。之前也沉迷于快感式的阅读，尤其是短篇小说，也买了一些来看，情节的跌宕起伏引人入胜，上过瘾。后来手机的出现，大部分的时间被它占据，尤其是之后的短视频，也让我每天消耗掉了大量的时间。每天无差别的花费一些时间在这些娱乐软件中，阅读的快感也消磨殆尽了，去图书馆也要假装拿上一本文艺书，仿佛是对自己愧疚的补偿。后来由于有了看技术博客的习惯和自己也写一些技术总结的原因，正在想慢慢的捡起这些阅读和写作的兴趣。</p>
<p>《一一》给我的感觉，一直是很沉闷和慢节奏的，直到最后洋洋的话，又将人从模糊带回到现实的思考中。爸爸妈妈在自己的故事中，似乎也想明白了“本来以为，我再活一次的话，也许会有什么不一样。结果……还是差不多，没什么不同。只是突然觉得，再活一次的话，好像……真的没那个必要，真的没那个必要。”，时间会给我们最好的答案，我们会厌倦说教式的表达，有些还是自己去经历才能得到感悟（就算偏执，也好过后悔）。导演给了模糊的镜头，模糊的台词，模糊的细节。一切仿佛都交给了观众，关于人生、爱情、家庭、道德，每个人有自己的困惑，朋友，自己去解开吧~</p>
<p><img src="https://cdn.rongshen2020.com/202155a1.png"></p>
]]></content>
      <categories>
        <category>movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title>《一秒钟》</title>
    <url>/2020/11/28/%E3%80%8A%E4%B8%80%E7%A7%92%E9%92%9F%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>《一秒钟》——张艺谋</p>
</blockquote>
<span id="more"></span>

<p>由于技术原因，电影先后退出了柏林电影节与金鸡奖首映。这一次，又由于审片原因，删除了一些关键情节，看完，如鲠在喉。这部电影丝毫没有影响老谋子在我心中的份量，因为这不是他的错。</p>
<p>从西方电影节的三大满贯，《活着》虽未在我国公映，不过也能从很多渠道看到，可谓是一个时代的缩影，老谋子似乎很想让大家去感知那个时代。在这之后，从《红高粱》、《大红灯笼高高挂》、《我的父亲母亲》、《秋菊打官司》《有话好好说》、《一个都不能少》等等，带给了我们太多的经典。02年之后的转型商业片，让人诟病。08年。奥运会的开闭幕式是他的巅峰，赞美远远多于争论，当时的震撼，如今仍然热泪盈眶。10年开始的《山楂树之恋》、《金陵十三钗》、《归来》既有尝试又有回归。张热衷于自己成长的那个时代，因为这给他和那一辈的中国人带来了太多的苦泪与欢笑回忆，作为90后的我们是无法理解的。所以，片中出现某些xx是不可避免的，而中国的审片制度，无形中加了很多的限制，并不想去评论审片制度。<br>我喜欢看那种将人物的悲欢直接展现在荧幕上，而不需要我去联想的电影，这和含蓄并不冲突。因为有笑有泪才是一段回忆中最重要的部份。</p>
<p>致敬！</p>
<p><img src="http://cdn.rongshen.top/20201128a1.jpg"></p>
<p>电影主题曲中很喜欢的两句：<br><strong>游子故人晚来风，满月杯酒中。</strong><br><strong>须臾即永恒，回忆定终身。</strong></p>
]]></content>
      <categories>
        <category>movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title>一个获取主机IP地址的命令解释-awk、gensub</title>
    <url>/2020/04/25/%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%BAIP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A-awk%E3%80%81gensub/</url>
    <content><![CDATA[<blockquote>
<p>今天在看师兄写的一个安装脚本文件，虽然之前学了不少bash知识。不是太熟练，打算练练手，可是这个命令折磨了我好久。索性花点时间把它弄清楚。awk这个工具语言的难度，我是体会到了。写正则表达式的都是什么人啊。。。佩服！！！</p>
</blockquote>
<span id="more"></span>
<h1 id="一个获取ip地址的命令详解，涉及awk知识和gensub函数"><a href="#一个获取ip地址的命令详解，涉及awk知识和gensub函数" class="headerlink" title="一个获取ip地址的命令详解，涉及awk知识和gensub函数"></a>一个获取ip地址的命令详解，涉及awk知识和gensub函数</h1><h2 id="1、先上命令"><a href="#1、先上命令" class="headerlink" title="1、先上命令"></a>1、先上命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyIpAddr=$(ip addr | awk <span class="string">&#x27;/^[0-9]+: / &#123;&#125;; /inet.*global/ &#123;print gensub(/(.*)\/(.*)/, &quot;\\1&quot;, &quot;g&quot;, $2)&#125;&#x27;</span>|head -1)</span><br></pre></td></tr></table></figure>
<h3 id="1-1、先看下它得出的结果吧："><a href="#1-1、先看下它得出的结果吧：" class="headerlink" title="1.1、先看下它得出的结果吧："></a>1.1、先看下它得出的结果吧：</h3><p><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%87111.png"></p>
<p><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%87211.png"></p>
<ul>
<li>就是这个命令，折磨了我很久。我们来思考它是怎么获取到你的主机IP地址的？反向推理一波，一边猜测，一边解题。。。</li>
</ul>
<h3 id="1-2、我们先来拆分下这个命令："><a href="#1-2、我们先来拆分下这个命令：" class="headerlink" title="1.2、我们先来拆分下这个命令："></a>1.2、我们先来拆分下这个命令：</h3><ul>
<li>拆分是为了帮助我们更好的化繁为简，其他的命令我就不解释了。主要围绕awk和gensub这两个进行解释。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr | awk <span class="string">&#x27;/^[0-9]+: / &#123;&#125;; /inet.*global/ &#123;print gensub(/(.*)\/(.*)/, &quot;\\1&quot;, &quot;g&quot;, $2)&#125;&#x27;</span>|head -1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/^[0-9]+: / &#123;&#125;; /inet.*global/ &#123;print gensub(/(.*)\/(.*)/, &quot;\\1&quot;, &quot;g&quot;, $2)&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、awk和genden函数的解释"><a href="#2、awk和genden函数的解释" class="headerlink" title="2、awk和genden函数的解释"></a>2、awk和genden函数的解释</h2><h3 id="2-1、awk命令解释，擅长列输出。awk的一般语法格式为："><a href="#2-1、awk命令解释，擅长列输出。awk的一般语法格式为：" class="headerlink" title="2.1、awk命令解释，擅长列输出。awk的一般语法格式为："></a>2.1、awk命令解释，擅长列输出。awk的一般语法格式为：</h3><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%87311.png"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [-参数 变量] &#39;BEGIN&#123;初始化&#125;条件类型1&#123;动作1&#125;条件类型2&#123;动作2&#125;。。。。END&#123;后处理&#125;&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>pattern+action</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件类型1是&#x2F;^[0-9]+: &#x2F;，你要知道正则表达式要写在&#x2F; &#x2F;双斜杠这个里面。那么他是用一个正则表达式来作为一个条件类型。</span><br><span class="line">动作1是&#123;&#125;，里面是空的。</span><br><span class="line">继续...</span><br><span class="line">条件类型2是&#x2F;inet.*global&#x2F;</span><br><span class="line">动作2是&#123;print gensub(&#x2F;(.*)\&#x2F;(.*)&#x2F;, &quot;\\1&quot;, &quot;g&quot;, $2)&#125;，他用这个print加上gensub函数作为动作。</span><br><span class="line">关于这个分号 ; 分号只是起到一个分隔作用，表示分号前和分号后没有联系。</span><br></pre></td></tr></table></figure>
<h3 id="2-2、gensub函数命令解释："><a href="#2-2、gensub函数命令解释：" class="headerlink" title="2.2、gensub函数命令解释："></a>2.2、gensub函数命令解释：</h3><p><strong>gensub(a,b,c[,d])全局替换，匹配正则表达式a， 用b替换，c为指定替换目标是第几次匹配（”g”:表示全局替换），d为指定替换目标是哪个域如$1,$2，若无d指$0，返回值为target替换后内容(未替换还是返回target原内容)与sub、gsub不同的是，target内容替换后不变。</strong></p>
<h3 id="2-3、简单测试下，帮助更好的了解命令干了什么，之后反推下："><a href="#2-3、简单测试下，帮助更好的了解命令干了什么，之后反推下：" class="headerlink" title="2.3、简单测试下，帮助更好的了解命令干了什么，之后反推下："></a>2.3、简单测试下，帮助更好的了解命令干了什么，之后反推下：</h3><ul>
<li>我们先用pattern1来测试下匹配，可以看到得到了两个网卡信息：<br><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%87411.png"></li>
<li>继续看下图，继续做一个pattern2的匹配看下：<br><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%875.png"></li>
<li>可以看到里面有我们最终的ip地址了，那么之后就是action2里面的print和gensub的事了。</li>
<li><code>gensub(/(.*)\/(.*)/, &quot;\\1&quot;, &quot;g&quot;, $2)</code>那么这个到底是干了什么呢？</li>
<li>之前我提到了gensub的函数命令解释，那么可以推测gensub就是把IP地址从下面图中的句子里提炼出来：<br><img src="http://cdn.rongshen2020.com/%E5%9B%BE%E7%89%876.png"></li>
</ul>
<p><strong>我们再来对genden做一个详细的解释：</strong></p>
<ul>
<li><code>(.*)\/(.*)</code> 这个的意思是 括号1/括号2，括号里面有两个一模一样的正则表达式。匹配出了192.168.3.11/24</li>
<li><code>“//1”</code>表示引用第一个括号例匹配的内容，也就是192.168.3.11，用它来替换，也就是192.168.3.11/24变成了192.168.3.11</li>
<li><code>“g”</code>表示全局替换。</li>
<li><code>$2</code>表示第二个域。其中inet是第一个域里面，192.168.3.11在第二个域里面，brd在第三个域里面。。。</li>
</ul>
<h3 id="你可以尝试将"><a href="#你可以尝试将" class="headerlink" title="你可以尝试将"></a>你可以尝试将</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyIpAddr=<span class="string">&quot;inet 192.168.3.11/24 brd 192.168.3.255 scope global&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;MyIpAddr&#125;</span> &gt;&gt; test1.txt</span><br><span class="line">awk <span class="string">&#x27;&#123;print gensub(/(.*)\/(.*)/,&quot;\\1&quot;,&quot;g&quot;,$2)&#125;&#x27;</span> test1.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>多做几次试验。。。</li>
</ul>
<h1 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h1><ul>
<li><code>^[0-9]+   </code>表示匹配输入字符串开始的位置，匹配多个数字。 ^ 为匹配输入字符串的开始位置。[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。</li>
<li><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ambari二次开发-集成自定义组件的一些理解</title>
    <url>/2020/06/22/%E5%85%B3%E4%BA%8Eambari%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91-%E9%9B%86%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>目前网上对于ambari的二次开发详细的说明太少，我也不知道怎么可以讲清楚。因为目前我也不是很理解这其中的原理，作为对于自己的一个锻炼，先写一篇博客作为一个先导。</p>
</blockquote>
<span id="more"></span>

<h1 id="1-集成组件的简单介绍："><a href="#1-集成组件的简单介绍：" class="headerlink" title="1. 集成组件的简单介绍："></a>1. 集成组件的简单介绍：</h1><p>我们看到ambari在大数据的平台搭建上可以做到一键部署，十分的方便。但是在对于其提供的软件和组件之外的一些软件（例如tomcat），其并没有提供支持（一键部署与监控）。我之前的《hdp和ambari版本速查》博客中写过，你可以查询到你所安装的hdp版本所支持的组件。</p>
<ul>
<li>下图是我集成了tomcat后在ambari上的大致显示：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020622a2.png"></p>
<ul>
<li>其代码大致结构，如下：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020622a4.png"></p>
<h1 id="2-快速上手："><a href="#2-快速上手：" class="headerlink" title="2. 快速上手："></a>2. 快速上手：</h1><ul>
<li>在你安装ambari-server的主机上，进入以下的文件夹，你会发现：<br><img src="http://cdn.rongshen2020.com/2020622a1.png"></li>
</ul>
<p>这里有很多栈的版本，在之前安装ambari时，我们是都已经选择过对应的栈的版本。</p>
<ul>
<li>进入对应的栈后，我们会发现这其中的大致结构：<br><img src="http://cdn.rongshen2020.com/2020622a3.png"></li>
</ul>
<p>这是我自己集成的tomcat的大致结构。主要分为四大部分，下面我会详细介绍下。</p>
<h2 id="2-1、configuration文件夹："><a href="#2-1、configuration文件夹：" class="headerlink" title="2.1、configuration文件夹："></a>2.1、configuration文件夹：</h2><ul>
<li>configuration文件夹里主要是xml文件。这里面体现在ambari前端界面就是，你可以自定义自己的配置信息，如下图所示：<br><img src="http://cdn.rongshen2020.com/2020622a7.png"><br><img src="http://cdn.rongshen2020.com/2020622a5.png"></li>
</ul>
<h2 id="2-2、metainfo-xml文件："><a href="#2-2、metainfo-xml文件：" class="headerlink" title="2.2、metainfo.xml文件："></a>2.2、metainfo.xml文件：</h2><ul>
<li>描述了对整个项目的约束配置，是一个 核心 文件。也就是你整个服务的安装需要服从该文件里面的配置。<br><img src="http://cdn.rongshen2020.com/2020622a8.png"></li>
</ul>
<h2 id="2-3、package文件夹："><a href="#2-3、package文件夹：" class="headerlink" title="2.3、package文件夹："></a>2.3、package文件夹：</h2><ul>
<li>该文件夹里面主要是python代码。用来控制组件的安装，启动，暂停等一些生命周期的操作。其原理是python控制shell脚本来操作。<br><img src="http://cdn.rongshen2020.com/2020622a9.png"></li>
</ul>
<h2 id="2-4、quicklinks文件夹："><a href="#2-4、quicklinks文件夹：" class="headerlink" title="2.4、quicklinks文件夹："></a>2.4、quicklinks文件夹：</h2><ul>
<li>这里面是一个json文件，用来控制跳转的。也就是图片中对应的这个功能。<br><img src="http://cdn.rongshen2020.com/2020622a6.png"></li>
</ul>
<h1 id="3-怎么部署服务？"><a href="#3-怎么部署服务？" class="headerlink" title="3. 怎么部署服务？"></a>3. 怎么部署服务？</h1><p>这一步很简单，当你写好代码后，主要是将整个代码的文件夹，放入到对饮的栈文件夹下，之后重启ambari server服务。若报错，请连其他节点的ambari agent服务一起重启。</p>
<ul>
<li>在界面的add service 上就可以快速部署你的服务了：<br><img src="http://cdn.rongshen2020.com/2020622a10.png"></li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://cwiki.apache.org/confluence/display/AMBARI/Ambari">https://cwiki.apache.org/confluence/display/AMBARI/Ambari</a></p>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>HDP,Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>在IDEA中开启热部署与Run Dashboard</title>
    <url>/2020/09/26/%E5%9C%A8IDEA%E4%B8%AD%E5%BC%80%E5%90%AF%E7%83%AD%E9%83%A8%E7%BD%B2%E4%B8%8ERun-Dashboard/</url>
    <content><![CDATA[<blockquote>
<p>在idea中开启热部署和run dashboard可以帮助我们更好的进行开发</p>
</blockquote>
<span id="more"></span>


<h2 id="开启热部署："><a href="#开启热部署：" class="headerlink" title="开启热部署："></a>开启热部署：</h2><ol>
<li><p>导入依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>粘贴插件到聚合父类总工程的pom.xml里面：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">        &lt;addResources&gt;true&lt;/addResources&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在idea中开启热部署：</p>
<p> <img src="http://cdn.rongshen2020.com/2020926a1.png"></p>
</li>
</ol>
<ol start="4">
<li><p>更新值：</p>
<ol>
<li><p>快捷键Ctrl+shift+alt+/</p>
<p><img src="http://cdn.rongshen2020.com/2020926a2.png"></p>
<p>将下面的选项勾上：</p>
<p><img src="http://cdn.rongshen2020.com/2020926a3.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020926a4.png"></p>
</li>
<li><p>重启IDEA~</p>
<ul>
<li>如果电脑性能跟的上的话，很推荐这个。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="开启Run-Dashboard："><a href="#开启Run-Dashboard：" class="headerlink" title="开启Run Dashboard："></a>开启Run Dashboard：</h2><p>在工程的<code>.idea</code>的文件夹里的<code>workspace.xml</code>文件里添加上：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;component name=<span class="string">&quot;RunDashboard&quot;</span>&gt;</span><br><span class="line"> &lt;option name=<span class="string">&quot;ruleStates&quot;</span>&gt;</span><br><span class="line">     &lt;list&gt;</span><br><span class="line">       &lt;RuleState&gt;</span><br><span class="line">           &lt;option name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;ConfigurationTypeDashboardGroupingRule&quot;</span> /&gt;</span><br><span class="line">       &lt;/RuleState&gt;</span><br><span class="line">       &lt;RuleState&gt;</span><br><span class="line">          &lt;option name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;StatusDashboardGroupingRule&quot;</span> /&gt;</span><br><span class="line">       &lt;/RuleState&gt;</span><br><span class="line">     &lt;/list&gt;</span><br><span class="line">  &lt;/option&gt;</span><br><span class="line">  &lt;option name=<span class="string">&quot;contentProportion&quot;</span> value=<span class="string">&quot;0.22874807&quot;</span> /&gt;</span><br><span class="line">  &lt;option name=<span class="string">&quot;configurationTypes&quot;</span>&gt;</span><br><span class="line">     &lt;set&gt;</span><br><span class="line">          &lt;option value=<span class="string">&quot;SpringBootApplicationConfigurationType&quot;</span> /&gt;</span><br><span class="line">     &lt;/set&gt;</span><br><span class="line">  &lt;/option&gt;</span><br><span class="line"> &lt;/component&gt;</span><br></pre></td></tr></table></figure>

<p>即可！</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>IDEA工具</tag>
      </tags>
  </entry>
  <entry>
    <title>学习开发tips集散地</title>
    <url>/2021/01/03/%E5%AD%A6%E4%B9%A0%E3%80%81%E5%BC%80%E5%8F%91%E3%80%81%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>学习的tips</p>
</blockquote>
<span id="more"></span>

<h2 id="工具网站："><a href="#工具网站：" class="headerlink" title="工具网站："></a>工具网站：</h2><p>GIT学习：<a href="https://learngitbranching.js.org/?local=zh_CN&amp;locale=zh_CN">https://learngitbranching.js.org/?local=zh_CN&amp;locale=zh_CN</a></p>
<h2 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h2><p>java学习加面试指南：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>残差网络之快捷键-ResNet,skip connection</title>
    <url>/2020/04/26/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%BF%AB%E6%8D%B7%E9%94%AE-ResNet%E3%80%81skip-connection/</url>
    <content><![CDATA[<blockquote>
<p>最近由于《高级数字图像处理》课程考核的原因，看了一篇CV的论文。我没有读懂全部的论文内容，关于其中一个很小的一点skip connection，我做个记录。只是简单的介绍下这个我看懂的一小点。</p>
</blockquote>
<span id="more"></span>
<h1 id="1、论文简介："><a href="#1、论文简介：" class="headerlink" title="1、论文简介："></a>1、论文简介：</h1><ul>
<li>论文题目：《Deep Residual Learning for Image Recognition》</li>
<li>中文译名：《深度残差学习在图像识别中的应用》</li>
<li>论文链接：<a href="https://arxiv.org/pdf/1512.03385.pdf">https://arxiv.org/pdf/1512.03385.pdf</a></li>
<li>Github代码参考：<a href="https://github.com/tornadomeet/ResNet">https://github.com/tornadomeet/ResNet</a></li>
<li>作者：何恺明、 Xiangyu Zhang, Shaoqing Ren, Jian Sun</li>
</ul>
<h1 id="2、short-cut-skip-connection"><a href="#2、short-cut-skip-connection" class="headerlink" title="2、short cut/skip connection:"></a>2、short cut/skip connection:</h1><ul>
<li>传统的卷积网络在做学习时，往往会出现随着网络层的加深，会出现梯度消失、误差加大的问题。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/204261.png"></p>
<ul>
<li>基于VGG网络启发，该网络是将卷积核的尺寸全部都化为3*3的矩阵卷积核。从而减少过多的参数，使得整个网络的学习效率提高。但是这样会增加网络的层数，会导致出现梯度消失、误差加大的问题。</li>
<li><h2 id="2-1、Residual-Block"><a href="#2-1、Residual-Block" class="headerlink" title="2.1、Residual Block"></a>2.1、Residual Block</h2></li>
</ul>
<p><img src="http://cdn.rongshen2020.com/204262.png"></p>
<ul>
<li>我们先来看下这个residual block，残差网络就是由很多这样的residual block构成的。我就把它叫做一个残差计算块吧（随便你怎么翻译啦）。我们可以看到一个残差块residual block里包括2个layer和1个skip connection。而一个layer里，我们有一个Linear（线性计算），一个ReLU（激活函数（rectified linear Units））。如下图所示：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/204264.png"></p>
<ul>
<li>这个只是一个plain network，也就是没有skip connetion的简单网络。</li>
</ul>
<h2 id="2-2、short-connection"><a href="#2-2、short-connection" class="headerlink" title="2.2、short connection"></a>2.2、short connection</h2><p><strong>那我们加上skip connection就会变成下图这样，这就是完整的残差网络的一个block了</strong></p>
<p><img src="http://cdn.rongshen2020.com/204263.png"></p>
<p><strong>注意看上图的线性计算和激活函数的结果，通过比较我们发现了不同</strong></p>
<ul>
<li>是什么不同呢，就是那个加号，这个不同，可以解决掉之后出现随着网络层数加深出现的问题。</li>
</ul>
<h2 id="2-3、思考，short-connection的重要性"><a href="#2-3、思考，short-connection的重要性" class="headerlink" title="2.3、思考，short connection的重要性"></a>2.3、思考，short connection的重要性</h2><p><img src="http://cdn.rongshen2020.com/204265.png"></p>
<p><strong>解释：我们先假设计算网络有l层吧，那么左边的plain网络根据最后一层的激活函数得出的就是左边的这个公式。同理，右边的残差网络，最后我们在加一个residual block，那么得到的就是右边的这个。那么，单纯深模型的问题就是：模型越深，w，b可能vanishing到0，那么左边的plain网络就得到了a[l+2]=g(0)，做反向传递的时候，继续更新，很难更新参数，很难学到东西了。那么skip connection就保证了a[l+2]不会是0，a[l+2]=g(a[l]),从而能有效的反向传递进行参数更新。</strong></p>
<ul>
<li>这张图也解释了plain network从理论上和实际上，随着网络层数的加深，训练误差，不降反升。</li>
</ul>
<h2 id="2-4、维度问题"><a href="#2-4、维度问题" class="headerlink" title="2.4、维度问题"></a>2.4、维度问题</h2><p><img src="http://cdn.rongshen2020.com/204267.png"></p>
<p><img src="http://cdn.rongshen2020.com/204266.png"></p>
<ul>
<li>我们对每几个层叠的层次采用残差学习。图2中展示出了一个积木块（building block ）。形式上，在本文中，我们考虑了一个积木块被定义为：x和F的维数必须相等。如果情况并非如此(例如，在更改输入/输出通道时)，我们可以通过快捷连接执行线性投影W s ，以匹配维度:我们还注意到，虽然为了简单起见，上述表示法是关于全连通层的，但它们适用于卷积层。函数F(x，{wi})可以表示多个卷积层.元素级加法是在两个特征映射上相应通道上执行的。如只有一层卷积来表示F没有很好的效果，而快捷的加法在两层上面是有很好的效果，所以最终本文选择了一块积木由两层卷积加一层激活组成。即之前介绍过的表示形式。</li>
</ul>
<h1 id="3、思考："><a href="#3、思考：" class="headerlink" title="3、思考："></a>3、思考：</h1><ul>
<li>这是一个找差距的过程。虽然不是做CV，也没有这方面的知识储备。可是互联网是个好东西，他可以帮助我们一点一点的去弄懂。对于整篇文章，我还没全部看完。2020.04.26晚21.30。</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>ResNet</tag>
      </tags>
  </entry>
  <entry>
    <title>解决CDH平台搭建时离线安装依赖包的方法</title>
    <url>/2020/04/14/%E8%A7%A3%E5%86%B3CDH%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%E6%97%B6%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景介绍："><a href="#背景介绍：" class="headerlink" title="背景介绍："></a>背景介绍：</h2><span id="more"></span>
<p>1、CDH开发平台在搭建的过程中，会遇到各种各样的问题，其中的各种依赖就是一个很让人头痛的问题。如果安装脚本文件出现了这种问题，那么就可以把以下的这种方法加入shell中，但是不要用yum来安装，因为yum安装需要网络，有的应用场景是离线的，所以我们采用离线安装，下一个Yum包所需要的离线包以及依赖。<br>2、CDH开发平台如果遇到网卡不能重启，就重启整个机器<br>3、重启整个云主机完后启动CDH前，不要忘了先启动Ntp和Mysql服务，不然你连CDH怎么挂的都不知道<br><em><strong>注：本文也是参考了其他大牛，作为本人在搭建过程中遇到的问题，如何解决的方法介绍</strong></em>**</p>
<h2 id="【yum】解决离线安装依赖包的方法"><a href="#【yum】解决离线安装依赖包的方法" class="headerlink" title="【yum】解决离线安装依赖包的方法**"></a>【yum】解决离线安装依赖包的方法**</h2><p><strong>解决办法：</strong> 下载所有所需的rpm包和它的依赖，拷贝到目标安装机器上，然后搭建一个本地yum仓库，安装完成之后删除本地仓库。<br>反向代理所需：  nginx  keepalived<br>搭建仓库所需：  createrepo<br><strong>一、新建一台CentOS7 mini虚拟机，联网下载所有所需的rpm包和其依赖</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -y install epel-release</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mkdir /root/abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#yum -y install createrepo --downloadonly --downloaddir=/root/abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#yum -y install nginx keepalived --downloadonly --downloaddir=/root/abc</span></span><br></pre></td></tr></table></figure>
<p>注：    <code> yum  -y  install   XXX    --downloadonly    --downloaddir=/XXX</code><br>安装软件包xxx下载到/xxx位置，然后记得指定–downloadonly，只下载，不安装。此方法，会将主软件包和基于你现在的操作系统缺少的依赖关系包一并下载！基于你现在的操作系统，意味着不同版本的操作系统（桌面版、mini版等）下载的软件依赖包个数会不一样！你的操作系统已装的包越多，那么下下来的依赖会越少，所以请选择合适的基操作系统！<br>下载完成后，我们可以看到/root/abc 下有多个rpm包（主包及其依赖），接下来我们就利用这些rpm包搭建一个本地yum仓库。</p>
<p><strong>二、拷贝下载的rpm包到离线目标机器（假设为/root/abc），搭建本地yum仓库(我是使用xftp直接拖过去的)</strong><br><img src="https://img-blog.csdnimg.cn/20200307110624153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZW5fUg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>自己选择一个好的方法，比较推荐scp命令。<br>将目标机器系统自带的仓库文件，转移备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /etc/yum.repos.d/backup</span></span><br><span class="line"><span class="comment"># mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup</span></span><br><span class="line"><span class="comment"># yum clean all</span></span><br></pre></td></tr></table></figure>
<p>安装搭建仓库所需的的软件包，主包为createrepo，请按如下顺序安装：<br><img src="https://img-blog.csdnimg.cn/20200307110920202.png" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/abc</span><br><span class="line"></span><br><span class="line">rpm -qa | grep libxml2 | xargs rpm -e --nodeps</span><br><span class="line"></span><br><span class="line">rpm -qa | grep deltarpm| xargs rpm -e --nodeps</span><br><span class="line"></span><br><span class="line">rpm -ivh  deltarpm-3.6-3.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  python-deltarpm-3.6-3.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  libxml2-2.9.1-6.el7_2.3.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  libxml2-python-2.9.1-6.el7_2.3.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>以上两条命令未成功，由于没有对应的.rpm文件<br><img src="https://img-blog.csdnimg.cn/20200307110940717.png" alt="在这里插入图片描述"><br><code>rpm -ivh  createrepo-0.9.9-28.el7.noarch.rpm</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200307111102447.png" alt="在这里插入图片描述"><br>同理，由于缺少前两条的依赖，所以需先安装前两条命令</p>
<p><strong>解决方法：下载这两个文件后，再重新执行以上3个命令</strong></p>
<p>继续执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir -p /var/ftp/pub/localrepo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp -f /root/abc/* /var/ftp/pub/localrepo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch /etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;[localrepo]&quot;  &gt;&gt;/etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;name=Local Repository&quot; &gt;&gt;/etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;baseurl=file:///var/ftp/pub/localrepo&quot; &gt;&gt;/etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;gpgcheck=0&quot; &gt;&gt;/etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;enabled=1&quot;  &gt;&gt;/etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#createrepo -v /var/ftp/pub/localrepo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#yum repolist</span></span><br></pre></td></tr></table></figure>
<h2 id="三、利用本地yum仓库，安装所需软件包"><a href="#三、利用本地yum仓库，安装所需软件包" class="headerlink" title="三、利用本地yum仓库，安装所需软件包"></a>三、利用本地yum仓库，安装所需软件包</h2><p>因为我们已利用我们所需的软件和其依赖包搭建了本地仓库，安装过程中yum会自己解决依赖包安装的顺序。createrepo 在上面已安装，下面无需再装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install nginx  keepalived</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200307111154267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZW5fUg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="四、安装完成后，删除搭建的本地yum仓库，恢复系统yum仓库文件"><a href="#四、安装完成后，删除搭建的本地yum仓库，恢复系统yum仓库文件" class="headerlink" title="四、安装完成后，删除搭建的本地yum仓库，恢复系统yum仓库文件"></a>四、安装完成后，删除搭建的本地yum仓库，恢复系统yum仓库文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm  -rf /var/ftp/pub/localrepo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rm  -rf /etc/yum.repos.d/localrepo.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mv  /etc/yum.repos.d/backup/*.repo   /etc/yum.repos.d/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rm  -rf /etc/yum.repos.d/backup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yum clean all</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200307111253100.png" alt="在这里插入图片描述"></p>
<p>盖木欧瓦~</p>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>CDH</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ambari界面quickLinks链接无效</title>
    <url>/2020/06/17/%E8%A7%A3%E5%86%B3ambari%E7%95%8C%E9%9D%A2quickLinks%E9%93%BE%E6%8E%A5%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<blockquote>
<p>安装好数据平台之后，发现ambari里面的quicklinks的链接跳转无效。主要是本地主机没有配置映射关系，并不是端口其他的问题。</p>
</blockquote>
<span id="more"></span>

<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><ol>
<li><p>主要原因是本地windows的hosts文件没有修改映射关系。该文件位于：C:\Windows\System32\drivers\etc下。</p>
</li>
<li><p>打开“命令提示符”，右键“以管理员身份运行”，复制以下命令并执行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TAKEOWN /F %windir%\System32\drivers\etc\hosts &amp; <span class="built_in">echo</span> Y| cacls %windir%\system32\drivers\etc\hosts /s:<span class="string">&quot;D:AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)(A;ID;0x1200a9;;;AC)&quot;</span> &amp; notepad %windir%\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure></li>
<li><p>开始修改映射关系：<br><img src="http://cdn.rongshen2020.com/2020617a1.png"></p>
</li>
</ol>
<ol start="4">
<li><p>保存。ping一下测试。<br><img src="http://cdn.rongshen2020.com/2020617a3.jpg"></p>
</li>
<li><p>ok，浏览器访问下就可以了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>HDP,Ambari</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Hadoop平台搭建（入门级）</title>
    <url>/2020/05/06/Apache-Hadoop%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%EF%BC%88%E5%85%A5%E9%97%A8%E7%BA%A7%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章的写完后没有实践，所以如果在实际安装中遇到的问题，需要详细的去查看安装日志文件。</p>
</blockquote>
<span id="more"></span>
<h1 id="Apache-Hadoop的集群搭建-入门级"><a href="#Apache-Hadoop的集群搭建-入门级" class="headerlink" title="  Apache Hadoop的集群搭建(入门级) "></a><center>  Apache Hadoop的集群搭建(入门级) </center></h1><blockquote>
<p>建议3台虚拟机，虚拟机是centos7版本，使用完全分布式运行模式。<br>hadoop下载地址：<a href="https://archive.apache.org/dist/hadoop/common/">https://archive.apache.org/dist/hadoop/common/</a><br>hadoop的伪分布式和本地运行模式：<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a><br>jdk下载：<a href="https://repo.huaweicloud.com/java/jdk/">https://repo.huaweicloud.com/java/jdk/</a></p>
</blockquote>
<h2 id="1-虚拟机准备"><a href="#1-虚拟机准备" class="headerlink" title="1.虚拟机准备"></a>1.虚拟机准备</h2><blockquote>
<p>提示：在你准备虚拟机环境时，有几点你是需要理解的。第一，虚拟机之间需要互相ping通，那么你的网卡和防火墙要配置。集群节点之间互相关闭防火墙，节点组成的集群开启防火墙（防御组）。</p>
</blockquote>
<h3 id="1-1、关闭防火墙："><a href="#1-1、关闭防火墙：" class="headerlink" title="1.1、关闭防火墙："></a>1.1、关闭防火墙：</h3><blockquote>
<p>每一个节点都需要。</p>
</blockquote>
<ul>
<li>第一种方式：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//服务关闭</span><br><span class="line">service iptables stop </span><br><span class="line">//关闭开机自启</span><br><span class="line">chkconfig iptables off </span><br><span class="line">//检查防火墙是否关闭</span><br><span class="line">service iptables status</span><br><span class="line">chkconfig --list iptables</span><br></pre></td></tr></table></figure></li>
<li>第二种方式：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
<h3 id="1-2、创建一般用户（可选）："><a href="#1-2、创建一般用户（可选）：" class="headerlink" title="1.2、创建一般用户（可选）："></a>1.2、创建一般用户（可选）：</h3><blockquote>
<p>使用一般用户来搭建集群，碰到问题会很多，可以帮助你快速成长。这里的创建software和module文件夹是必要的。</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建一个一般用户rong</span><br><span class="line">useradd rong</span><br><span class="line">//设置密码</span><br><span class="line">password rong</span><br><span class="line">//在/opt目录下创建software和module文件夹，这两个文件夹是用来放后面的软件和其解压包的。这一步是必要的！</span><br><span class="line">mkdir /opt/software /opt/module</span><br><span class="line">//更改文件夹权限</span><br><span class="line">chown rong:rong /opt/software /opt/module</span><br><span class="line">//将用户添加到sudoers管理中，使该用户具有root权限</span><br><span class="line">vi /etc/sudoers</span><br><span class="line">	rong ALL=(ALL)  NOPASSWD:ALL</span><br><span class="line">	:wq! 强制保存下。</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.rongshen2020.com/2020551.png"></p>
<h3 id="1-3、修改Hosts："><a href="#1-3、修改Hosts：" class="headerlink" title="1.3、修改Hosts："></a>1.3、修改Hosts：</h3><blockquote>
<p>每一个节点都需要，集群的节点之间标注位置信息，互相通信。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">	//文件后追加</span><br><span class="line">	节点1的ip 节点1名字</span><br><span class="line">	节点2的ip 节点2名字</span><br><span class="line">	节点3的ip 节点3名字</span><br></pre></td></tr></table></figure>

<h3 id="1-4、修改静态IP："><a href="#1-4、修改静态IP：" class="headerlink" title="1.4、修改静态IP："></a>1.4、修改静态IP：</h3><blockquote>
<p>静态IP的作用就是之前的配置在当IP自动分配时，在每一次重启时，会影响之前的配置信息。每一个节点都需要，要和之前的Hosts里面的信息对上。这里面的网卡信息要注意！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">	DEVICE=eth0</span><br><span class="line">	HWADDR=00:0C:29:F5:1D:6A</span><br><span class="line">	TYPE=Ethernet</span><br><span class="line">	UUID=8f49ebc2-5b1b-4135-863b-6acb0c84453f</span><br><span class="line">	ONBOOT=yes</span><br><span class="line">	BOOTPROTO=static <span class="comment">#设置为静态</span></span><br><span class="line">	IPADDR=192.168.xxx.xxx <span class="comment">#修改ip和之前设置的节点ip对上</span></span><br><span class="line">	PREFIX=24</span><br><span class="line">	NETMASK=255.255.255.0 <span class="comment">#掩码</span></span><br><span class="line">	GATEWAY=192.168.xxx.x <span class="comment">#网关</span></span><br><span class="line">	DNS1=192.168.xxx.x <span class="comment">#配置网关连接外网</span></span><br><span class="line">	NAME=eth0</span><br><span class="line">//使配置文件生效</span><br><span class="line"><span class="built_in">source</span> /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">//重启</span><br><span class="line">service network restart  </span><br></pre></td></tr></table></figure>
<h3 id="1-5、修改主机名："><a href="#1-5、修改主机名：" class="headerlink" title="1.5、修改主机名："></a>1.5、修改主机名：</h3><blockquote>
<p>每一个节点都需要，和之前的Hosts中的节点信息对上。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br><span class="line">	//修改HOSTNAME字段</span><br><span class="line">	HOSTNAME=节点名和之前对上</span><br></pre></td></tr></table></figure>

<h2 id="2、安装JDK"><a href="#2、安装JDK" class="headerlink" title="2、安装JDK"></a>2、安装JDK</h2><blockquote>
<p>当然是每个节点都需要配置的，因为hadoop的执行需要java的编译。</p>
</blockquote>
<h3 id="2-1、卸载现有JDK-OpenJDK："><a href="#2-1、卸载现有JDK-OpenJDK：" class="headerlink" title="2.1、卸载现有JDK/OpenJDK："></a>2.1、卸载现有JDK/OpenJDK：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查询自带的jdk版本，没有jdk也没关系</span><br><span class="line">java -version</span><br><span class="line">//查询自带的jdk版本号</span><br><span class="line">rpm -qa | grep jdk</span><br><span class="line">//卸载open jdk</span><br><span class="line">yum -y remove $(rpm -qa | grep jdk)</span><br><span class="line">//或者使用sudo来卸载</span><br><span class="line">sudo rpm -e jdk软件包</span><br><span class="line">//再次查询jdk的版本号</span><br><span class="line">java -version</span><br><span class="line">//查询JDK安装路径</span><br><span class="line"><span class="built_in">which</span> java</span><br></pre></td></tr></table></figure>
<h3 id="2-2、安装JDK："><a href="#2-2、安装JDK：" class="headerlink" title="2.2、安装JDK："></a>2.2、安装JDK：</h3><blockquote>
<p>将jdk的安装包放入到指定文件夹下，可以使用Xftp软件。之前要创建software和moudle文件夹，你可以把安装包和解压包放到这两个文件夹下。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//将压缩包解压到/opt/moudle目录下xzvf也有其特殊的意义，欢迎百度</span><br><span class="line">tar xzvf jdk-8u144-linux-x64.tar.gz -C /opt/moudle</span><br></pre></td></tr></table></figure>
<h3 id="2-3、配置JDK环境："><a href="#2-3、配置JDK环境：" class="headerlink" title="2.3、配置JDK环境："></a>2.3、配置JDK环境：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//配置java的环境变量，将配置信息添加到profile文件中</span><br><span class="line">vi /etc/profile</span><br><span class="line">	//在文件末尾添加jdk的路径</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">	<span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">	<span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">//让配置信息生效</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">//再次查询java版本号，查看配置是否成功</span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="3、安装Hadoop"><a href="#3、安装Hadoop" class="headerlink" title="3、安装Hadoop"></a>3、安装Hadoop</h2><blockquote>
<p>和jdk安装同理，要将事先下载好的Hadoop压缩包放入到/opt/software文件夹下，之后再解压到moudle文件夹下。</p>
</blockquote>
<h3 id="3-1、安装Hadoop："><a href="#3-1、安装Hadoop：" class="headerlink" title="3.1、安装Hadoop："></a>3.1、安装Hadoop：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//解压hadoop压缩文件到moudle文件夹下</span><br><span class="line">tar -zxvf hadoop-2.9.2.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure>
<h3 id="3-2、配置Hadoop环境："><a href="#3-2、配置Hadoop环境：" class="headerlink" title="3.2、配置Hadoop环境："></a>3.2、配置Hadoop环境：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//在hadoop的解压文件夹下可以获取Hadoop安装路径</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">//配置hadoop的环境变量，将配置信息添加到profile文件中</span><br><span class="line">vi /etc/profile</span><br><span class="line">	//在profile文件末尾添加hadoop路径,bin是可执行文件，sbin是可执行脚本</span><br><span class="line">	<span class="built_in">export</span> HADOOP_HOME=/opt/module/hadoop-2.9.2</span><br><span class="line">	<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin</span><br><span class="line">	<span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/sbin</span><br><span class="line">//让配置信息生效</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">//查看是否安装成功</span><br><span class="line">hadoop version</span><br></pre></td></tr></table></figure>
<p><strong>总结：到此为止，三个节点上的java和hadoop算是全部安装完成了！</strong></p>
<h2 id="4、配置集群并测试单点启动"><a href="#4、配置集群并测试单点启动" class="headerlink" title="4、配置集群并测试单点启动"></a>4、配置集群并测试单点启动</h2><blockquote>
<p>scp命令可在不同的主机之间实现文件的快速传输。有3个节点，那么我们就选择一个作为主节点（master），剩下的作为从节点（slave）。所以每个节点上都要配置好第1、2、3节的信息，jdk和Hadoop的安装包全部解压配置安装好。可以尝试使用scp进行快速传输，rsync命令也用于拷贝，但是性质却不一样，建议百度！当然，你可以写个脚本快速执行以上步骤。拷贝文件时，还有一点需要注意，那就是/etc/profile文件别忘记拷贝和之后需要source一下该文件（使之生效）。</p>
</blockquote>
<h3 id="4-1、三个节点的规划："><a href="#4-1、三个节点的规划：" class="headerlink" title="4.1、三个节点的规划："></a>4.1、三个节点的规划：</h3><h4 id="1、穷人版："><a href="#1、穷人版：" class="headerlink" title="1、穷人版："></a>1、穷人版：</h4><p><img src="http://cdn.rongshen2020.com/2020552.png"></p>
<h4 id="2、富人版："><a href="#2、富人版：" class="headerlink" title="2、富人版："></a>2、富人版：</h4><blockquote>
<p>有一个疑问：每一个节点是不是在安装hadoop时就会有了DN和NM？</p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/2020554.png"></p>
<h3 id="4-2、配置集群："><a href="#4-2、配置集群：" class="headerlink" title="4.2、配置集群："></a>4.2、配置集群：</h3><blockquote>
<p>我们使用穷人版的集群架构，所以3个节点都有DN和NM，节点1有NN，节点2有RM，节点3有2NN。</p>
<p>另外，在/opt/module/hadoop-2.9.2/etc/hadoop目录下有7个文件需要配置，分别是core-site.xml,hdfs-site.xml,mapred-site.xml,yarn-site.xml,hadoop-env.sh,mapred-env.sh,yarn-env.sh。其中hadoop-env.sh,mapred-env.sh,yarn-env.sh这三个主要是配置下JAVA_HOME。注意，这些文件你在一个节点上做了修改之后，记得分发给其他的节点。</p>
</blockquote>
<p><strong>1.核心配置文件core-site.xml：</strong></p>
<blockquote>
<p>在/opt/module/hadoop-2.9.2/etc/hadoop目录下。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi core-site.xml</span><br><span class="line">	//在该文件中编写如下配置</span><br><span class="line">	&lt;!-- 指定HDFS中NameNode的地址 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">			&lt;value&gt;/opt/module/hadoop-2.9.2/data/tmp&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2.HDFS配置文件hadoop-env.sh和hdfs-site.xml：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//配置hadoop-env.sh</span><br><span class="line">vi hadoop-env.sh</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">//配置hdfs-site.xml</span><br><span class="line">vi hdfs-site.xml</span><br><span class="line">	//在该文件中编写如下配置</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">			&lt;value&gt;3&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定Hadoop辅助名称节点2NN主机配置 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">	        &lt;value&gt;slave2:50090&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3.YARN配置文件yarn-env.sh和yarn-site.xml：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//配置yarn-env.sh</span><br><span class="line">vi yarn-env.sh</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">//配置yarn-site.xml</span><br><span class="line">vi yarn-site.xml</span><br><span class="line">	//在该文件中增加如下配置</span><br><span class="line">	&lt;!-- Reducer获取数据的方式 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">			&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">			&lt;value&gt;slave1&lt;/value&gt; </span><br><span class="line">	&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4.MapReduce配置文件mapred-env.sh和mapred-site.xml：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//配置mapred-env.sh</span><br><span class="line">vi mapred-env.sh</span><br><span class="line">	<span class="built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">//配置mapred-site.xml</span><br><span class="line">vi mapred-site.xml</span><br><span class="line">	//在该文件中增加如下配置</span><br><span class="line">	&lt;!-- 指定MR运行在Yarn上 --&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">			&lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">			&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>以上的配置信息，每一个节点上都要有。所以在一台节点上配置完成之后，分发到其他节点就可以了。</p>
<h3 id="4-3、集群单点启动："><a href="#4-3、集群单点启动：" class="headerlink" title="4.3、集群单点启动："></a>4.3、集群单点启动：</h3><blockquote>
<p>每一个节点都启动了datanode，会有DM服务的。</p>
</blockquote>
<ul>
<li><p>在master节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format <span class="comment">#注意一定要在配置了namenode的机器上格式化</span></span><br><span class="line">hadoop-daemon.sh start namenode <span class="comment">#启动namenode</span></span><br><span class="line">hadoop-daemon.sh start datanode <span class="comment">#启动datanode</span></span><br></pre></td></tr></table></figure></li>
<li><p>在slave1节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start datanode <span class="comment">#启动datanode</span></span><br></pre></td></tr></table></figure></li>
<li><p>在slave2节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop-daemon.sh start datanode <span class="comment">#启动datanode</span></span><br><span class="line">hadoop-daemon.sh start secondarynamenode <span class="comment">#启动2NN</span></span><br></pre></td></tr></table></figure></li>
<li><p>在3个节点上依次执行<code>jps</code></p>
</li>
</ul>
<h2 id="5、配置SSH无密码登录"><a href="#5、配置SSH无密码登录" class="headerlink" title="5、配置SSH无密码登录"></a>5、配置SSH无密码登录</h2><blockquote>
<p>主要作用是为了群起集群，配置好了ssh协议就可以使用hadoop自带的群起脚本。群起脚本之前需要配置好位于/opt/moudle/hadoop-2.9.2/etc/hadoop文件夹下slave文件，这里面记录了hadoop集群的所有主机，之后要将这个文件分发给每一台主机。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment">#生成私钥和公钥，一个私钥对应一个公钥。</span></span><br><span class="line">ssh-copy-id 节点名 <span class="comment">#发送公钥到指定的节点</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1、需要发送的秘钥图："><a href="#5-1、需要发送的秘钥图：" class="headerlink" title="5.1、需要发送的秘钥图："></a>5.1、需要发送的秘钥图：</h3><blockquote>
<p>节点之间使用公钥和私钥进行比对来判断，所以3个节点之间需要进行9次公钥交换，这是最安全的一种SSH无密码配置。密钥实现无密码登录的原理就是，生成的公钥和私钥时一一对应的，将公钥发个远端，本地使用私钥来进行匹配，匹配成功即为登录成功。</p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/20561.png"></p>
<h3 id="5-2、SSH无密码配置解决方法1："><a href="#5-2、SSH无密码配置解决方法1：" class="headerlink" title="5.2、SSH无密码配置解决方法1："></a>5.2、SSH无密码配置解决方法1：</h3><ul>
<li>这种方法是最安全的，在每一个节点上生成公钥和私钥<code>ssh-keygen -t rsa</code>，之后再将每个公钥发送给每一个节点（包括自己）<code>ssh-copy-id 节点名</code>。</li>
</ul>
<h3 id="5-3、SSH无密码配置解决方法2："><a href="#5-3、SSH无密码配置解决方法2：" class="headerlink" title="5.3、SSH无密码配置解决方法2："></a>5.3、SSH无密码配置解决方法2：</h3><ul>
<li>这种方法不推荐，主要是将一个节点上生成的公钥和私钥通过rsync命令分发给每个节点，那么每个节点上拥有的就是相同的公钥和私钥，所以可以实现节点之间的无密码登录。这有一个最严重的问题，就是节点之间传输公钥和私钥时会出现泄漏问题，不安全。</li>
</ul>
<h2 id="6、群起集群"><a href="#6、群起集群" class="headerlink" title="6、群起集群"></a>6、群起集群</h2><blockquote>
<p>群起脚本之前需要配置好位于/opt/moudle/hadoop-2.9.2/etc/hadoop文件夹下slave文件，这里面记录了hadoop集群的所有主机，之后要将这个文件分发给每一台主机。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /opt/moudle/hadoop-2.9.2/etc/hadoop/slave</span><br><span class="line">	删除localhost</span><br><span class="line">	master</span><br><span class="line">	slave1</span><br><span class="line">	slave2</span><br></pre></td></tr></table></figure>
<h3 id="6-1、群起HDFS脚本："><a href="#6-1、群起HDFS脚本：" class="headerlink" title="6.1、群起HDFS脚本："></a>6.1、群起HDFS脚本：</h3><blockquote>
<p>因为之前我们使用穷人版的集群架构，每一个节点上都应有DN和NM服务，所以需要在一个节点上启动一次就可以了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<h3 id="6-2、YARN启动："><a href="#6-2、YARN启动：" class="headerlink" title="6.2、YARN启动："></a>6.2、YARN启动：</h3><blockquote>
<p>因为YARN我们主要配置在了slave1节点上，因为我们将ResourceManager配置在了slave1上，所以这个只需要在slave1节点上启动。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>

<h3 id="6-3、测试："><a href="#6-3、测试：" class="headerlink" title="6.3、测试："></a>6.3、测试：</h3><ul>
<li><p>群起脚本成功之后，就可以使用<code>jps</code>命令查看是不是每个节点都应有下面图中的配置。</p>
</li>
<li><p>启动HDFS和YARN之后并运行MapReduce程序查看集群是否启动成功。</p>
</li>
</ul>
<h2 id="7、历史服务器和日志聚集"><a href="#7、历史服务器和日志聚集" class="headerlink" title="7、历史服务器和日志聚集"></a>7、历史服务器和日志聚集</h2><blockquote>
<p>配置Yarn历史服务器和日志聚集功能。配置历史服务器主要是查看程序的历史运行情况。日志聚集主要是查看程序运行详情。那么我们在一台节点上配置好这些之后，一定要记得分发给其他节点，让其他节点同步。配置历史服务器之前要将hdfs和yarn关闭。</p>
</blockquote>
<h3 id="7-1、停止集群节点服务："><a href="#7-1、停止集群节点服务：" class="headerlink" title="7.1、停止集群节点服务："></a>7.1、停止集群节点服务：</h3><ol>
<li>各个服务组件逐一启动/停止<br> （1）分别启动/停止HDFS组件<pre><code> `hadoop-daemon.sh  start / stop  namenode / datanode / secondarynamenode`
</code></pre>
 （2）启动/停止YARN<pre><code> `yarn-daemon.sh  start / stop  resourcemanager / nodemanager`
</code></pre>
</li>
<li>各个模块分开启动/停止（配置ssh是前提）常用<br> （1）整体启动/停止HDFS<pre><code> `start-dfs.sh   /  stop-dfs.sh`
</code></pre>
 （2）整体启动/停止YARN<pre><code> `start-yarn.sh  /  stop-yarn.sh`
</code></pre>
</li>
</ol>
<h3 id="7-2、配置历史服务器："><a href="#7-2、配置历史服务器：" class="headerlink" title="7.2、配置历史服务器："></a>7.2、配置历史服务器：</h3><ol>
<li>配置mapred-site.xml<blockquote>
<p>该文件位于这个/opt/moudle/hadoop-2.9.2/etc/hadoop文件夹下</p>
</blockquote>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi mapred-site.xml</span><br><span class="line">    //在该文件里面增加如下配置</span><br><span class="line">    &lt;!-- 历史服务器端地址 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">    	&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">    	&lt;value&gt;slave2:10020&lt;/value&gt; <span class="comment">#选择节点2作为历史服务器</span></span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!-- 历史服务器web端地址 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;slave2:19888&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-3、配置日志聚集："><a href="#7-3、配置日志聚集：" class="headerlink" title="7.3、配置日志聚集："></a>7.3、配置日志聚集：</h3><blockquote>
<p>日志聚集概念：应用运行完成以后，将程序运行日志信息上传到HDFS系统上。日志聚集功能好处：可以方便的查看到程序运行详情，方便开发调试。<br>注意：开启日志聚集功能，需要重新启动NodeManager 、ResourceManager和HistoryManager。</p>
</blockquote>
<ul>
<li>配置yarn-site.xml<blockquote>
<p>同理，这个文件位于/opt/moudle/hadoop-2.9.2/etc/hadoop文件夹下</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi yarn-site.xml</span><br><span class="line">    //在该文件里面增加如下配置。</span><br><span class="line">    &lt;!-- 日志聚集功能使能 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;<span class="literal">true</span>&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 日志保留时间设置7天 --&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;604800&lt;/value&gt; <span class="comment">#7天的秒数</span></span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结：配置完历史服务器和日志聚集，一定要记得同步到其他节点。</li>
</ul>
<h3 id="7-4、测试配置："><a href="#7-4、测试配置：" class="headerlink" title="7.4、测试配置："></a>7.4、测试配置：</h3><ol>
<li>关闭NodeManager 、ResourceManager和HistoryManager<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sbin&#x2F;yarn-daemon.sh stop resourcemanager</span><br><span class="line">sbin&#x2F;yarn-daemon.sh stop nodemanager</span><br><span class="line">sbin&#x2F;mr-jobhistory-daemon.sh stop historyserver</span><br></pre></td></tr></table></figure></li>
<li>启动NodeManager 、ResourceManager和HistoryManager<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbin/yarn-daemon.sh start resourcemanager</span><br><span class="line">sbin/yarn-daemon.sh start nodemanager</span><br><span class="line">sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>说明：如果你配置好ssh了，那么上面的两步你可以尝试使用以下的步骤，因为我们要保证在配置历史服务器之前将hdfs和yarn关闭的，配置好之后，我们要将他们呢个重开。在master节点上开启dfs的脚本<code>start-dfs.sh</code>，在slave1上开启yarn的脚本<code>start-yarn.sh</code>，在slave2上开启历史服务<code>mr-jobhistory-daemon.sh start historyserver</code>。因为我们之前将slave2节点作为历史服务器节点。</li>
</ul>
<ol start="3">
<li><p>删除HDFS上已经存在的输出文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hdfs dfs -rm -R &#x2F;user&#x2F;root&#x2F;output</span><br></pre></td></tr></table></figure></li>
<li><p>执行WordCount程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar wordcount /user/root/input /user/root/output</span><br></pre></td></tr></table></figure></li>
<li><p>查看日志</p>
</li>
</ol>
<ul>
<li>我们是将slave2作为历史服务器的。<code>客户端http://slave2:19888/jobhistory</code></li>
</ul>
<h2 id="8、集群时间同步"><a href="#8、集群时间同步" class="headerlink" title="8、集群时间同步"></a>8、集群时间同步</h2><blockquote>
<p>集群时间同步的作用就是让集群的节点之间的时间取得一直。选择一个节点作为时间同步服务器。hbase对时间的同步要求是很高的。</p>
</blockquote>
<h3 id="8-1、时间服务器配置（必须root用户）"><a href="#8-1、时间服务器配置（必须root用户）" class="headerlink" title="8.1、时间服务器配置（必须root用户）"></a>8.1、时间服务器配置（必须root用户）</h3><blockquote>
<p>那我们选择将master作为一个ntp服务器。</p>
</blockquote>
<ol>
<li>检查ntp是否安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep ntp</span><br><span class="line">    ntp-4.2.6p5-10.el6.centos.x86_64</span><br><span class="line">    fontpackages-filesystem-1.41-1.1.el6.noarch</span><br><span class="line">    ntpdate-4.2.6p5-10.el6.centos.x86_64</span><br></pre></td></tr></table></figure></li>
<li>检查ntpd状态，并关闭<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ntpd status <span class="comment">#正在运行的状态必须关闭</span></span><br><span class="line">service ntpd stop <span class="comment">#将三台服务全部停掉</span></span><br><span class="line">chkconfing ntpd off</span><br><span class="line">chkconfing --list ntpd <span class="comment">#查看是否关闭</span></span><br></pre></td></tr></table></figure></li>
<li>修改ntp配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>修改内容如下<br>a）修改1（授权192.168.1.0-192.168.1.255网段上的所有机器可以从这台机器上查询和同步时间）  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line">为</span><br><span class="line">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span><br></pre></td></tr></table></figure>
b）修改2（集群在局域网中，不使用其他互联网上的时间）  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将下面4行注释掉</span><br><span class="line">server 0.centos.pool.ntp.org iburst</span><br><span class="line">server 1.centos.pool.ntp.org iburst</span><br><span class="line">server 2.centos.pool.ntp.org iburst</span><br><span class="line">server 3.centos.pool.ntp.org iburst</span><br><span class="line">为</span><br><span class="line">#server 0.centos.pool.ntp.org iburst</span><br><span class="line">#server 1.centos.pool.ntp.org iburst</span><br><span class="line">#server 2.centos.pool.ntp.org iburst</span><br><span class="line">#server 3.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure>
c）添加3（当该master节点丢失网络连接，依然可以采用本地时间作为时间服务器为集群中的其他节点提供时间同步）  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server 127.127.1.0</span><br><span class="line">fudge 127.127.1.0 stratum 10</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p>修改/etc/sysconfig/ntpd文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;ntpd</span><br><span class="line">    &#x2F;&#x2F;增加内容如下（让硬件时间与系统时间一起同步）</span><br><span class="line">    SYNC_HWCLOCK&#x3D;yes</span><br></pre></td></tr></table></figure></li>
<li><p>重新启动ntpd服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service ntpd status</span><br><span class="line">		ntpd 已停</span><br><span class="line">service ntpd start</span><br><span class="line">		正在启动 ntpd：                       [确定]</span><br></pre></td></tr></table></figure></li>
<li><p>设置ntpd服务开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure>
<h3 id="8-2、其他机器配置（必须root用户）"><a href="#8-2、其他机器配置（必须root用户）" class="headerlink" title="8.2、其他机器配置（必须root用户）"></a>8.2、其他机器配置（必须root用户）</h3><blockquote>
<p>在另外的slave1和slave2节点上配置。</p>
</blockquote>
</li>
<li><p>在其他机器配置1分钟与时间服务器同步一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">    编写定时任务如下：</span><br><span class="line">    *&#x2F;1 * * * * &#x2F;usr&#x2F;sbin&#x2F;ntpdate master</span><br></pre></td></tr></table></figure></li>
<li><p>修改任意机器时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date -s &quot;2020-9-11 11:11:11&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>一分钟后查看机器是否与时间服务器同步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<h2 id="总结。。。"><a href="#总结。。。" class="headerlink" title="总结。。。"></a>总结。。。</h2></li>
</ol>
]]></content>
      <categories>
        <category>大数据平台</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础知识梳理</title>
    <url>/2020/12/30/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8C">https://github.com/Snailclimb/JavaGuide，</a><br>Guide哥</p>
</blockquote>
<h1 id="java泛型、类型擦除、常用的通配符"><a href="#java泛型、类型擦除、常用的通配符" class="headerlink" title="java泛型、类型擦除、常用的通配符"></a>java泛型、类型擦除、常用的通配符</h1><p>来源：<a href="https://segmentfault.com/a/1190000019306920">https://segmentfault.com/a/1190000019306920</a></p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定泛型为String</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 指定泛型为Integer</span></span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">System.out.println(list1.getClass() == list2.getClass()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面判断的结果就是true。代表两个传入了不同类型的List最终都编译成ArrayList，成为了同一种类型。原来的泛型参数String和Integer被擦除掉了。这就是类型擦除的例子。</p>
<h1 id="和equals方法的区别"><a href="#和equals方法的区别" class="headerlink" title="==和equals方法的区别"></a>==和equals方法的区别</h1><ol>
<li><strong><code>==</code></strong> : 它的作用是判断<code>两个对象的地址</code>或<code>基本数据类型的值</code>是不是相等。即判断两个对象是不是同一个对象。</li>
</ol>
<ul>
<li>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</li>
</ul>
<ol start="2">
<li><p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。</p>
<ul>
<li><code>equals()</code> 方法存在两种使用情况：<ul>
<li>情况 1：类没有覆盖 <code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li>情况 2：类覆盖了 <code>equals()</code>方法。一般，我们都覆盖 <code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
</li>
</ul>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</li>
<li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li>
</ul>
</li>
</ol>
<h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode()与 equals()"></a>hashCode()与 equals()</h2><p><strong>1)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<ol>
<li><p>hashCode()介绍:</p>
<p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。散列表（哈希表）存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码（哈希码）！（可以快速找到所需要的对象）</p>
</li>
</ol>
<p><strong>2)为什么要有 hashCode？</strong></p>
<ol>
<li><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code> 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自 Java 启蒙书《Head First Java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
</li>
</ol>
<p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></li>
<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p>
<p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p>
<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>Integer包装类型会将[-128,127]之间的数据直接放到缓存中，所以比较会是true。如果超出这个范围则会新建一个对象。</p>
<p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。</strong></p>
<h1 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h1><p><strong>重载：</strong></p>
<p>​    发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写：</strong></p>
<p>​    重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<p>Constructor 构造器方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<p><strong>注意：</strong></p>
<p>​        Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<p>一个类如果没有声明构造方法，那么也会有默认的不带参数的构造方法。如果你写了有参的构造方法，尽量也写上无参的构造方法（避免踩坑，是个好习惯）。</p>
<h1 id="深拷贝VS浅拷贝"><a href="#深拷贝VS浅拷贝" class="headerlink" title="深拷贝VS浅拷贝"></a>深拷贝VS浅拷贝</h1><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<h1 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h1><ol>
<li>**从语法形式上看:**成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>**从变量在内存中的存储方式来看:**如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>**从变量在内存中的生存时间上看:**成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>**成员变量如果没有被赋初值:**则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h1 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h1><p>继承、封装、多态（子类可以使用父类的方法，也可以重写父类的方法）</p>
<h1 id="静态方法内调用一个非静态成员为什么是非法的"><a href="#静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="静态方法内调用一个非静态成员为什么是非法的?"></a>静态方法内调用一个非静态成员为什么是非法的?</h1><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h1 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h1><ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<p>首先，两者本质上的区别是：静态方法是在类中使用staitc修饰的方法，在类定义的时候已经被装载和分配。而非静态方法是不加static关键字的方法，在类定义时没有占用内存，只有在类被实例化成对象时，对象调用该方法才被分配内存。其次，静态方法中只能调用静态成员或者方法，不能调用非静态方法或者非静态成员，而非静态方法既可以调用静态成员或者方法又可以调用其他的非静态成员或者方法。</p>
<p>例子1：静态方法的Main方法访问类中的非静态成员方法。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//非静态方法</span></span><br><span class="line">    	<span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=sum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//静态方法调用非静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：以上程序在编译时，会提示静态方法不能引用非静态方法的错误信息。</p>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>静态方法只能访问静态方法和静态成员。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//加入static关键字，变成静态方法</span></span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result=sum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//静态方法调用静态方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非静态方法要被实例化才能被静态方法调用。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Test test=<span class="keyword">new</span> Test();<span class="comment">//实例化类</span></span><br><span class="line">		<span class="keyword">int</span> result=test.sum(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//调用非静态方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="String、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h1><ol>
<li><code>string</code>类中使用final关键字修饰字符。而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</li>
<li><strong>在线程安全性方面：</strong><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li><strong>性能：</strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ol>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="java序列化"><a href="#java序列化" class="headerlink" title="java序列化"></a>java序列化</h1><p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<p><strong>对于不想进行序列化的变量，使用 transient 关键字修饰。</strong></p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h1 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h1><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>



<h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p>
<h2 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h2><ul>
<li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li>
</ul>
<h2 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h2><ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li>
</ul>
<h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><p><strong>反射是框架设计的灵魂。</strong></p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：</p>
<ol>
<li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li>
<li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li>
<li>动态配置实例的属性；</li>
<li>……</li>
</ol>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="http://cdn.rongshen2020.com/20201230a1.png"></p>
<p>在 Java中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(checked exception必须处理) 和 不受检查异常(un-checked exception可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>受检查异常</strong></p>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>不受检查异常</strong></p>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointExecrption</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h2 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h2><ul>
<li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程、进程、程序，以及他们之间的关系？"><a href="#线程、进程、程序，以及他们之间的关系？" class="headerlink" title="线程、进程、程序，以及他们之间的关系？"></a>线程、进程、程序，以及他们之间的关系？</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="线程的基本状态"><a href="#线程的基本状态" class="headerlink" title="线程的基本状态"></a>线程的基本状态</h2><p><img src="http://cdn.rongshen2020.com/20201230a2.png"></p>
<p> 还有一个<strong>READY（可运行，也是就绪状态）状态</strong>。操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>线程的变迁图：</strong></p>
<p><img src="http://cdn.rongshen2020.com/20201230a3.png"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h1 id="文件与I-O流"><a href="#文件与I-O流" class="headerlink" title="文件与I/O流"></a>文件与I/O流</h1><h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p> Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。按字节和字符的原则，各两个。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><strong>按操作方式分：</strong></p>
<p><img src="http://cdn.rongshen2020.com/20201230a4.png"></p>
<p><strong>按操作对象分：</strong></p>
<p><img src="http://cdn.rongshen2020.com/20201230a5.png"></p>
<h1 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别"></a>BIO,NIO,AIO 有什么区别</h1><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<p>举例就像：</p>
<ul>
<li>去理发店，老实的在的店里面等的就是BIO。先去逛商场，过一段时间再回来看看有没有到自己的就是NIO（需要重复的回来看看到没到自己）。去逛商场，等轮到自己了，理发店会主动发消息（或者有专门的人）通知你，这就是AIO。</li>
</ul>
]]></content>
      <categories>
        <category>java理论</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2020/12/19/redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>java开发面试整理。来源：<a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p>
<span id="more"></span>

<blockquote>
<p>整理自：<a href="https://github.com/Snailclimb/JavaGuide%EF%BC%8CGuide%E5%93%A5">https://github.com/Snailclimb/JavaGuide，Guide哥</a></p>
</blockquote>
<h2 id="简介redis"><a href="#简介redis" class="headerlink" title="简介redis"></a>简介redis</h2><p>“在内存中的数据库”，redis可以做缓存、分布式锁、消息队列。redis支持事务、持久化、Lua脚本、多集群等。</p>
<h2 id="redis和memcached的区别？"><a href="#redis和memcached的区别？" class="headerlink" title="redis和memcached的区别？"></a>redis和memcached的区别？</h2><ol>
<li>redis支持的数据类型更加丰富，除了k-v键值对，还有list、set、zset、hash等数据结构的存储。memcached目前只支持简单的k-v键值对。</li>
<li>redis支持数据的持久化，memcached目前不支持。</li>
<li>redis有<strong>灾难恢复机制</strong>，因为其可以持久化数据。</li>
<li>redis用完内存之后，可以将暂时不用的数据放到磁盘上，而memcached在服务器内存使用完之后，就会直接报异常。</li>
<li>memcached没有原生的集群模式，而是依靠客户端来实现集群中的分片写入。redis支持cluster模式集群。</li>
<li>Memcached 是多线程的非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）？？？</li>
<li>redis支持发布-订阅模型、Lua脚本、事务等。而memcached不支持，并且redis支持更多的编程语言。</li>
<li>对于过期数据的删除，memcached使用的是惰性删除，而redis同时使用惰性删除与定期删除。</li>
</ol>
<p><strong>解释</strong>：</p>
<ol>
<li><p>惰性删除：当访问一个键时，程序会对这个键进行检查，如果这个键已经过期，则将其删除。</p>
</li>
<li><p>定期删除：程序会在后台定期扫描过期的键，并将它们删除。</p>
</li>
<li><p>同步与异步，阻塞与非阻塞：实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成。 异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。</p>
<p>同步有阻塞和非阻塞之分，异步没有，它一定是非阻塞的。</p>
</li>
<li><p>IO复用模型：正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。</p>
</li>
</ol>
<h2 id="为什么要用redis，为什么使用缓存"><a href="#为什么要用redis，为什么使用缓存" class="headerlink" title="为什么要用redis，为什么使用缓存?"></a>为什么要用redis，为什么使用缓存?</h2><ol>
<li><p>快，高性能：</p>
<p>直接操作内存中的数据。</p>
</li>
<li><p>高并发：</p>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
</li>
</ol>
<h2 id="redis常用的数据结构"><a href="#redis常用的数据结构" class="headerlink" title="redis常用的数据结构"></a>redis常用的数据结构</h2><ol>
<li>string，简单的k-v键值对类型。应用场景有：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
<li>list，是一个双向链表。应用场景：发布与订阅或者说消息队列、慢查询。</li>
<li>hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>
<li>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。<strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>
</ol>
<h2 id="redis的单线程模型"><a href="#redis的单线程模型" class="headerlink" title="redis的单线程模型"></a>redis的单线程模型</h2><p>待续…..</p>
<h2 id="redis为什么开始不适用多线程？"><a href="#redis为什么开始不适用多线程？" class="headerlink" title="redis为什么开始不适用多线程？"></a>redis为什么开始不适用多线程？</h2><p>待续……</p>
<h2 id="redis6-0为什么又加入多线程？"><a href="#redis6-0为什么又加入多线程？" class="headerlink" title="redis6.0为什么又加入多线程？"></a>redis6.0为什么又加入多线程？</h2><p>待续……</p>
<h2 id="redis为什么要给数据设置过期时间？"><a href="#redis为什么要给数据设置过期时间？" class="headerlink" title="redis为什么要给数据设置过期时间？"></a>redis为什么要给数据设置过期时间？</h2><p>不然内存爆炸。</p>
<h2 id="redis是如何判断数据是否过期的？"><a href="#redis是如何判断数据是否过期的？" class="headerlink" title="redis是如何判断数据是否过期的？"></a>redis是如何判断数据是否过期的？</h2><p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<p><img src="http://cdn.rongshen2020.com/20201219a1.png"></p>
<h2 id="redis如何删除数据？"><a href="#redis如何删除数据？" class="headerlink" title="redis如何删除数据？"></a>redis如何删除数据？</h2><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。</p>
<p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p>
<h2 id="redis内存淘汰机制？"><a href="#redis内存淘汰机制？" class="headerlink" title="redis内存淘汰机制？"></a>redis内存淘汰机制？</h2><p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2 id="redis持久化机制？"><a href="#redis持久化机制？" class="headerlink" title="redis持久化机制？"></a>redis持久化机制？</h2><p>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。</p>
<p><strong>快照（snapshotting）持久化（RDB）：</strong>、</p>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure>



<p><strong>AOF（append-only file）持久化：</strong></p>
<p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>补充：</strong></p>
<p>redis4.0之后开始支持RDB与AOF的混合持久化。</p>
<p>AOF重写是产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p>
<h2 id="redis事务？"><a href="#redis事务？" class="headerlink" title="redis事务？"></a>redis事务？</h2><p>使用 <a href="https://redis.io/commands/multi">MULTI</a>命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec">EXEC</a>命令将执行所有命令。</p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p><strong>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。</strong></p>
<h2 id="缓存穿透？"><a href="#缓存穿透？" class="headerlink" title="缓存穿透？"></a>缓存穿透？</h2><p>大量请求的key不在缓存中，导致请求全部到了数据库一层。缓存形同虚设。</p>
<p><strong>解决办法：</strong></p>
<p>最基本就是前端做好参数校验。还有其他的两种方法：</p>
<ol>
<li><p>缓存无效key：</p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>布隆过滤器：</p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
</li>
</ol>
<h2 id="缓存雪崩？"><a href="#缓存雪崩？" class="headerlink" title="缓存雪崩？"></a>缓存雪崩？</h2><p>缓存在同一时间，大面积停止服务，那么所有的请求都会到数据库。之前的缓存穿透是缓存没失效，注意区别。</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<p><strong>解决：</strong></p>
<p>针对redis服务不可用：使用redis集群；做服务限流。</p>
<p>针对热点缓存失效的情况：为热点设置不同的失效时间；缓存永不失效。</p>
<h2 id="如何保存缓存与数据库的一致性？"><a href="#如何保存缓存与数据库的一致性？" class="headerlink" title="如何保存缓存与数据库的一致性？"></a>如何保存缓存与数据库的一致性？</h2><p>旁路缓存模式。Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<ol>
<li><p>可以将缓存的失效时间变短。（但对先缓存，后数据库场景不一定适用）</p>
</li>
<li><p>如果修改DB之后，出现缓存失效怎么办？可以增加cache更新重试机制。隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</p>
</li>
</ol>
<p>待续……</p>
<h2 id="HashMap与HashSet的区别？"><a href="#HashMap与HashSet的区别？" class="headerlink" title="HashMap与HashSet的区别？"></a>HashMap与HashSet的区别？</h2><ol>
<li>实现的接口不同，一个是Map<T>，一个是Set<T>。</li>
<li>HashMap对键值（key）做了一一对应的关系，不允许键值重复。存储的是k-v键值对模型。</li>
<li>HashSet中的数据是以哈希表的形式存放的，里面的不能包含重复数据。Set接口是一种一个不包含重复元素的 collection。存储的是对象。</li>
<li>hashMap使用键值来计算HashCode，而HashSet使用对象来计算HashCode。但是可能出现对于两个对象来说，hashcoode值相等。</li>
<li>hashmap比较快（因为使用唯一的键值来获取对象）。</li>
</ol>
<h2 id="Set集合与List集合？"><a href="#Set集合与List集合？" class="headerlink" title="Set集合与List集合？"></a>Set集合与List集合？</h2><ol>
<li>list集合以特定次序来持有元素，可能有重复元素。集合内部有序。</li>
<li>set集合，hashset集合比较两个对象是否相等，首先看hashcode，再看equals方法。set集合中不允许用相等的对象（不仅仅hashcode不同，equals比较也要不同）</li>
</ol>
<h2 id="fork了别人的项目，怎么实现同步更新？"><a href="#fork了别人的项目，怎么实现同步更新？" class="headerlink" title="fork了别人的项目，怎么实现同步更新？"></a>fork了别人的项目，怎么实现同步更新？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git remote add upstream https:<span class="comment">//github.com/Snailclimb/JavaGuide.git</span></span><br><span class="line"></span><br><span class="line">git pull upstream master</span><br></pre></td></tr></table></figure>

<p>解决<code>fatal: unable to access &#39;https://github.com/.../.git&#39;: Could not resolve host: github.com</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy </span><br><span class="line">    </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot集成shiro安全框架</title>
    <url>/2020/09/02/springBoot%E9%9B%86%E6%88%90shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>springBoot集成shiro框架的笔记，整理自狂神说课程~</p>
</blockquote>
<span id="more"></span>

<h2 id="1、shiro介绍："><a href="#1、shiro介绍：" class="headerlink" title="1、shiro介绍："></a>1、shiro介绍：</h2><p>Apache Shiro是一个功能强大且易于使用的Java安全框架，提供了认证，授权，加密，和会话管理</p>
<p>如同 Spring security 一样都是是一个权限安全框架，但是与Spring Security相比，在于他使用了和比较简洁易懂的认证和授权方式。</p>
<p><strong>Apache Shiro 的三大核心组件：</strong></p>
<p>1、Subject ：当前用户的操作</p>
<p>2、SecurityManager：用于管理所有的Subject</p>
<p>3、Realms：用于进行权限信息的验证</p>
<p>Subject：即当前用户，在权限管理的应用程序里往往需要知道谁能够操作什么，谁拥有操作该程序的权利，shiro中则需要通过Subject来提供基础的当前用户信息，Subject 不仅仅代表某个用户，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。</p>
<p>SecurityManager：即所有Subject的管理者，这是Shiro框架的核心组件，可以把他看做是一个Shiro框架的全局管理组件，用于调度各种Shiro框架的服务。</p>
<p>Realms：Realms则是用户的信息认证器和用户的权限人证器，我们需要自己来实现Realms来自定义的管理我们自己系统内部的权限规则。</p>
<p><strong>shiro的架构：（三大类）</strong><br><img src="http://cdn.rongshen2020.com/200902a1.png" alt="img"></p>
<p><strong>3、Authentication 和 Authorization</strong></p>
<p>在shiro的用户权限认证过程中其通过两个方法来实现：</p>
<p>1、Authentication：是验证用户身份的过程。</p>
<p>2、Authorization：是授权访问控制，用于对用户进行的操作进行人证授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。</p>
<p><strong>4、其他组件：</strong></p>
<p>除了以上几个组件外，Shiro还有几个其他组件：</p>
<p>1、SessionManager ：Shiro为任何应用提供了一个会话编程范式。</p>
<p>2、CacheManager :对Shiro的其他组件提供缓存支持。 </p>
<p><strong>5、Shiro 完整架构图：</strong> </p>
<p><img src="http://cdn.rongshen2020.com/200902a2.jfif" alt="img"></p>
<h2 id="2、shiro简单使用实例（上代码）："><a href="#2、shiro简单使用实例（上代码）：" class="headerlink" title="2、shiro简单使用实例（上代码）："></a>2、shiro简单使用实例（上代码）：</h2><p><strong>shiro三大对象（使用过程中需要配置），创建时从下往上配置创建：</strong></p>
<p><em>ShiroFilterFactoryBean</em>: shiro过滤的一些对象（用户）</p>
<p><em>DefaultWebSecurityManager</em>: shiro的安全对象（管理所有用户）</p>
<p><em>创建realm对象，需要自定义</em>（连接数据库）<br><strong>简单实例：</strong><br><strong>技术栈：springboot、mybatis、thymeleaf、shiro</strong><br><strong>总结:</strong><br>shiro有很强的自定义性，可以自定义较多的权限设置。<br>在创建shiro的三大对象时，应该从下往上编写，更具有逻辑性。<br>这个为初学shiro时写的一个很简单的案例。</p>
<ol>
<li><p>数据库：</p>
<p>最后一个perms字段是认证字段，user:update表示这个用户只有update权限。</p>
</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/200902a4.png" alt="image-20200830083845453"></p>
<ol start="2">
<li><p>项目的大致结构：</p>
<p><img src="http://cdn.rongshen2020.com/200902a3.png" alt="image-20200830084344626"></p>
</li>
<li><p>代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--整合mybatis和数据库--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">       &lt;!-- shiro整合spring的包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.2&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;</span></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">       &lt;!--shiro与thymeleaf--&gt;</span><br><span class="line">       &lt;!-- https:<span class="comment">//mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt;</span></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">           &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">               &lt;/exclusion&gt;</span><br><span class="line">           &lt;/exclusions&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> at.pollux.thymeleaf.shiro.dialect.ShiroDialect;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shiroFilterFactoryBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">getShiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">//设置安全管理器</span></span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加shiro的内置过滤器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             anon:无须认证就可以访问</span></span><br><span class="line"><span class="comment">             authc:必须认证了才能访问</span></span><br><span class="line"><span class="comment">             user:必须拥有，记住我功能才能用到</span></span><br><span class="line"><span class="comment">             perms:拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">             role：拥有某个角色权限才能访问</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        Map&lt;String, String&gt; filterMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/add&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/update&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/index&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 授权</span></span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/add&quot;</span>,<span class="string">&quot;perms[user:add]&quot;</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;/user/update&quot;</span>,<span class="string">&quot;perms[user:update]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置登录的请求</span></span><br><span class="line">        bean.setLoginUrl(<span class="string">&quot;/toLogin&quot;</span>);</span><br><span class="line">        <span class="comment">//设置未授权页面</span></span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">&quot;/noauth&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// DafaultWebSecurityManager</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;securityManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">getDefaultWebSecurityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;userRealm&quot;)</span> UserRealm userRealm)</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建realm对象，需要自定义</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;userRealm&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整合ShiroDialect：用来整合shiro thymeleaf</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">getShiroDialect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.aaron.services.UserService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.session.Session;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.awt.SystemColor.info;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的UserRealm继承AuthorizingRealm，重载方法进行授权和认证</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了授权方法doGetAuthorizationInfo~&quot;</span>);</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到这个登录对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        User currentUser = (User) subject.getPrincipal(); <span class="comment">//拿到user对象</span></span><br><span class="line">        <span class="comment">//设置当前用户的权限</span></span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了认证方法doGetAuthenticationInfo~&quot;</span>);</span><br><span class="line">        <span class="comment">// 用户名，密码，数据库去取</span></span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        User user = userService.queryByname(token.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Subject currentSubject = SecurityUtils.getSubject();</span><br><span class="line">        Session session = currentSubject.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;loginUser&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//MD5加密，也可以MD5盐值加密</span></span><br><span class="line">        <span class="comment">// 密码认证，shiro去做</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPwd(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,shiro&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user/add&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/update&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user/update&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toLogin&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//封装用户的登录数据</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            subject.login(token); <span class="comment">//执行登录的方法，没有异常就是登录成功了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e)&#123; <span class="comment">//用户名不存在</span></span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//未授权页面跳转</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/noauth&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unauthorized</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user/noauth&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.mapperDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> String perms;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd, String perms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">        <span class="keyword">this</span>.perms = perms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPerms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> perms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerms</span><span class="params">(String perms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.perms = perms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, perms=&#x27;&quot;</span> + perms + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.mapperDao.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSericeImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryByname</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.queryByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryByname</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.aaron.mapperDao.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;queryByName&quot;</span> parameterType=<span class="string">&quot;String&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">       select * from user where name = #&#123;name&#125;;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;add&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;add&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;未授权页面&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;update&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;update&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span> xmlns:th=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span></span><br><span class="line">      xmlns:shiro=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">&lt;div th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;session.loginUser == null&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;a href=&quot;@&#123;/toLogin&#125;&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;div shiro:hasPermission=<span class="string">&quot;user:add&quot;</span>&gt;</span><br><span class="line">    &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div shiro:hasPermission=<span class="string">&quot;user:update&quot;</span>&gt;</span><br><span class="line">    &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span> xmlns:th=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;login&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color: red&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;form th:action=<span class="string">&quot;@&#123;/login&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/mybatistest?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">    #Spring Boot 默认是不注入这些属性值的，需要自己绑定</span><br><span class="line">    #druid 数据源专有配置</span><br><span class="line">    initialSize: <span class="number">5</span></span><br><span class="line">    minIdle: <span class="number">5</span></span><br><span class="line">    maxActive: <span class="number">20</span></span><br><span class="line">    maxWait: <span class="number">60000</span></span><br><span class="line">    timeBetweenEvictionRunsMillis: <span class="number">60000</span></span><br><span class="line">    minEvictableIdleTimeMillis: <span class="number">300000</span></span><br><span class="line">    validationQuery: SELECT <span class="number">1</span> FROM DUAL</span><br><span class="line">    testWhileIdle: <span class="keyword">true</span></span><br><span class="line">    testOnBorrow: <span class="keyword">false</span></span><br><span class="line">    testOnReturn: <span class="keyword">false</span></span><br><span class="line">    poolPreparedStatements: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span><br><span class="line">    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span><br><span class="line">    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span><br><span class="line">    filters: stat,wall,log4j</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: <span class="number">20</span></span><br><span class="line">    useGlobalDataSourceStat: <span class="keyword">true</span></span><br><span class="line">    connectionProperties: druid.stat.mergeSql=<span class="keyword">true</span>;druid.stat.slowSqlMillis=<span class="number">500</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis.type-aliases-<span class="keyword">package</span>=com.aaron.pojo</span><br><span class="line">mybatis.mapper-locations=classpath:mappers<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud alibaba之seata分布式事务</title>
    <url>/2020/10/06/springcloud-alibaba%E4%B9%8Bseata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第十四章，Seata分布式事务解决方案。</p>
</blockquote>
<span id="more"></span>


<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p>
<p>例：用户购买商品的业务逻辑，整个业务逻辑由3个微服务提供支持。</p>
<ul>
<li>仓储服务：对给定的商品扣除仓储数量。</li>
<li>订单服务：根据采购需求创建订单。</li>
<li>账户服务：从用户账户中扣除余额。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020106a1.png"></p>
<p>一句话就是：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。</p>
<h3 id="分布式事务处理过程的ID-三组件模型："><a href="#分布式事务处理过程的ID-三组件模型：" class="headerlink" title="分布式事务处理过程的ID+三组件模型："></a>分布式事务处理过程的ID+三组件模型：</h3><p><img src="http://cdn.rongshen2020.com/2020106a2.png"></p>
<p>处理过程：</p>
<p><img src="http://cdn.rongshen2020.com/2020106a3.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020106a4.png"></p>
<h2 id="Seata-server安装："><a href="#Seata-server安装：" class="headerlink" title="Seata-server安装："></a>Seata-server安装：</h2><ol>
<li><p><strong>下载安装seata的安装包</strong></p>
</li>
<li><p><strong>修改file.conf</strong>，修改之前请先备份好</p>
<p>service模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vgroup_mapping.my_test_tx_group = <span class="string">&quot;fsp_tx_group&quot;</span></span><br></pre></td></tr></table></figure>

<p>store模块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mode = <span class="string">&quot;db&quot;</span></span><br><span class="line"></span><br><span class="line">  url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">  user = <span class="string">&quot;root&quot;</span></span><br><span class="line">  password = <span class="string">&quot;你自己的密码&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>mysql建库建表</strong></p>
<ol>
<li><p>上面指定了数据库为seata,所以创建一个数据库名为seata。</p>
</li>
<li><p>建表,在seata的安装目录下有一个db_store.sql,运行即可。</p>
</li>
</ol>
</li>
<li><p><strong>继续修改配置文件,修改seta\conf\registry.conf</strong></p>
<p>配置seata作为微服务,指定注册中心。</p>
<p><img src="http://cdn.rongshen2020.com/2020106a5.png"></p>
</li>
<li><p>启动：</p>
<p>先启动nacos，再启动seata-server(运行安装目录下的seata-server.bat。</p>
</li>
</ol>
<h2 id="Seata业务实例："><a href="#Seata业务实例：" class="headerlink" title="Seata业务实例："></a>Seata业务实例：</h2><p><img src="http://cdn.rongshen2020.com/2020106a6.png"></p>
<p>下单—&gt;库存—&gt;账号余额。</p>
<h3 id="业务数据库准备："><a href="#业务数据库准备：" class="headerlink" title="业务数据库准备："></a>业务数据库准备：</h3><ol>
<li><p>创建三个数据库：</p>
<ul>
<li>seata_order存储订单的数据库</li>
<li>seata_storage存储库存的数据库</li>
<li>seata_account存储账户信息的数据库</li>
</ul>
</li>
<li><p>按照上面的数据库创建对应的业务表：</p>
<ul>
<li>seata_order库下建t_order表</li>
<li>seata_storage库下建t_storage表</li>
<li>seata_account库下建t_account表</li>
</ul>
</li>
<li><p>创建回滚日志表，方便查看：</p>
<ul>
<li>订单-库存-账户3个库下都需要建各自的回滚日志表。建表sql位于seata\conf目录下的db_undo_log.sql</li>
<li><strong>注意每个库都要执行一次这个sql,生成回滚日志表</strong></li>
</ul>
</li>
<li><p>最终效果：</p>
<p><img src="http://cdn.rongshen2020.com/2020106a7.png"></p>
</li>
</ol>
<p>业务需求：下订单——》减库存——》扣余额——》改（订单）状态。订单状态0表示整个业务流程还未走完。1则表示整个业务流程已经走完了。</p>
<h3 id="Seata之order-moudle配置搭建："><a href="#Seata之order-moudle配置搭建：" class="headerlink" title="Seata之order-moudle配置搭建："></a>Seata之order-moudle配置搭建：</h3><ol>
<li><p>每个业务都创建一个微服务,也就是要有三个微服务,订单,库存,账号。<strong>订单seta-order-2001</strong></p>
</li>
<li><p>pom</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">&lt;!--nacos--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--seata--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--feign--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>YML配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2001</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-order-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        # 自定义事务组名称需要与seata-server中的对应,我们之前在seata的配置文件中配置的名字</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span></span><br><span class="line">  datasource:</span><br><span class="line">    # 当前数据源操作类型</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    # mysql驱动类</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/seata_order?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: <span class="keyword">false</span></span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath*:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure></li>
<li><p>还要额外创建其他配置文件,创建一个file.conf:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker &#x3D; false</span><br><span class="line">    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size &#x3D; 1</span><br><span class="line">    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size &#x3D; 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  # 事务组名称</span><br><span class="line">  vgroup_mapping.fsp_tx_group &#x3D; &quot;default&quot;</span><br><span class="line">  #only support single node</span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  #disable</span><br><span class="line">  disable &#x3D; false</span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit &#x3D; 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal &#x3D; 10</span><br><span class="line">    retry.times &#x3D; 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count &#x3D; 5</span><br><span class="line">  tm.commit.retry.count &#x3D; 1</span><br><span class="line">  tm.rollback.retry.count &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  #mode &#x3D; &quot;file&quot;</span><br><span class="line">  mode &#x3D; &quot;db&quot;</span><br><span class="line"> </span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir &#x3D; &quot;sessionStore&quot;</span><br><span class="line"> </span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size &#x3D; 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    max-global-session-size &#x3D; 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    file-write-buffer-cache-size &#x3D; 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size &#x3D; 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode &#x3D; async</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource &#x3D; &quot;dbcp&quot;</span><br><span class="line">    ## mysql&#x2F;oracle&#x2F;h2&#x2F;oceanbase etc.</span><br><span class="line">    db-type &#x3D; &quot;mysql&quot;</span><br><span class="line">    driver-class-name &#x3D; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata&quot;</span><br><span class="line">    user &#x3D; &quot;root&quot;</span><br><span class="line">    password &#x3D; &quot;root&quot;</span><br><span class="line">    min-conn &#x3D; 1</span><br><span class="line">    max-conn &#x3D; 3</span><br><span class="line">    global.table &#x3D; &quot;global_table&quot;</span><br><span class="line">    branch.table &#x3D; &quot;branch_table&quot;</span><br><span class="line">    lock-table &#x3D; &quot;lock_table&quot;</span><br><span class="line">    query-limit &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store mode: local、remote</span><br><span class="line">  mode &#x3D; &quot;remote&quot;</span><br><span class="line"> </span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks in user&#39;s database</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  remote &#123;</span><br><span class="line">    ## store locks in the seata&#39;s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  #schedule committing retry period in milliseconds</span><br><span class="line">  committing-retry-period &#x3D; 1000</span><br><span class="line">  #schedule asyn committing retry period in milliseconds</span><br><span class="line">  asyn-committing-retry-period &#x3D; 1000</span><br><span class="line">  #schedule rollbacking retry period in milliseconds</span><br><span class="line">  rollbacking-retry-period &#x3D; 1000</span><br><span class="line">  #schedule timeout retry period in milliseconds</span><br><span class="line">  timeout-retry-period &#x3D; 1000</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation &#x3D; true</span><br><span class="line">  undo.log.serialization &#x3D; &quot;jackson&quot;</span><br><span class="line">  undo.log.save.days &#x3D; 7</span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period &#x3D; 86400000</span><br><span class="line">  undo.log.table &#x3D; &quot;undo_log&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled &#x3D; false</span><br><span class="line">  registry-type &#x3D; &quot;compact&quot;</span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list &#x3D; &quot;prometheus&quot;</span><br><span class="line">  exporter-prometheus-port &#x3D; 9898</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建registry.conf:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type &#x3D; &quot;nacos&quot;</span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    #serverAddr &#x3D; &quot;localhost&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:8848&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost:6379&quot;</span><br><span class="line">    db &#x3D; &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout &#x3D; 6000</span><br><span class="line">    connect.timeout &#x3D; 2000</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:9603&quot;</span><br><span class="line">    application &#x3D; &quot;default&quot;</span><br><span class="line">    region &#x3D; &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter &#x3D; &quot;DefaultDataCenter&quot;</span><br><span class="line">    cluster &#x3D; &quot;default&quot;</span><br><span class="line">    group &#x3D; &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime &#x3D; &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;localhost&quot;</span><br><span class="line">    namespace &#x3D; &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.id &#x3D; &quot;seata-server&quot;</span><br><span class="line">    apollo.meta &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8801&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout &#x3D; 6000</span><br><span class="line">    connect.timeout &#x3D; 2000</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实际上,就是要将seata中的我们之前修改的两个配置文件复制到这个项目下</strong></p>
</li>
<li><p><strong>主启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span> <span class="comment">//取消数据源的自动创建</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeataOrderMain2001</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SeataOrderMain2001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>service层</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface OrderService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建订单</span><br><span class="line">     * @param order</span><br><span class="line">     */</span><br><span class="line">    void create(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = &quot;seata-storage-service&quot;)</span><br><span class="line">public interface StorageService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 减库存</span><br><span class="line">     * @param productId</span><br><span class="line">     * @param count</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(value = &quot;/storage/decrease&quot;)</span><br><span class="line">    CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = &quot;seata-account-service&quot;)</span><br><span class="line">public interface AccountService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 减余额</span><br><span class="line">     * @param userId</span><br><span class="line">     * @param money</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(value = &quot;/account/decrease&quot;)</span><br><span class="line">    CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class OrderServiceImpl implements OrderService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private OrderDao orderDao;</span><br><span class="line">    @Resource</span><br><span class="line">    private AccountService accountService;</span><br><span class="line">    @Resource</span><br><span class="line">    private StorageService storageService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态</span><br><span class="line">     * 简单说:</span><br><span class="line">     * 下订单-&gt;减库存-&gt;减余额-&gt;改状态</span><br><span class="line">     * GlobalTransactional seata开启分布式事务,异常时回滚,name保证唯一即可</span><br><span class="line">     * @param order 订单对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    ///@GlobalTransactional(name = &quot;fsp-create-order&quot;, rollbackFor = Exception.class)</span><br><span class="line">    public void create(Order order) &#123;</span><br><span class="line">        // 1 新建订单</span><br><span class="line">        log.info(&quot;-----&gt;开始新建订单&quot;);</span><br><span class="line">        orderDao.create(order);</span><br><span class="line"></span><br><span class="line">        // 2 扣减库存</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用库存,做扣减Count&quot;);</span><br><span class="line">        storageService.decrease(order.getProductId(), order.getCount());</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用库存,做扣减End&quot;);</span><br><span class="line"></span><br><span class="line">        // 3 扣减账户</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用账户,做扣减Money&quot;);</span><br><span class="line">        accountService.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">        log.info(&quot;-----&gt;订单微服务开始调用账户,做扣减End&quot;);</span><br><span class="line"></span><br><span class="line">        // 4 修改订单状态,从0到1,1代表已完成</span><br><span class="line">        log.info(&quot;-----&gt;修改订单状态开始&quot;);</span><br><span class="line">        orderDao.update(order.getUserId(), 0);</span><br><span class="line"></span><br><span class="line">        log.nfo(&quot;-----&gt;下订单结束了,O(∩_∩)O哈哈~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>dao层,也就是接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 新建订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(Order order)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 修改订单状态,从0改为1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;status&quot;)</span> Integer status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ==在resource下创建mapper文件夹,编写mapper.xml==</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.eiletxie.springcloud.alibaba.dao.OrderDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.eiletxie.springcloud.alibaba.domain.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span>//id是主键唯一标识</span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span>//这里的写法就是在数据库里面是user_id,在java的实体类里面是userId。其他的属性使用result</span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;product_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;productId&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;count&quot;</span> <span class="attr">property</span>=<span class="string">&quot;count&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.eiletxie.springcloud.alibaba.domain.Order&quot;</span> <span class="attr">u</span>   <span class="attr">seGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into t_order(user_id,product_id,count,money,status) values (#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update t_order set status =1 where user_id =#&#123;userId&#125; and status=#&#123;status&#125;;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p><strong>controller层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderService.create(order);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;订单创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>entity类(也叫domain类)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>config配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.eiletxie.springcloud.alibaba.dao&quot;&#125;)</span>		指定我们的接口的位置</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> EiletXie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Since</span> 2020/3/18 21:51</span></span><br><span class="line"><span class="comment"> * 使用Seata对数据源进行代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mapperLocations;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource druidDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSourceProxy);</span><br><span class="line">        ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        bean.setMapperLocations(resolver.getResources(mapperLocations));</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Seata之storage-moudle说明："><a href="#Seata之storage-moudle说明：" class="headerlink" title="Seata之storage-moudle说明："></a>Seata之storage-moudle说明：</h3><p><strong>库存seta-storage-2002</strong></p>
<ol>
<li><p>pom   </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">       &lt;!--nacos--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--seata--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">                   &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">               &lt;/exclusion&gt;</span><br><span class="line">           &lt;/exclusions&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;seata-all&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--feign--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.37&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">2002</span></span><br><span class="line"> </span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: seata-storage-service</span><br><span class="line">  cloud:</span><br><span class="line">    alibaba:</span><br><span class="line">      seata:</span><br><span class="line">        tx-service-group: fsp_tx_group</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/seata_storage</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">111111</span></span><br><span class="line"> </span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    io:</span><br><span class="line">      seata: info</span><br><span class="line"> </span><br><span class="line">mybatis:</span><br><span class="line">  mapperLocations: classpath:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure></li>
<li><p>file.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = <span class="string">&quot;TCP&quot;</span></span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server = <span class="string">&quot;NIO&quot;</span></span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = <span class="keyword">true</span></span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix = <span class="string">&quot;NettyBoss&quot;</span></span><br><span class="line">    worker-thread-prefix = <span class="string">&quot;NettyServerNIOWorker&quot;</span></span><br><span class="line">    server-executor-thread-prefix = <span class="string">&quot;NettyServerBizHandler&quot;</span></span><br><span class="line">    share-boss-worker = <span class="keyword">false</span></span><br><span class="line">    client-selector-thread-prefix = <span class="string">&quot;NettyClientSelector&quot;</span></span><br><span class="line">    client-selector-thread-size = <span class="number">1</span></span><br><span class="line">    client-worker-thread-prefix = <span class="string">&quot;NettyClientWorkerThread&quot;</span></span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size = <span class="number">1</span></span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size = <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  serialization = <span class="string">&quot;seata&quot;</span></span><br><span class="line">  compressor = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.fsp_tx_group = <span class="string">&quot;default&quot;</span></span><br><span class="line">  #only support single node</span><br><span class="line">  <span class="keyword">default</span>.grouplist = <span class="string">&quot;127.0.0.1:8091&quot;</span></span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade = <span class="keyword">false</span></span><br><span class="line">  #disable</span><br><span class="line">  disable = <span class="keyword">false</span></span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  max.rollback.retry.timeout = <span class="string">&quot;-1&quot;</span></span><br><span class="line">  disableGlobalTransaction = <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit = <span class="number">10000</span></span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal = <span class="number">10</span></span><br><span class="line">    retry.times = <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count = <span class="number">5</span></span><br><span class="line">  tm.commit.retry.count = <span class="number">1</span></span><br><span class="line">  tm.rollback.retry.count = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation = <span class="keyword">true</span></span><br><span class="line">  undo.log.serialization = <span class="string">&quot;jackson&quot;</span></span><br><span class="line">  undo.log.save.days = <span class="number">7</span></span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period = <span class="number">86400000</span></span><br><span class="line">  undo.log.table = <span class="string">&quot;undo_log&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy = <span class="keyword">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>registry.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk</span><br><span class="line">  type = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = <span class="string">&quot;http://localhost:8761/eureka&quot;</span></span><br><span class="line">    application = <span class="string">&quot;default&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost:6381&quot;</span></span><br><span class="line">    db = <span class="string">&quot;0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = <span class="number">6000</span></span><br><span class="line">    connect.timeout = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk</span><br><span class="line">  type = <span class="string">&quot;file&quot;</span></span><br><span class="line"> </span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.id = <span class="string">&quot;fescar-server&quot;</span></span><br><span class="line">    apollo.meta = <span class="string">&quot;http://192.168.1.204:8801&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    session.timeout = <span class="number">6000</span></span><br><span class="line">    connect.timeout = <span class="number">2000</span></span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure></li>
<li><p>service层，记得写接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StorageServiceImpl.class);</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StorageDao storageDao;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 扣减库存</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">(Long productId, Integer count)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存开始&quot;</span>);</span><br><span class="line">    storageDao.decrease(productId,count);</span><br><span class="line">    LOGGER.info(<span class="string">&quot;-------&gt;storage-service中扣减库存结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dao层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StorageDao</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//扣减库存信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decrease</span><span class="params">(<span class="meta">@Param(&quot;productId&quot;)</span> Long productId, <span class="meta">@Param(&quot;count&quot;)</span> Integer count)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/storage/decrease&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">decrease</span><span class="params">(Long productId, Integer count)</span> </span>&#123;</span><br><span class="line">        storageService.decrease(productId, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;扣减库存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>config配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.atguigu.springcloud.alibaba.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String mapperLocations;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(dataSource);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">    sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));</span><br><span class="line">    sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> SpringManagedTransactionFactory());</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Seata之account-moudle说明："><a href="#Seata之account-moudle说明：" class="headerlink" title="Seata之account-moudle说明："></a>Seata之account-moudle说明：</h3><p> <strong>账号seta-account-2003</strong></p>
<ol>
<li>   pom     </li>
<li>   配置文件</li>
<li>   主启动类</li>
<li>   service层</li>
<li>   dao层</li>
<li>   controller层</li>
<li>   <strong>全局创建完成后,首先测试不加seata</strong></li>
</ol>
<h3 id="使用seata的注解-GlobalTransaction"><a href="#使用seata的注解-GlobalTransaction" class="headerlink" title="使用seata的注解@GlobalTransaction:"></a>使用seata的注解@GlobalTransaction:</h3><p><strong>在订单模块的serviceImpl类中的==create方法==添加启动分布式事务的注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	这里添加开启分布式事务的注解,name指定当前全局事务的名称</span></span><br><span class="line"><span class="comment">	rollbackFor表示,发生什么异常需要回滚</span></span><br><span class="line"><span class="comment">	noRollbackFor:表示,发生什么异常不需要回滚</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span></span><br><span class="line"><span class="comment">///@GlobalTransactional(name = &quot;fsp-create-order&quot;, rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 新建订单</span></span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;开始新建订单&quot;</span>);</span><br><span class="line">    orderDao.create(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 扣减库存</span></span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存,做扣减Count&quot;</span>);</span><br><span class="line">    storageService.decrease(order.getProductId(), order.getCount());</span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;订单微服务开始调用库存,做扣减End&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 扣减账户</span></span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户,做扣减Money&quot;</span>);</span><br><span class="line">    accountService.decrease(order.getUserId(), order.getMoney());</span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;订单微服务开始调用账户,做扣减End&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 修改订单状态,从0到1,1代表已完成</span></span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;修改订单状态开始&quot;</span>);</span><br><span class="line">    orderDao.update(order.getUserId(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;-----&gt;下订单结束了,O(∩_∩)O哈哈~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>此时在测试</p>
<p>发现,发生异常后,直接回滚了,前面的修改操作都回滚了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud之Hystrix</title>
    <url>/2020/09/27/springcloud%E4%B9%8BHystrix/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第六章，Hystrix。hystrix已经停止了更新，目前处于维护阶段了。</p>
</blockquote>
<span id="more"></span>

<p>hystrix：豪猪</p>
<p><img src="http://cdn.rongshen2020.com/2020927b11.png"></p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>扇出：就是微服务之间的调用就像一把扇子一样，关联性太强了。</p>
<p>先来了解一下什么是服务雪崩：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b12.png"></p>
<p>Hystrix是什么？</p>
<p><img src="http://cdn.rongshen2020.com/2020927b13.png"></p>
<h2 id="Hystrix的几个重要概念："><a href="#Hystrix的几个重要概念：" class="headerlink" title="Hystrix的几个重要概念："></a>Hystrix的几个重要概念：</h2><ol>
<li><p><strong>服务降级fallback</strong></p>
<ul>
<li>比如当某个服务繁忙,不能让客户端的请求一直等待,应该立刻返回给客户端一个备选方案</li>
</ul>
</li>
<li><p><strong>服务熔断break</strong></p>
<ul>
<li>当某个服务出现问题,卡死了,不能让用户一直等待,需要关闭所有对此服务的访问，然后调用服务降级。</li>
</ul>
</li>
<li><p><strong>服务限流flowlimit</strong></p>
<ul>
<li>限流，比如秒杀场景,不能访问用户瞬间都访问服务器,限制一次只可以有多少请求</li>
</ul>
</li>
</ol>
<h2 id="Hystrix实现服务降级实例："><a href="#Hystrix实现服务降级实例：" class="headerlink" title="Hystrix实现服务降级实例："></a>Hystrix实现服务降级实例：</h2><h3 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h3><p><img src="http://cdn.rongshen2020.com/2020927b14.png"></p>
<p>说明：生产者与消费者都注册进eureka，消费者的调用使用OpenFeign。所以这些maven依赖不要忘记导入。</p>
<h3 id="创建不带降级模式的生成者模块："><a href="#创建不带降级模式的生成者模块：" class="headerlink" title="创建不带降级模式的生成者模块："></a>创建不带降级模式的生成者模块：</h3><ol>
<li><p>创建模块<code>cloud-provider-hystrix-payment8001</code></p>
</li>
<li><p>pom文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--hystrix--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--eureka client--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--web--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--一般基础通用配置--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--hutool插件--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: true  #false表示不向注册中心注册自己</span><br><span class="line">    fetch-registry: true #false表示自己端就是注册中心</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka/</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-provider-hystrix-payment</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentHystrixMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_ok</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;，paymentInfo_ok，id：&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;aaron&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeNumber = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(timeNumber);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;，paymentInfo_Timeout，id：&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;aaron&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_ok(id);</span><br><span class="line">        log.info(<span class="string">&quot;*********result&quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;*********result&quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动eureka和payment：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b15.png"></p>
</li>
<li><p><strong>高并发测试</strong>，先不加入hystrix支持，上面只是引入了一个pom包。</p>
<ul>
<li>使用jmeter压力测试工具，模拟20000个线程访问<code>http://localhost:8001/payment/hystrix/timeout/31</code>，最后我们发现<code>http://localhost:8001/payment/hystrix/ok/31</code>路径也被拖慢了（之前都是很快的响应的）。这是因为tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。</li>
</ul>
</li>
</ol>
<h3 id="创建不带降级模式的消费者模块："><a href="#创建不带降级模式的消费者模块：" class="headerlink" title="创建不带降级模式的消费者模块："></a>创建不带降级模式的消费者模块：</h3><ul>
<li>使用feign实现服务调用paymentHytrix8001。</li>
</ul>
<ol>
<li><p>创建模块<code>cloud-consumer-feign-hystrix-order80</code></p>
</li>
<li><p>pom文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--openFeign--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--hystrix--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--eureka client--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--web--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--一般基础通用配置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">80</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false  #表示不向注册中心注册自己，openFeign要求的</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderHystrixMain80.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service，需要远程调用接口，这是openFeign里面规定的：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>controller：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderHystrixController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentHystrixService paymentHystrixService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_OK(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<p><img src="http://cdn.rongshen2020.com/2020927b16.png"></p>
<p>但是<code>http://localhost/consumer/payment/hystrix/timeout/31</code>链接访问不成功！这是因为我们在消费者一侧写的timeOut线程休眠时间是5秒，而之前我们学过OpenFeign的默认时间是1秒：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b17.png"></p>
</li>
<li><p>以上都先不加入hystrix支持，这是可以看到<strong>服务错误</strong>和<strong>服务处理不了高并发却不降级</strong>，这都是我们需要解决的问题。</p>
</li>
</ol>
<p><strong>这个时候使用jmeter进行压力测试，和服务端payment压力测试时出现的情况差不多。</strong></p>
<h3 id="生产和消费模块配置服务降级："><a href="#生产和消费模块配置服务降级：" class="headerlink" title="生产和消费模块配置服务降级："></a>生产和消费模块配置服务降级：</h3><p>故障导致原因，所以我们需要有个东西来解决这些：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b18.png"></p>
<p>为了解决这些需求：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b19.png"></p>
<ul>
<li>降级配置Hystrix：<code>@HystrixCommand</code></li>
</ul>
<h4 id="修改pay8001模块，进行服务降级"><a href="#修改pay8001模块，进行服务降级" class="headerlink" title="修改pay8001模块，进行服务降级"></a>修改pay8001模块，进行服务降级</h4><ul>
<li><p>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作为服务降级fallback</p>
<p><img src="http://cdn.rongshen2020.com/2020927b20.png"></p>
</li>
<li><p>业务类service：</p>
<p>需要在超时方法上加一个注解，并写一个降级后的处理方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,</span></span><br><span class="line"><span class="meta">           commandProperties = &#123;</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;3000&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> timeNumber = <span class="number">5</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(timeNumber);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;，paymentInfo_Timeout，id：&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;aaron&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理超时访问，服务降级的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;调用支付接口服务异常，当前的线程池名字是：&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://cdn.rongshen2020.com/2020927b21.png"></p>
</li>
<li><p>主启动类激活，添加新注解<code>@EnableCircuitBreaker</code></p>
</li>
</ul>
<ul>
<li><p>启动测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b22.png"></p>
<p>访问：<code>http://localhost:8001/payment/hystrix/timeout/1</code>，由于服务降级设置的是3秒，请求了5秒，所以出现了服务降级。而且用的是单独的一个线程池。</p>
<p><img src="http://cdn.rongshen2020.com/2020927b23.png"></p>
<p>超时服务和运行报错，都可以进行服务降级。</p>
</li>
</ul>
<h4 id="修改order80模块，进行服务降级"><a href="#修改order80模块，进行服务降级" class="headerlink" title="修改order80模块，进行服务降级"></a>修改order80模块，进行服务降级</h4><ul>
<li><p>参照pay8001进行降级。</p>
</li>
<li><p>题外话，切记</p>
<p><strong>我们对于配置通过热部署方式对Java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务</strong></p>
</li>
<li><p>YML</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true # 开启hystrix服务降级</span><br></pre></td></tr></table></figure></li>
<li><p>主启动类</p>
<p><code>@EnableHystrix</code></p>
</li>
<li><p>业务类controller，同理，加上注解和降级后处理方法：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b24.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutFallbackHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">           @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;1500&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">       String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutFallbackHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;调用支付接口服务异常，当前的线程池名字是：&quot;</span>+Thread.currentThread().getName();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>测试，consumer中的timeOut超时时间设置的是1.5秒，而provider中的处理时间是5秒，它的超时时间设置的是3秒。</p>
<p><img src="http://cdn.rongshen2020.com/2020927b25.png"></p>
</li>
</ol>
<h2 id="重构以上代码："><a href="#重构以上代码：" class="headerlink" title="重构以上代码："></a>重构以上代码：</h2><p><strong>上面出现的问题:</strong></p>
<ol>
<li>降级方法与业务方法写在了一块,耦合度高</li>
<li>每个业务方法都写了一个降级方法,重复代码多</li>
</ol>
<p><strong>1、解决重复代码的问题：</strong></p>
<ul>
<li>配置一个全局的降级方法,所有方法都可以走这个降级方法,至于某些特殊创建,再单独创建方法</li>
</ul>
<ol>
<li><p>创建一个全局方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试~&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们是在order80模块上做演示：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b26.png"></p>
</li>
<li><p>使用注解指定其为全局降级方法（默认降级方法）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务方法使用默认降级方法</p>
<p><img src="http://cdn.rongshen2020.com/2020927b27.png"></p>
</li>
<li><p>测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b28.png"></p>
</li>
</ol>
<p><strong>2、解决代码耦合度的问题：</strong></p>
<p><strong>服务降级，客户端去调用服务端，碰上服务端宕机或关闭。本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦。</strong></p>
<p><strong>未来我们要面对的异常：</strong></p>
<ul>
<li>运行异常，超时，宕机。</li>
</ul>
<p>修改order模块,这里开始,pay模块就不服务降级了,服务降级写在order模块即可。</p>
<ol>
<li><p>修改cloud-consumer-feign-hystrix-order80模块。</p>
</li>
<li><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新创建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理。</p>
</li>
<li><p>PaymentFallbackService类实现PaymentHystrixService接口</p>
</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020927b29.png"></p>
<p>​    处理思路就是正常那么久走正常的接口，出现错误需要降级久走，该fallback实现类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_OK</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------PaymentFallbackService fall back back-paymentInfo_OK.........&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------PaymentFallbackService fall back back-paymentInfo_TimeOut.........&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>修改配置文件yml，记得开启hystrix：</p>
</li>
<li><p>PaymentHystrixService接口，添加降级处理的类的注解：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b30.png"></p>
</li>
<li><p>启动测试：</p>
<ul>
<li><p>单个eureka先启动7001</p>
</li>
<li><p>PaymentHystrixMain8001启动</p>
</li>
<li><p>正常访问测试</p>
<ul>
<li><a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></li>
</ul>
</li>
<li><p>故意关闭微服务8001</p>
<ul>
<li>访问超时错误，还是走全局方法：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020927b31.png"></p>
</li>
<li><p>客户端自己调用测试</p>
<ul>
<li><a href="http://localhost/consumer/payment/hystrix/ok/1">http://localhost/consumer/payment/hystrix/ok/1</a></li>
</ul>
<p>这时，就是处理超时调用的请求无论是调用错误还是超时错误还是走全局方法，正常的调用错误走接口实现类的降级方法：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b32.png"></p>
</li>
</ul>
</li>
</ol>
<h2 id="Hystrix实现服务熔断："><a href="#Hystrix实现服务熔断：" class="headerlink" title="Hystrix实现服务熔断："></a>Hystrix实现服务熔断：</h2><p>理论：类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。服务降级——》进而熔断——》恢复调用链路。</p>
<h3 id="熔断机制："><a href="#熔断机制：" class="headerlink" title="熔断机制："></a>熔断机制：</h3><p><img src="http://cdn.rongshen2020.com/2020927b33.png"></p>
<h3 id="修改前面的pay模块实现服务熔断："><a href="#修改前面的pay模块实现服务熔断：" class="headerlink" title="修改前面的pay模块实现服务熔断："></a>修改前面的pay模块实现服务熔断：</h3><p>IdUtil是Hutool包下的类,这个Hutool就是整合了所有的常用方法,比如UUID,反射,IO流等工具方法什么的都整合了。记得导入依赖。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>修改<code>cloud-provider-hystrix-payment8001</code></p>
</li>
<li><p>PaymentService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;), // 请求次数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;), // 时间窗口期</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),  // 失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;*******id不能为负数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String serialNumber = IdUtil.simpleUUID();</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功，流水号：&quot;</span>+serialNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;id不能为负数，请稍后再试，&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;id:&quot;</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020927b34.png"></p>
<p>这里的这么多属性表示的意思是：在10秒的窗口期中，处理10次请求，如果有6次失败就服务熔断，也就是跳闸。</p>
</li>
<li><p>PaymentController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;*******result:&quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b35.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020927b36.png"></p>
<ul>
<li><p>配置熔断之后，先一直刷新-1，使错误率达到100%，开启断路器。之后再试1，不能马上反应过来，等达到60%之后，才会恢复正常。这就是熔断机制：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b37.png"></p>
</li>
</ul>
</li>
</ol>
<h3 id="熔断的类型："><a href="#熔断的类型：" class="headerlink" title="熔断的类型："></a>熔断的类型：</h3><p><img src="http://cdn.rongshen2020.com/2020927b38.png"></p>
<h3 id="断路器在什么情况下起作用："><a href="#断路器在什么情况下起作用：" class="headerlink" title="断路器在什么情况下起作用："></a>断路器在什么情况下起作用：</h3><p><img src="http://cdn.rongshen2020.com/2020927b39.png"></p>
<h3 id="断路器开启或者关闭的条件："><a href="#断路器开启或者关闭的条件：" class="headerlink" title="断路器开启或者关闭的条件："></a>断路器开启或者关闭的条件：</h3><p><img src="http://cdn.rongshen2020.com/2020927b40.png"></p>
<h3 id="断路器打开之后："><a href="#断路器打开之后：" class="headerlink" title="断路器打开之后："></a>断路器打开之后：</h3><p><img src="http://cdn.rongshen2020.com/2020927b41.png"></p>
<h2 id="Hystrix所有可配置的属性："><a href="#Hystrix所有可配置的属性：" class="headerlink" title="Hystrix所有可配置的属性："></a>Hystrix所有可配置的属性：</h2><p><img src="http://cdn.rongshen2020.com/2020927b42.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020927b43.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020927b44.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020927b45.png"></p>
<h2 id="Hystrix工作流程："><a href="#Hystrix工作流程：" class="headerlink" title="Hystrix工作流程："></a>Hystrix工作流程：</h2><p><img src="http://cdn.rongshen2020.com/2020927b46.png"></p>
<h2 id="Hystrix服务监控，图形化DashBoard："><a href="#Hystrix服务监控，图形化DashBoard：" class="headerlink" title="Hystrix服务监控，图形化DashBoard："></a>Hystrix服务监控，图形化DashBoard：</h2><h3 id="搭建监控："><a href="#搭建监控：" class="headerlink" title="搭建监控："></a>搭建监控：</h3><ol>
<li><p>新建<code>cloud-consumer-hystrix-dashboard9001</code></p>
</li>
<li><p>POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9001</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动类HystrixDashboardMain9001+新注解<code>@EnableHystrixDashboard</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardMain9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardMain9001.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>所有的Provider微服务类（8001/8002/8003…）都需要监控依赖配置，这个依赖必须要。</p>
<p><img src="http://cdn.rongshen2020.com/2020927b47.png"></p>
</li>
<li><p>启动cloud-consumer-hystrix-dashboard9001该微服务后将监控微服务8001：</p>
<p><img src="http://cdn.rongshen2020.com/2020927b48.png"></p>
</li>
<li><p>此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002。。。如果要监控,还需要配置:(8001为例)</p>
</li>
</ol>
<h3 id="如何使用监控浏览器："><a href="#如何使用监控浏览器：" class="headerlink" title="如何使用监控浏览器："></a>如何使用监控浏览器：</h3><ol>
<li><p>修改<code>cloud-provider-hystrix-payment8001</code></p>
<ul>
<li>注意新版本需要在主启动类中去增加监控路径，否则404报错。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此服务是为了服务监控配置的，与服务容错本身无关。</span></span><br><span class="line"><span class="comment">     * 这个是springcloud新版本里确定加的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/2020927b49.png"></p>
</li>
<li><p>监控测试</p>
<ol>
<li><p>启动1个eureka或者3个eureka集群即可</p>
<ul>
<li>9001监控8001即可：<a href="http://localhost:8001/hystrix.stream">http://localhost:8001/hystrix.stream</a></li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020927b50.png"></p>
</li>
<li><p>观察监控窗口</p>
<ul>
<li>新开窗口访问：localhost:8001/payment/circuit/1,localhost:8001/payment/circuit/-1</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020927b51.png"></p>
</li>
<li><p>怎么来看这一张图：</p>
<p>七色、一圈、一线。这个我也没懂。</p>
</li>
</ol>
</li>
</ol>
<p>ps：写于2020.9.27号，写了一天，出去吃饭了。值得纪念！</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5学习笔记</title>
    <url>/2020/07/26/Spring5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>Spring学习笔记</p>
</blockquote>
<span id="more"></span>

<h1 id="1、IoC"><a href="#1、IoC" class="headerlink" title="1、IoC"></a>1、IoC</h1><p>Spring的IoC(控制反转) 、DI(依赖注入)。</p>
<p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。DI是实现IoC的一种方法。控制反转是一种设计思想。</strong></p>
<p>传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建。</p>
<p>写得很好的一篇博客：<a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">https://www.cnblogs.com/xdp-gacl/p/4249939.html</a></p>
<p>spring官网：<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-annotation-config">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-annotation-config</a></p>
<ul>
<li>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/20726b1.png" alt="image-20200718211620579"></p>
<ul>
<li>从上面的图中我们也看到了中间件的影子。</li>
</ul>
<h2 id="1-1、如何实现IoC："><a href="#1-1、如何实现IoC：" class="headerlink" title="1.1、如何实现IoC："></a>1.1、如何实现IoC：</h2><p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<p><img src="http://cdn.rongshen2020.com/20726b2.png" alt="image-20200718211940110"></p>
<ul>
<li>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</li>
</ul>
<h2 id="1-2、HelloSpring："><a href="#1-2、HelloSpring：" class="headerlink" title="1.2、HelloSpring："></a>1.2、HelloSpring：</h2><ol>
<li><p>创建一个无模板的maven项目。</p>
</li>
<li><p>在该项目中在创建一个maven模块。可以添加spring或者springMVC的支持。或者直接创建一个SpringMVC的模块。</p>
</li>
<li><p>ApplicationContext.xml文件的大致样子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;helloSpring&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Person&quot;</span>&gt;</span><br><span class="line">        &lt;!--在这里改变赋值就可以改变测试的输出--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aaron.pojo.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.TestConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ApplicationContext.xml&quot;</span>);</span><br><span class="line">        Person helloSpring = (Person) context.getBean(<span class="string">&quot;helloSpring&quot;</span>);</span><br><span class="line">        helloSpring.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2、IoC创建对象的方式"><a href="#2、IoC创建对象的方式" class="headerlink" title="2、IoC创建对象的方式"></a>2、IoC创建对象的方式</h1><ol>
<li><p>默认使用无参构造创建对象。</p>
</li>
<li><p>假设我们需要使用有参构造来创建对象。可以使用注入构造器：</p>
<p>参考文档：<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-dependencies">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-dependencies</a></p>
<ol>
<li>第一种，参数下标赋值：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例如你的构造函数是：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">那么index就是你有参方法里面的参数的下标，从<span class="number">0</span>开始：</span><br><span class="line">&lt;bean id=<span class="string">&quot;exampleBean&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg index=<span class="string">&quot;0&quot;</span> value=<span class="string">&quot;aaron荣燊&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二种，参数类型赋值：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;exampleBean&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg type=<span class="string">&quot;java.lang.String&quot;</span> value=<span class="string">&quot;aaron荣燊&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三种，参数名来赋值：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;exampleBean&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;aaron荣燊&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！而且是单例的。。。就是相同的对象只创建一个。</p>
<h1 id="3、Spring配置"><a href="#3、Spring配置" class="headerlink" title="3、Spring配置"></a>3、Spring配置</h1><h2 id="3-1、别名："><a href="#3-1、别名：" class="headerlink" title="3.1、别名："></a>3.1、别名：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;helloSpring&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Person&quot;</span>&gt;</span><br><span class="line">        &lt;!--在这里改变赋值就可以改变测试的输出--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;hello spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;alias name=&quot;helloSpring&quot; alias=&quot;jj&quot;&gt;&lt;/alias&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;ApplicationContext.xml&quot;</span>);</span><br><span class="line">        Person helloSpring = (Person) context.getBean(<span class="string">&quot;jj&quot;</span>);</span><br><span class="line">        helloSpring.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-2、Bean的配置："><a href="#3-2、Bean的配置：" class="headerlink" title="3.2、Bean的配置："></a>3.2、Bean的配置：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id：bean的唯一标识符，也就是相当于我们学的对象名</span><br><span class="line"><span class="class"><span class="keyword">class</span>：<span class="title">bean</span>对象所对应的权限定名，包名+类型</span></span><br><span class="line"><span class="class"><span class="title">name</span>：通过<span class="title">name</span>也可以取别名，而且那么可以取多个别名。</span></span><br><span class="line"><span class="class"><span class="title">scope</span>：是否是单例模式</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">&lt;<span class="title">bean</span> <span class="title">id</span></span>=<span class="string">&quot;helloSpring&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Person&quot;</span> name=<span class="string">&quot;jj jj1,jj2;jj3&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>&gt;</span><br><span class="line">        &lt;!--在这里改变赋值就可以改变测试的输出--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;hello spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3、import："><a href="#3-3、import：" class="headerlink" title="3.3、import："></a>3.3、import：</h2><ul>
<li><p>一般用于团队开发使用，他可以将多个xml配置文件导入合并为一个。</p>
</li>
<li><p>applicationContext.xml：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;helloSpring&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Person&quot;</span>&gt;</span><br><span class="line">        &lt;!--在这里改变赋值就可以改变测试的输出--&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;hello spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;alias name=&quot;helloSpring&quot; alias=&quot;jj&quot;&gt;&lt;/alias&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>bean.xml：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationContext.xml&quot;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationContext1.xml&quot;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">import</span> resource=<span class="string">&quot;applicationContext2.xml&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>后期直接使用总的bean.xml配置文件就可以了。</p>
<h1 id="4、DI依赖注入"><a href="#4、DI依赖注入" class="headerlink" title="4、DI依赖注入"></a>4、DI依赖注入</h1><h2 id="4-1、构造器注入："><a href="#4-1、构造器注入：" class="headerlink" title="4.1、构造器注入："></a>4.1、构造器注入：</h2><p>前面已经讲过了。</p>
<h2 id="4-2、Set方式注入【重点】："><a href="#4-2、Set方式注入【重点】：" class="headerlink" title="4.2、Set方式注入【重点】："></a>4.2、Set方式注入【重点】：</h2><ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入。</li>
<li>例：</li>
</ul>
<ol>
<li><p>项目构造：</p>
<p><img src="http://cdn.rongshen2020.com/20726b3.png" alt="image-20200719131600188"></p>
</li>
<li><p>Address.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Student.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getBooks() &#123;</span><br><span class="line">        <span class="keyword">return</span> books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(String[] books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.books = books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHobbys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getCard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getGames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGames</span><span class="params">(Set&lt;String&gt; games)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(String wife)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(Properties info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address.toString() +</span><br><span class="line">                <span class="string">&quot;, books=&quot;</span> + Arrays.toString(books) +</span><br><span class="line">                <span class="string">&quot;, hobbys=&quot;</span> + hobbys +</span><br><span class="line">                <span class="string">&quot;, card=&quot;</span> + card +</span><br><span class="line">                <span class="string">&quot;, games=&quot;</span> + games +</span><br><span class="line">                <span class="string">&quot;, wife=&#x27;&quot;</span> + wife + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, info=&quot;</span> + info +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>bean.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;address1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Address&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; value=&quot;江西九江&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=<span class="string">&quot;student&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Student&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 第一种，普通值注入，使用value --&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;荣燊&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 第二种，bean注入，使用ref --&gt;</span><br><span class="line">        &lt;property name=&quot;address&quot; ref=&quot;address1&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- String数组注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;books&quot;</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;红楼梦&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;西游记&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;三国演义&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;水浒传&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- List数组注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;hobbys&quot;</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;唱歌&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;看电影&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;写代码&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;运动&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Map数组注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;card&quot;</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;身份证&quot;</span> value=<span class="string">&quot;123123123123123123&quot;</span>/&gt;</span><br><span class="line">                &lt;entry key=<span class="string">&quot;银行卡&quot;</span> value=<span class="string">&quot;1231231231231231234567&quot;</span>/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Set注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;games&quot;</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;LOL&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;COC&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- NULL空字符串注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;wife&quot;</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">null</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Properties注入--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;学号&quot;&gt;1467002030&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;passWord&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Mytest.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aaron.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出：</p>
<p><img src="http://cdn.rongshen2020.com/20726b4.png" alt="image-20200719131957489"></p>
</li>
</ol>
<h2 id="4-3、拓展方式注入："><a href="#4-3、拓展方式注入：" class="headerlink" title="4.3、拓展方式注入："></a>4.3、拓展方式注入：</h2><p>说明：p命名空间像之前的直接注入，c命名空间注入像通过一个有参构造器注入。p命名空间与c命名空间都不能直接使用，需要导入xml约束。</p>
<ul>
<li><h3 id="p命名空间导入："><a href="#p命名空间导入：" class="headerlink" title="p命名空间导入："></a>p命名空间导入：</h3></li>
</ul>
<ol>
<li>命名头：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实体类User.java：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>xml文件中就可以这样写：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- p命名空间可以直接注入同样的值，property --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.User&quot;</span> p:userName=<span class="string">&quot;夏天&quot;</span> p:age=<span class="string">&quot;18&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="c命名空间导入："><a href="#c命名空间导入：" class="headerlink" title="c命名空间导入："></a>c命名空间导入：</h3></li>
</ul>
<p>注意，该命名空间是要求  实体类里面  写了有参构造器的。</p>
<ol>
<li>命名头：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实体类中需要写   有参构造器  ：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在这里写一个无参构造器，那么p命名空间也可以用了</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>xml文件中就可以这样写：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.User&quot;</span> c:userName=<span class="string">&quot;谢磊&quot;</span> c:age=<span class="string">&quot;25&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h1 id="5、bean的作用域scope"><a href="#5、bean的作用域scope" class="headerlink" title="5、bean的作用域scope"></a>5、bean的作用域scope</h1><p><img src="http://cdn.rongshen2020.com/20726b5.png" alt="image-20200719161622482"></p>
<h2 id="5-1、singleton单例："><a href="#5-1、singleton单例：" class="headerlink" title="5.1、singleton单例："></a>5.1、singleton单例：</h2><p>默认实现用这种。</p>
<h2 id="5-2、prototyp原型："><a href="#5-2、prototyp原型：" class="headerlink" title="5.2、prototyp原型："></a>5.2、prototyp原型：</h2><p>也就是多例。每次从容器中get的时候，都会产生一个新对象。</p>
<ol>
<li><p>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;user&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.User&quot;</span> c:userName=<span class="string">&quot;谢磊&quot;</span> c:age=<span class="string">&quot;25&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用：<br><img src="http://cdn.rongshen2020.com/20726b6.png" alt="image-20200719162229863"></p>
</li>
</ol>
<h2 id="5-3、其余："><a href="#5-3、其余：" class="headerlink" title="5.3、其余："></a>5.3、其余：</h2><p>其余的像request、session、application这些只能在web开发中使用到。</p>
<h1 id="6、Bean的自动装配"><a href="#6、Bean的自动装配" class="headerlink" title="6、Bean的自动装配"></a>6、Bean的自动装配</h1><ul>
<li>自动装配是spring满足bean依赖的一种方式。</li>
<li>spring会在上下文context中自动寻找，并自动给bean装配属性。</li>
</ul>
<p>在spring中有三种装配的方式</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示的配置</li>
<li>隐式的自动装配bean【重要】</li>
</ol>
<h2 id="6-1、-Autowired："><a href="#6-1、-Autowired：" class="headerlink" title="6.1、@Autowired："></a>6.1、@Autowired：</h2><h3 id="6-1-1、byName自动装配："><a href="#6-1-1、byName自动装配：" class="headerlink" title="6.1.1、byName自动装配："></a>6.1.1、byName自动装配：</h3><ul>
<li><p>byName会自动在容器上下文中查找，和自己对象set方法后面的值对饮的bean的id。id是要小写的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;cat&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Cat&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt;  <span class="comment">//id必须小写，与people里的对应</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;dog1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt;  <span class="comment">//错误</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;Dog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt;  <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;people&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.People&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;谢蕾蕾&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-1-2、byType自动装配："><a href="#6-1-2、byType自动装配：" class="headerlink" title="6.1.2、byType自动装配："></a>6.1.2、byType自动装配：</h3><ul>
<li><p>byName会自动在容器上下文中查找，和自己对象属性类型相同的bean。类型必须唯一。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;cat&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Cat&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dog111&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt;  </span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt; <span class="comment">//不用id也可以</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;dog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt; <span class="comment">//错误，和上面的定义只能有一个在</span></span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">&quot;people&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.People&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;谢蕾蕾&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-1-3、小结："><a href="#6-1-3、小结：" class="headerlink" title="6.1.3、小结："></a>6.1.3、小结：</h3><ul>
<li>byName的时候，需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</li>
<li>byType的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致。</li>
</ul>
<h2 id="6-2、注解实现自动装配："><a href="#6-2、注解实现自动装配：" class="headerlink" title="6.2、注解实现自动装配："></a>6.2、注解实现自动装配：</h2><p>jdk1.5支持注解，spring2.5就开始支持注解。</p>
<p>要使用注解：</p>
<ol>
<li><p>导入约束，context约束。</p>
</li>
<li><p>配置注解的支持</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>直接在属性上使用即可，也可以在set方法上使用。使用Autowired我们可以不用写set方法了，前提是你这个自动装配的属性在IOC容器中存在。：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;cat&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Cat&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.Dog&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;people&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.pojo.People&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>科普：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> 字段标记了这个注解，说明这个字段可以为<span class="keyword">null</span>；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired(required = false)</span> <span class="comment">//里面的值可以为空，null    </span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;dog&quot;)</span> <span class="comment">//多个装配相同的对象，可以和autowired搭配使用</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Resource</span> <span class="comment">//java的原生注解</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>小结：</p>
<p>@Resource和@Autowired的区别：</p>
<pre><code>1. 都是用来自动装配的，都可以放在属性字段上
 2. @Autowired通过byType的方式实现，而且必须要求这个对象存在。
 3. @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现。
</code></pre>
</li>
</ul>
<h1 id="7、使用注解开发"><a href="#7、使用注解开发" class="headerlink" title="7、使用注解开发"></a>7、使用注解开发</h1><p>在spring4之后要使用注解开发，必须导入AOP的包了。使用注解需要导入context的约束，增加注解的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定要扫描的包，这个包下面的注解就会生效</span></span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.aaron.pojo&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>

<p>@Component：组件，放在类上，说明这个类被Spring管理了，就是bean。</p>
<h2 id="7-1、bean："><a href="#7-1、bean：" class="headerlink" title="7.1、bean："></a>7.1、bean：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解等价于&lt;bean id=&quot;user&quot; class=&quot;com.aaron.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="comment">//注册组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;夏天&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2、属性如何注入："><a href="#7-2、属性如何注入：" class="headerlink" title="7.2、属性如何注入："></a>7.2、属性如何注入：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于&lt;property name=&quot;name&quot; value=&quot;夏天&quot;/&gt;，也可以注解在set方法上</span></span><br><span class="line"><span class="meta">@Value(&quot;夏天&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="meta">@Value(&quot;夏天&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3、衍生的注解："><a href="#7-3、衍生的注解：" class="headerlink" title="7.3、衍生的注解："></a>7.3、衍生的注解：</h2><p>@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层。</p>
<ul>
<li>dao层：<code>@Repository</code></li>
<li>service层：<code>@Service</code></li>
<li>controller{servlet}层：<code>@Controller</code></li>
<li>这四个注解都是代表将某个类注册到Spring中，装配bean。</li>
</ul>
<h2 id="7-4、自动装配："><a href="#7-4、自动装配：" class="headerlink" title="7.4、自动装配："></a>7.4、自动装配：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> 字段标记了这个注解，说明这个字段可以为<span class="keyword">null</span>；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired(required = false)</span> <span class="comment">//里面的值可以为空，null    </span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;dog&quot;)</span> <span class="comment">//多个装配相同的对象，可以和autowired搭配使用</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Resource</span> <span class="comment">//java的原生注解</span></span><br></pre></td></tr></table></figure>

<h2 id="7-5、作用域："><a href="#7-5、作用域：" class="headerlink" title="7.5、作用域："></a>7.5、作用域：</h2><p>@Scope</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6、小结："><a href="#7-6、小结：" class="headerlink" title="7.6、小结："></a>7.6、小结：</h2><p>比较xml配置文件与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护更加方便。</li>
<li>注解，不是自己的类使用不了，维护相对复杂。</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li>xml用来管理bean。</li>
<li>注解只负责完成属性的注入。</li>
</ul>
<p>我们在使用的过程中，只需要注意一个问题：让注解生效，必须开启注解的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.aaron.pojo&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h1 id="8、使用java的方式配置Spring"><a href="#8、使用java的方式配置Spring" class="headerlink" title="8、使用java的方式配置Spring"></a>8、使用java的方式配置Spring</h1><p>我们现在不使用Spring中xml的配置方式了，交给java来做。</p>
<p>JavaConfig是Spring的一个子项目，在spring4之后，他称为了一个新功能。</p>
<p><img src="http://cdn.rongshen2020.com/20726b7.png" alt="image-20200719210501430"></p>
<p><img src="http://cdn.rongshen2020.com/20726b8.png" alt="image-20200719210538628"></p>
<p>这种纯java的注解在spingboot中随处可见。所以springboot很重要。</p>
<h1 id="9、代理模式proxy"><a href="#9、代理模式proxy" class="headerlink" title="9、代理模式proxy"></a>9、代理模式proxy</h1><h2 id="9-1、静态代理："><a href="#9-1、静态代理：" class="headerlink" title="9.1、静态代理："></a>9.1、静态代理：</h2><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决 </li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色之后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务（例如日志功能 ）。</li>
<li>公共业务也就交给代理角色，实现了业务的分工。</li>
<li>公共业务发生扩展的时候，方便集中管理。</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量就会翻倍，开发效率会更低</li>
</ul>
<h2 id="9-2、动态代理："><a href="#9-2、动态代理：" class="headerlink" title="9.2、动态代理："></a>9.2、动态代理：</h2><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的。</li>
<li>动态代理分为两大类：<strong>1.基于接口的动态代理，2.基于类的动态代理。</strong><ul>
<li>基于接口——JDK代理</li>
<li>基于类的——cglib</li>
<li>java字节码实现——javasist </li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy代理，InvocationHandler调用处理程序。</p>
<p><strong>动态代理的好处：</strong></p>
<ul>
<li>可以使真实角色的操作可以更加纯粹！不用去关注一些公共的业务。</li>
<li>公共业务就交给代理角色！实现了业务的分工。</li>
<li>公共业务发生扩展的时候，方便集中管理。</li>
<li>一个动态代理类代理的就是一个接口，一般就是对应的一类业务。</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可。</li>
</ul>
<p><strong>实例：</strong></p>
<ol>
<li><p>UserService接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.proxyDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接口里面的类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserService接口实现类UserServiceImpl：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aaron.proxyDemo;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        System.out.println(&quot;新增一个用户~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delete() &#123;</span><br><span class="line">        System.out.println(&quot;删除一个用户~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;修改一个用户~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void query() &#123;</span><br><span class="line">        System.out.println(&quot;查询一个用户~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ProxyInvocationHandler自动生成代理类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aaron.proxyDemo;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等会我们会用这个类，自动生成代理类</span><br><span class="line">public class ProxyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;被代理的接口</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public void setTarget(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生成得到代理类</span><br><span class="line">    public Object getProxy()&#123;</span><br><span class="line">        return Proxy.newProxyInstance(this.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;处理代理实例，并返回结果</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        log(method.getName());</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void log(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;调用了&quot;+msg+&quot;方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.aaron.proxyDemo;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;真实角色</span><br><span class="line">        UserServiceImpl userService &#x3D; new UserServiceImpl();</span><br><span class="line">        &#x2F;&#x2F;代理角色</span><br><span class="line">        ProxyInvocationHandler pih &#x3D; new ProxyInvocationHandler();</span><br><span class="line">        &#x2F;&#x2F;设置要代理的对象</span><br><span class="line">        pih.setTarget(userService);</span><br><span class="line">        &#x2F;&#x2F;动态生成代理类</span><br><span class="line">        UserService proxy &#x3D; (UserService) pih.getProxy();</span><br><span class="line">        proxy.add();</span><br><span class="line">        proxy.delete();</span><br><span class="line">        proxy.update();</span><br><span class="line">        proxy.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="10、AOP"><a href="#10、AOP" class="headerlink" title="10、AOP"></a>10、AOP</h1><h2 id="10-1、什么是AOP："><a href="#10-1、什么是AOP：" class="headerlink" title="10.1、什么是AOP："></a>10.1、什么是AOP：</h2><p> 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过<strong>预编译方式和运行期间动态代理</strong>实现程序功能的统一维护的一种技术。</p>
<p><strong>AOP的几个专业术语：</strong></p>
<ul>
<li><p>横切关注点：</p>
</li>
<li><p>通知方法：（就像日志工具类LogUtils里面的LogStart、LogReturn等等方法）</p>
</li>
<li><p>切面类：（就像日志工具类LogUtils）</p>
</li>
<li><p>连接点：每一个方法的每一个位置就是一个连接点。</p>
</li>
<li><p>切入点：红色部分，我们真正需要执行日志记录的地方。</p>
</li>
<li><p>图见：</p>
<p><img src="http://cdn.rongshen2020.com/20726b9.png" alt="img"></p>
</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/image-20200721082031772.png" alt="image-20200721082031772"></p>
<h2 id="10-2、AOP在Spring中的作用："><a href="#10-2、AOP在Spring中的作用：" class="headerlink" title="10.2、AOP在Spring中的作用："></a>10.2、AOP在Spring中的作用：</h2><p><img src="http://cdn.rongshen2020.com/image-20200721082511662.png" alt="image-20200721082511662"></p>
<h2 id="10-3、使用Spring实现AOP："><a href="#10-3、使用Spring实现AOP：" class="headerlink" title="10.3、使用Spring实现AOP："></a>10.3、使用Spring实现AOP：</h2><h3 id="10-3-1、使用Spring的API接口实现："><a href="#10-3-1、使用Spring的API接口实现：" class="headerlink" title="10.3.1、使用Spring的API接口实现："></a>10.3.1、使用Spring的API接口实现：</h3><ol>
<li><p>使用到的jar包（有些包应该也不是必须的）：</p>
<p><img src="http://cdn.rongshen2020.com/image-20200721100200905.png" alt="image-20200721100200905"></p>
</li>
<li><p>项目结构：</p>
<p><img src="http://cdn.rongshen2020.com/image-20200721100302953.png" alt="image-20200721100302953"></p>
</li>
<li><p>各类、接口、方法与xml配置：</p>
<ul>
<li><p>UserService接口与UserServiceImpl实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">package</span> com.aaron.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.aaron.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口方法实现前执行的Log：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//method：要执行的目标对象的方法</span></span><br><span class="line">    <span class="comment">//args：参数</span></span><br><span class="line">    <span class="comment">//target：目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(target.getClass().getName()+<span class="string">&quot;目标对象的&quot;</span>+method.getName()+<span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口方法实现后执行的LogAfter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAfter</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//o：返回结果</span></span><br><span class="line">    <span class="comment">//objects：参数</span></span><br><span class="line">    <span class="comment">//o1：目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+method.getName()+<span class="string">&quot;方法，返回结果为：&quot;</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>beans.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;log&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.log.Log&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;logAfter&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.log.LogAfter&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--方式一：使用原生的Spring API接口--&gt;</span><br><span class="line">    &lt;!--配置AOP，需要导入aop的约束--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点，expression表达式，要执行的位置execution(修饰词 返回值 类名 方法名 参数)--&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">&quot;pointcut&quot;</span> expression=<span class="string">&quot;execution(* com.aaron.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--执行环绕增加，将log这个类加到id为pointcut的切入点上--&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:advisor&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">&quot;logAfter&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aaron.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.aaron.service.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//动态代理代理的是个接口，注意点</span></span><br><span class="line">        UserService userService = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出：</p>
<p><img src="http://cdn.rongshen2020.com/image-20200721100448732.png" alt="image-20200721100448732"></p>
</li>
</ol>
<h3 id="10-3-2、自定义类来实现："><a href="#10-3-2、自定义类来实现：" class="headerlink" title="10.3.2、自定义类来实现："></a>10.3.2、自定义类来实现：</h3><p>基于以上的测试类不变，新增一个diy的类，xml文件里的写法也要改变：</p>
<ul>
<li><p>diy的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.diy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiyPointcut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前————————&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后————————&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>beans.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;diy&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.diy.DiyPointcut&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--方法二，自定义类--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--自定义切面，ref要使用的类--&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">&quot;diy&quot;</span>&gt;</span><br><span class="line">            &lt;!--切入点--&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">&quot;point&quot;</span> expression=<span class="string">&quot;execution(* com.aaron.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br><span class="line">            &lt;!--通知--&gt;</span><br><span class="line">            &lt;aop:before method=<span class="string">&quot;before&quot;</span> pointcut-ref=<span class="string">&quot;point&quot;</span>/&gt;</span><br><span class="line">            &lt;aop:after method=<span class="string">&quot;after&quot;</span> pointcut-ref=<span class="string">&quot;point&quot;</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类不变，结果为：</p>
<p><img src="http://cdn.rongshen2020.com/image-20200721105741754.png" alt="image-20200721105741754"></p>
</li>
</ul>
<h3 id="10-3-3、使用注解实现："><a href="#10-3-3、使用注解实现：" class="headerlink" title="10.3.3、使用注解实现："></a>10.3.3、使用注解实现：</h3><ul>
<li><p>先标记切入类和切入方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记类是一个切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.aaron.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前——————&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.aaron.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后——————&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在环绕增强的时候，我们可以给定一个参数，代表我们要获取处理切入的点</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.aaron.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>beans.xml中注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;annotionPointCut&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.annotation.AnnotationPointCut&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类不变，测试结果：</p>
<p><img src="http://cdn.rongshen2020.com/image-20200721134056609.png" alt="image-20200721134056609"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis3学习笔记</title>
    <url>/2020/07/26/mybatis3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>个人学习笔记mybatis</p>
</blockquote>
<span id="more"></span>

<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
<h2 id="1-1、什么是MyBatis："><a href="#1-1、什么是MyBatis：" class="headerlink" title="1.1、什么是MyBatis："></a>1.1、什么是MyBatis：</h2><ul>
<li><p>MyBatis 是一款优秀的<strong>持久层框架</strong>，它支持自定义 SQL、存储过程以及高级映射。</p>
</li>
<li><p>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p>
</li>
<li><p>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old  Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
</li>
<li><p>maven仓库：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2、持久层："><a href="#1-2、持久层：" class="headerlink" title="1.2、持久层："></a>1.2、持久层：</h2><p>数据持久化：</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程。</li>
</ul>
<h1 id="2、HelloMybatis"><a href="#2、HelloMybatis" class="headerlink" title="2、HelloMybatis"></a>2、HelloMybatis</h1><ul>
<li><p>搭建环境（数据库）——》导入mybatis——》编写代码——》测试！</p>
</li>
<li><p>项目结构：<br><img src="http://cdn.rongshen2020.com/20726a1.png"></p>
</li>
</ul>
<ol>
<li><p>新建一个maven项目，删除src目录，建立module项目，导入maven依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个子模块，编写mybatis的核心配置文件和编写mybatis的工具类：</p>
<ul>
<li>mybatis-config.xml：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">&quot;POOLED&quot;</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatistest?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>MybatisUtils工具类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用mybatis第一步，获取sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然有了SqlSessionFactory,顾名思义，</span></span><br><span class="line">    <span class="comment">// 我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line">    <span class="comment">// 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-1、编写代码："><a href="#2-1、编写代码：" class="headerlink" title="2.1、编写代码："></a>2.1、编写代码：</h2><ul>
<li><p>实体类User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口实现类，由原来的UserDaoImpl.java变成了UserMapper.xml文件了：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这里的id就像接口里要实现的方法名，resultType是执行sql语句后的返回值类型。里面写好sql语句。</span></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.aaron.dao.UserDao&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;getUserList&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">        select * from mybatistest.user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.aaron.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步，获得SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//执行SQL</span></span><br><span class="line">        UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭SqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试结果：</p>
<p><img src="http://cdn.rongshen2020.com/20726a2.png" alt="image-20200721203459936"></p>
</li>
</ul>
<h1 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h1><p>C：Create增加，R：Retrieve查询，U：Update修改，D：Delete删除。</p>
<h2 id="3-1、namespace："><a href="#3-1、namespace：" class="headerlink" title="3.1、namespace："></a>3.1、namespace：</h2><p>namespace中的包名要和dao/mapper接口的包名一致；</p>
<ul>
<li>UserMapper.xml：</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/20726a3.png" alt="image-20200723124353020"></p>
<h2 id="3-2、select、insert、update、delete："><a href="#3-2、select、insert、update、delete：" class="headerlink" title="3.2、select、insert、update、delete："></a>3.2、select、insert、update、delete：</h2><p>写起来很简单，之前的pojo实体类和utils工具类以及mybatis-config.xml配置文件都不用改变。主要改变的是dao层的接口类和UserMapper.xml配置文件：</p>
<p><img src="http://cdn.rongshen2020.com/20726a4.png" alt="image-20200723130502497"></p>
<ul>
<li><p>dao层里面的接口UserDao.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取全部用户</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据id查询用户</span></span><br><span class="line">   <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//插入用户</span></span><br><span class="line">   <span class="function">Integer <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//修改用户</span></span><br><span class="line">   <span class="function">Integer <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据id删除用户</span></span><br><span class="line">   <span class="function">Integer <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserMapper.xml：</p>
  <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.aaron.dao.UserDao&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;getUserList&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">        select * from mybatistest.user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;getUser&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">        select * from mybatistest.user where id = #&#123;userId&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;addUser&quot;</span> parameterType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">        insert into mybatistest.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;updateUser&quot;</span> parameterType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">        update mybatistest.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;deleteUser&quot;</span>&gt;</span><br><span class="line">        delete from mybatistest.user where id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.aaron.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步，获得SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//执行SQL</span></span><br><span class="line">        UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭SqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        User user = mapper.getUser(<span class="number">4</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改需要提交事务</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line">        Integer flag = mapper.addUser(<span class="keyword">new</span> User(<span class="number">7</span>,<span class="string">&quot;哈哈&quot;</span>,<span class="string">&quot;12345&quot;</span>));</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        Integer flag = mapper.updateUser(<span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;123dssdd&quot;</span>));</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        Integer flag = mapper.deleteUser(<span class="number">7</span>);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3、map传递参数："><a href="#3-3、map传递参数：" class="headerlink" title="3.3、map传递参数："></a>3.3、map传递参数：</h2><p>假设我们的实体类，或者数据库中的表、字段或者参数过多，我们应当考虑使用Map。</p>
<ul>
<li>实体类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递map参数</span></span><br><span class="line"><span class="function">User <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件UserMapper.xml：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;addUser2&quot;</span> parameterType=<span class="string">&quot;map&quot;</span>&gt;</span><br><span class="line">	insert into mybatistest.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试时：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;夏天天1号&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        mapper.addUser2(map);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3种情况：</strong></p>
<ul>
<li>Map传递参数，直接在sql中取出key即可！</li>
<li>对象传递参数，直接在sql中取对象的属性即可。</li>
<li>只有一个基本类型参数的，可以直接在sql中取到。</li>
</ul>
<h2 id="3-4、模糊查询："><a href="#3-4、模糊查询：" class="headerlink" title="3.4、模糊查询："></a>3.4、模糊查询：</h2><ol>
<li><p>java执行代码的时候，传递通配符<code>% %</code>。</p>
<p><img src="http://cdn.rongshen2020.com/20726a5.png" alt="image-20200723144008235"></p>
</li>
<li><p>sql注入问题一览：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user where id = ?;</span><br><span class="line">select * from user where id = <span class="number">1</span>;</span><br><span class="line">与</span><br><span class="line">select * from user where id = <span class="number">1</span> or <span class="number">1</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>模糊查询实例：</p>
<ul>
<li><p>实体类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模糊查询，根据名字</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件UserMapper.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUserLike&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.User&quot;</span>&gt;</span><br><span class="line">    select * from mybatistest.user where name like #&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%夏%&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="4、配置之属性优化"><a href="#4、配置之属性优化" class="headerlink" title="4、配置之属性优化"></a>4、配置之属性优化</h1><blockquote>
<p>注意里面的属性书写是有先后之分的：(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”。注意哈，这都是写在mybatis-config.xmll文件中的。</p>
</blockquote>
<h2 id="4-1、核心配置mybatis-config-xml："><a href="#4-1、核心配置mybatis-config-xml：" class="headerlink" title="4.1、核心配置mybatis-config.xml："></a>4.1、核心配置mybatis-config.xml：</h2><ul>
<li><p>mybatis-config.xml配置文件中包含了会深深影响mybatis行为的设置和属性信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2、环境配置（environment）："><a href="#4-2、环境配置（environment）：" class="headerlink" title="4.2、环境配置（environment）："></a>4.2、环境配置（environment）：</h2><p>mybatis可以配置成适应多种环境。</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境。</strong></p>
<p>学会使用配置多套环境运行。</p>
<p>mybatis默认的事务管理器就是JDBC，连接池POOLED。</p>
<h2 id="4-3、properties（属性）："><a href="#4-3、properties（属性）：" class="headerlink" title="4.3、properties（属性）："></a>4.3、properties（属性）：</h2><p>我们可以通过properti属性来实现引用配置文件。这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】</p>
<ol>
<li><p>编写db.properties配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/mybatistest?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure></li>
<li><p>在核心配置文件mybatis-config.xml中引入：</p>
<ul>
<li>直接引入外部文件：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=<span class="string">&quot;db.properties&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在其中可以增加属性配置：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=<span class="string">&quot;db.properties&quot;</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;12345&quot;</span>/&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果既有外部配置文件，又配置了相同的属性，优先使用外部配置文件里面的属性。</li>
</ul>
</li>
</ol>
<h2 id="4-4、类型别名（typeAliases）："><a href="#4-4、类型别名（typeAliases）：" class="headerlink" title="4.4、类型别名（typeAliases）："></a>4.4、类型别名（typeAliases）：</h2><ol>
<li>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的<strong>全限定类名</strong>书写。例如：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias type=<span class="string">&quot;com.aaron.pojo.User&quot;</span> alias=<span class="string">&quot;user&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>那么在UserMapper.xml中使用时：</p>
<p><img src="http://cdn.rongshen2020.com/20726a6.png" alt="image-20200723182221949"></p>
<ol start="2">
<li><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，扫描实体类的包，他的默认名就为这个类的类名，首字母小写！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">  &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.aaron.pojo.User&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br><span class="line">    </span><br><span class="line">使用时就是parameterType=<span class="string">&quot;user&quot;</span>，类名的首字母小写即可。</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结说明：</strong>在实体类比较少的时候，使用第一种方式。如果实体类十分多，建议使用第二种。第一种可以diy别名，第二种则不行，如果非要改，需要在实体上增加注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;user1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li>别名参考：下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</li>
</ul>
<table>
<thead>
<tr>
<th>别名</th>
<th>映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td>_byte</td>
<td>byte</td>
</tr>
<tr>
<td>_long</td>
<td>long</td>
</tr>
<tr>
<td>_short</td>
<td>short</td>
</tr>
<tr>
<td>_int</td>
<td>int</td>
</tr>
<tr>
<td>_integer</td>
<td>int</td>
</tr>
<tr>
<td>_double</td>
<td>double</td>
</tr>
<tr>
<td>_float</td>
<td>float</td>
</tr>
<tr>
<td>_boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h2 id="4-5、设置（settings）："><a href="#4-5、设置（settings）：" class="headerlink" title="4.5、设置（settings）："></a>4.5、设置（settings）：</h2><p><img src="http://cdn.rongshen2020.com/20726a7.png" alt="image-20200723200701175"></p>
<p><img src="http://cdn.rongshen2020.com/20726a8.png" alt="image-20200723200728188"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">  &lt;setting name=<span class="string">&quot;lazyLoadingEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-6、其他配置："><a href="#4-6、其他配置：" class="headerlink" title="4.6、其他配置："></a>4.6、其他配置：</h2><ul>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins（插件）：<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h2 id="4-7、映射器（mappers）："><a href="#4-7、映射器（mappers）：" class="headerlink" title="4.7、映射器（mappers）："></a>4.7、映射器（mappers）：</h2><p>我们需要告诉 MyBatis 到哪里去找到 SQL 映射语句，就是UserMapper.xml这样的文件里定义的。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。</p>
<p><strong>MapperRegistry：注册绑定我们的Mapper文件。每一个Mapper.xml都需要在mybatis的核心配置文件里面注册。</strong></p>
<ul>
<li><p>方式一：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;com/aaron/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.dao.UserMapper&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用这种方式的注意点：<ul>
<li>接口和它的Mapper配置文件必须同名。</li>
<li>接口和他的Mapper配置文件必须在同一包下。</li>
</ul>
</li>
</ul>
</li>
<li><p>方式三：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将包内的映射器接口实现全部注册为映射器,--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">  &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.aaron.dao&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用这种方式的注意点：<ul>
<li>接口和它的Mapper配置文件必须同名。</li>
<li>接口和他的Mapper配置文件必须在同一包下。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-8、生命周期与作用域："><a href="#4-8、生命周期与作用域：" class="headerlink" title="4.8、生命周期与作用域："></a>4.8、生命周期与作用域：</h2><p>生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。</p>
<p><strong>SqlSessionFactoryBuilder:</strong></p>
<ul>
<li>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。所以可以将其设置为<strong>局部变量。</strong></li>
</ul>
<p><strong>SqlSessionFactory：</strong></p>
<ul>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 </li>
<li>其很像一个数据库连接池。</li>
<li>最简单的就是使用单例模式或者静态单例模式。</li>
</ul>
<p><strong>SqlSession：</strong></p>
<ul>
<li>就像连接到连接池的一个请求</li>
<li>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/20726a9.png" alt="image-20200723212754942"></p>
<p>这里面的每一个Mapper，就代表一个具体的业务！</p>
<h1 id="5、解决属性名和字段名不一致的问题："><a href="#5、解决属性名和字段名不一致的问题：" class="headerlink" title="5、解决属性名和字段名不一致的问题："></a>5、解决属性名和字段名不一致的问题：</h1><p>数据库中的字段：</p>
<p><img src="http://cdn.rongshen2020.com/20726a10.png" alt="image-20200723204731043"></p>
<p>当你的实体类pojo如果和数据库中的字段不一致时。</p>
<p>例如：你在实体类里面将数据库的pwd写成password，那么有可能查出的user里面password=null。</p>
<p><img src="http://cdn.rongshen2020.com/20726a11.png" alt="image-20200724073143227"></p>
<p><strong>解决方法：</strong></p>
<h2 id="5-1、起别名"><a href="#5-1、起别名" class="headerlink" title="5.1、起别名"></a>5.1、起别名</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id,name,pwd as password from mybatistest.user;</span><br></pre></td></tr></table></figure>

<h2 id="5-2、resultMap："><a href="#5-2、resultMap：" class="headerlink" title="5.2、resultMap："></a>5.2、resultMap：</h2><p>结果集映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id   name   pwd</span><br><span class="line">id   name   password</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<p><img src="http://cdn.rongshen2020.com/20726a12.png" alt="image-20200724074046862"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=<span class="string">&quot;userResultMap&quot;</span> type=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">  &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;user_id&quot;</span> /&gt;</span><br><span class="line">  &lt;result property=<span class="string">&quot;username&quot;</span> column=<span class="string">&quot;user_name&quot;</span>/&gt;</span><br><span class="line">  &lt;result property=<span class="string">&quot;password&quot;</span> column=<span class="string">&quot;hashed_password&quot;</span>/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">&lt;select id=<span class="string">&quot;selectUsers&quot;</span> resultMap=<span class="string">&quot;userResultMap&quot;</span>&gt;</span><br><span class="line">  select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h1 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h1><h2 id="6-1、日志工厂："><a href="#6-1、日志工厂：" class="headerlink" title="6.1、日志工厂："></a>6.1、日志工厂：</h2><p>如果一个数据库操作出现了异常，我们需要排除。所以日志就是最好的助手。</p>
<p>曾经的实现方法：sout、debug。</p>
<p>现在的方法：日志工厂。</p>
<p><img src="http://cdn.rongshen2020.com/20726a13.png" alt="image-20200724093712912"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING【掌握】</li>
<li>NO_LOGGING</li>
</ul>
<p>在mybatis中具体使用哪一种日志实现，在设置中设定。</p>
<p><strong>STDOUT_LOGGING：标准日志输出</strong></p>
<p>在mybatis核心配置文件中，配置我们的日志！</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;logImpl&quot;</span> value=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/20726a14.png" alt="image-20200724095336391"></p>
<h2 id="6-2、LOG4J讲解："><a href="#6-2、LOG4J讲解：" class="headerlink" title="6.2、LOG4J讲解："></a>6.2、LOG4J讲解：</h2><p>什么是LOG4J？</p>
<ul>
<li><p>Log4j是Apache的一个开放源代码项目bai，通过du使用Log4j，我们可以控制zhi日志信息输送的目的地是控制台、文件。。。</p>
</li>
<li><p>我们也可以控制每一条日志的输出格式；</p>
</li>
<li><p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>
</li>
<li><p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
</li>
</ul>
<ol>
<li><p>先导入log4j的包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在CLASSPATH下建立log4j.properties。内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=【%c】-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/kuang.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=【%p】【%d&#123;yy-MM-dd&#125;】【%c】%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure></li>
<li><p>在mybatis的核心配置文件中，配置log4j为日志的实现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">   &lt;setting name=<span class="string">&quot;logImpl&quot;</span> value=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>log4j的使用，测试运行查询方法：</p>
<p><img src="http://cdn.rongshen2020.com/20726a15.png" alt="image-20200724114147100"></p>
</li>
</ol>
<p><strong>log4j的简单使用：</strong></p>
<ol>
<li><p>在要使用的Log4j的类中，导入包import <code>org.apache.log4j.Logger;</code></p>
</li>
<li><p>日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mucfc;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(Test.class);  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        logger.debug(<span class="string">&quot;This is debug message.&quot;</span>); </span><br><span class="line">        logger.info(<span class="string">&quot;This is info message.&quot;</span>);   </span><br><span class="line">        logger.error(<span class="string">&quot;This is error message.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>日志级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;This is debug message.&quot;</span>); </span><br><span class="line">logger.info(<span class="string">&quot;This is info message.&quot;</span>);   </span><br><span class="line">logger.error(<span class="string">&quot;This is error message.&quot;</span>);  </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h1><p><strong>思考：为什么要分页？</strong></p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h2 id="7-1、使用Limit分页："><a href="#7-1、使用Limit分页：" class="headerlink" title="7.1、使用Limit分页："></a>7.1、使用Limit分页：</h2><p>sql语句：<code>select * from user limit startIndex,pageSize; </code></p>
<p>数据库的下标也是从0开始的。假设：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select * from user limit <span class="number">0</span>,<span class="number">2</span>;</span><br><span class="line">select * from user limit <span class="number">2</span>,<span class="number">2</span>;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<h2 id="7-2、RowBounds分页："><a href="#7-2、RowBounds分页：" class="headerlink" title="7.2、RowBounds分页："></a>7.2、RowBounds分页：</h2><p>不建议使用。</p>
<h2 id="7-3、分页插件："><a href="#7-3、分页插件：" class="headerlink" title="7.3、分页插件："></a>7.3、分页插件：</h2><h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><ol>
<li><p>注解在接口上实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有的用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>需要在mybatis-config.xml核心配置文件中绑定接口：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--绑定接口--&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.aaron.dao.UserDao&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>本质：反射机制。</p>
<p>底层：动态代理。</p>
<h2 id="8-1、CRUD："><a href="#8-1、CRUD：" class="headerlink" title="8.1、CRUD："></a>8.1、CRUD：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id和name查询用户</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125; and name = #&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserBy</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于@Param()注解：<ul>
<li>基本类型的参数或者String类型，需要加上。</li>
<li>引用类型不需要加。</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上。</li>
<li>我们在sql中引用的就是我们这里的@Param(“”)中设定的属性名。</li>
</ul>
</li>
</ul>
<h1 id="9、Lombok的使用："><a href="#9、Lombok的使用：" class="headerlink" title="9、Lombok的使用："></a>9、Lombok的使用：</h1><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。Lombok也存在一定风险，在一些开发工具商店中没有Project Lombok支持选择。 IDE和JDK升级存在破裂的风险，并且围绕项目的目标和实施存在争议。 </p>
<ol>
<li><p>在IDEA中安装lombok的插件。</p>
</li>
<li><p>在项目中导入lombok的jar包。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>lombok的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span> ：注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。</span><br><span class="line"><span class="meta">@Getter</span> ：使用方法同上，区别在于生成的是getter方法。</span><br><span class="line"><span class="meta">@ToString</span> ：注解在类，添加toString方法。</span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>： 注解在类，生成hashCode和equals方法。</span><br><span class="line"><span class="meta">@NoArgsConstructor</span>： 注解在类，生成无参的构造方法。</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>： 注解在类，为类中需要特殊处理的字段生成构造方法，比如<span class="keyword">final</span>和被<span class="meta">@NonNull</span>注解的字段。</span><br><span class="line"><span class="meta">@AllArgsConstructor</span>： 注解在类，生成包含类中所有字段的构造方法。</span><br><span class="line"><span class="meta">@Data</span>： 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为<span class="keyword">final</span>属性，则不会为该属性生成setter方法。</span><br><span class="line"><span class="meta">@Slf4j</span>： 注解在类，生成log变量，严格意义来说是常量。</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="10、多对一与一对多"><a href="#10、多对一与一对多" class="headerlink" title="10、多对一与一对多"></a>10、多对一与一对多</h1><p><strong>联表查询。</strong></p>
<p>多个学生对应一个老师，老师的id对应学生的tid。</p>
<p>创建这两张表的sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">	) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher(`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;秦老师&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`tid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">	KEY `fktid` (`tid`),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> KEY (`tid`) <span class="keyword">REFERENCES</span> `teacher` (`id`)</span><br><span class="line">	) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line">	</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;小张&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="keyword">VALUES</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;小王&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.rongshen2020.com/20726a16.png" alt="image-20200725100251765"></p>
<ul>
<li><p>如果要查询所有的学生表，已经关联的所有老师：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select s.id s.name t.id t.name from student s,teacher t where s.tid = t.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>例如如下的两张表：</p>
<p><img src="http://cdn.rongshen2020.com/20726a17.png" alt="image-20200725113252815"></p>
<p><img src="http://cdn.rongshen2020.com/20726a18.png" alt="image-20200725113338525"></p>
<ul>
<li>student表的tid对应teacher表的id。那么我想实现如下的查询结果该如何实现。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/20726a19.png" alt="image-20200725113439096"></p>
<h2 id="10-1、多对一处理："><a href="#10-1、多对一处理：" class="headerlink" title="10.1、多对一处理："></a>10.1、多对一处理：</h2><h3 id="10-1-1、方式1，类似于子查询："><a href="#10-1-1、方式1，类似于子查询：" class="headerlink" title="10.1.1、方式1，类似于子查询："></a>10.1.1、方式1，类似于子查询：</h3><ul>
<li><p>实体类：</p>
<p>`````<br>package com.aaron.pojo;</p>
<p>public class Student {</p>
<pre><code>private int id;
private String name;
//学生需要关联一个老师
private Teacher teacher;

public Student() &#123;
&#125;

public Student(int id, String name, Teacher teacher) &#123;
    this.id = id;
    this.name = name;
    this.teacher = teacher;
&#125;

public int getId() &#123;
    return id;
&#125;

public void setId(int id) &#123;
    this.id = id;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public Teacher getTeacher() &#123;
    return teacher;
&#125;

public void setTeacher(Teacher teacher) &#123;
    this.teacher = teacher;
&#125;

@Override
public String toString() &#123;
    return &quot;Student&#123;&quot; +
            &quot;id=&quot; + id +
            &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &quot;, teacher=&quot; + teacher +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">package com.aaron.pojo;</span><br><span class="line"></span><br><span class="line">public class Teacher &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Teacher(int id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Teacher() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Teacher&#123;&quot; +</span><br><span class="line">                &quot;id&#x3D;&quot; + id +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>StudentMapper.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.aaron.dao.StudentMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;getStudentList&quot;</span> resultMap=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span><br><span class="line">        select * from student;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;getTeacher&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.Teacher&quot;</span>&gt;</span><br><span class="line">        select * from teacher where id = #&#123;tid&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap id=<span class="string">&quot;StudentTeacher&quot;</span> type=<span class="string">&quot;com.aaron.pojo.Student&quot;</span>&gt;</span><br><span class="line">        &lt;result property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;name&quot;</span>/&gt;</span><br><span class="line">        &lt;!--对于复杂的属性：对象：association。集合：collection。--&gt;</span><br><span class="line">        &lt;association property=<span class="string">&quot;teacher&quot;</span> column=<span class="string">&quot;tid&quot;</span> javaType=<span class="string">&quot;com.aaron.pojo.Teacher&quot;</span> select=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>以上的步骤很像子查询处理。</p>
<p><img src="http://cdn.rongshen2020.com/20726a20.png" alt="image-20200725121132359"></p>
</li>
</ul>
<h3 id="10-1-2、方式2，按照结果嵌套查询："><a href="#10-1-2、方式2，按照结果嵌套查询：" class="headerlink" title="10.1.2、方式2，按照结果嵌套查询："></a>10.1.2、方式2，按照结果嵌套查询：</h3><ul>
<li><p>在StudentMapper.xml文件中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--按照结果嵌套查询--&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;getStudentList2&quot;</span> resultMap=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span><br><span class="line">    select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;StudentTeacher2&quot;</span> type=<span class="string">&quot;com.aaron.pojo.Student&quot;</span>&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;sid&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;sname&quot;</span>/&gt;</span><br><span class="line">    &lt;association property=<span class="string">&quot;teacher&quot;</span> javaType=<span class="string">&quot;com.aaron.pojo.Teacher&quot;</span>&gt;</span><br><span class="line">        &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;tname&quot;</span>/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="http://cdn.rongshen2020.com/20726a21.png" alt="image-20200725120745107"></p>
<h2 id="10-2、一对多处理："><a href="#10-2、一对多处理：" class="headerlink" title="10.2、一对多处理："></a>10.2、一对多处理：</h2><ul>
<li><p>sql查询语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select t.id,t.name tname,s.id sid,s.name sname from student s,teacher t where s.tid = t.id;</span><br></pre></td></tr></table></figure></li>
<li><p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTid</span><span class="params">(<span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tid = tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, tid=&quot;</span> + tid +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//一个老师拥有多个学生</span></span><br><span class="line">    Student students;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(<span class="keyword">int</span> id, String name, Student students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudents</span><span class="params">(Student students)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.students = students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, students=&quot;</span> + students +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TeacherMapper.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--结果嵌套查询--&gt;</span><br><span class="line">   &lt;select id=<span class="string">&quot;getTeacher&quot;</span> resultMap=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span><br><span class="line">       select t.id,t.name,s.id,s.name,s.tid from student s,teacher t</span><br><span class="line">       where s.tid = t.id and t.id = #&#123;id&#125;;</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line">   &lt;resultMap id=<span class="string">&quot;TeacherStudent&quot;</span> type=<span class="string">&quot;com.aaron.pojo.Teacher&quot;</span>&gt;</span><br><span class="line">       &lt;result property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;t.id&quot;</span>/&gt;</span><br><span class="line">       &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;t.name&quot;</span>/&gt;</span><br><span class="line">       &lt;collection property=<span class="string">&quot;students&quot;</span> ofType=<span class="string">&quot;com.aaron.pojo.Student&quot;</span>&gt;</span><br><span class="line">           &lt;result property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;s.id&quot;</span>/&gt;</span><br><span class="line">           &lt;result property=<span class="string">&quot;name&quot;</span> column=<span class="string">&quot;s.name&quot;</span>/&gt;</span><br><span class="line">           &lt;result property=<span class="string">&quot;tid&quot;</span> column=<span class="string">&quot;s.tid&quot;</span>/&gt;</span><br><span class="line">       &lt;/collection&gt;</span><br><span class="line">   &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-3、小结："><a href="#10-3、小结：" class="headerlink" title="10.3、小结："></a>10.3、小结：</h2><ol>
<li>关联-associate【多对一】</li>
<li>集合-collation【一对多】</li>
<li>javaType和ofType</li>
</ol>
<h1 id="11、动态SQL"><a href="#11、动态SQL" class="headerlink" title="11、动态SQL"></a>11、动态SQL</h1><p>什么是动态SQL：动态Sql就是指根据不同的条件生成不同的SQL语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `blog`(</span><br><span class="line">`id` VARCHAR(<span class="number">50</span>) NOT NULL COMMENT <span class="string">&#x27;博客id&#x27;</span>,</span><br><span class="line">`title` VARCHAR(<span class="number">100</span>) NOT NULL COMMENT <span class="string">&#x27;博客标题&#x27;</span>,</span><br><span class="line">`author` VARCHAR(<span class="number">30</span>) NOT NULL COMMENT <span class="string">&#x27;博客作者&#x27;</span>,</span><br><span class="line">`create_time` DATETIME NOT NULL COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">`views` INT(<span class="number">30</span>) NOT NULL COMMENT <span class="string">&#x27;浏览量&#x27;</span></span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<h2 id="11-1、if语句："><a href="#11-1、if语句：" class="headerlink" title="11.1、if语句："></a>11.1、if语句：</h2><ul>
<li><p>BlogMapper.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.aaron.dao.BlogMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;getBlogList&quot;</span> parameterType=<span class="string">&quot;map&quot;</span> resultType=<span class="string">&quot;com.aaron.pojo.Blog&quot;</span>&gt;</span><br><span class="line">        select * from mybatistest.blog where <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">        &lt;if test=&quot;title != null&quot;&gt;and title = #&#123;title&#125;&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;author != null&quot;&gt;and author = #&#123;author&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.pojo.Blog;</span><br><span class="line"><span class="keyword">import</span> com.aaron.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper blogMapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>);</span><br><span class="line">        List&lt;Blog&gt; blogList = blogMapper.getBlogList(map);</span><br><span class="line">        <span class="keyword">for</span> (Blog blog : blogList) &#123;</span><br><span class="line">            System.out.println(blog);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-2、常用标签："><a href="#11-2、常用标签：" class="headerlink" title="11.2、常用标签："></a>11.2、常用标签：</h2><ul>
<li><p>choose、when、otherwise：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">     resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  &lt;choose&gt;</span><br><span class="line">    &lt;when test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;when test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/when&gt;</span><br><span class="line">    &lt;otherwise&gt;</span><br><span class="line">      AND featured = <span class="number">1</span></span><br><span class="line">    &lt;/otherwise&gt;</span><br><span class="line">  &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>trim、where、set：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">     resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  &lt;where&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;state != null&quot;</span>&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;</span><br><span class="line">      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;trim prefix=<span class="string">&quot;WHERE&quot;</span> prefixOverrides=<span class="string">&quot;AND |OR &quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;</span><br><span class="line">    </span><br><span class="line">&lt;trim prefix=<span class="string">&quot;SET&quot;</span> suffixOverrides=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;    </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-3、sql片段："><a href="#11-3、sql片段：" class="headerlink" title="11.3、sql片段："></a>11.3、sql片段：</h2><p>我们会将一些公用的片段抽取出来，实现复用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;sql id=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span>&gt;.....</span><br><span class="line">&lt;/sql&gt;</span><br><span class="line">        </span><br><span class="line">底下引用时，只需要使用&lt;include refid=<span class="string">&quot;&quot;</span>&gt;标签就可以导入该片段。</span><br></pre></td></tr></table></figure>

<h2 id="11-4、foreach："><a href="#11-4、foreach：" class="headerlink" title="11.4、foreach："></a>11.4、foreach：</h2><ul>
<li>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPostIn&quot;</span> resultType=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=<span class="string">&quot;item&quot;</span> index=<span class="string">&quot;index&quot;</span> collection=<span class="string">&quot;list&quot;</span></span><br><span class="line">      open=<span class="string">&quot;(&quot;</span> separator=<span class="string">&quot;,&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h1 id="12、缓存"><a href="#12、缓存" class="headerlink" title="12、缓存"></a>12、缓存</h1><blockquote>
<p>查询：连接数据库耗资源。一次查询的结果，给他暂存在一个可以直接取到的地方——》内存，缓存。我们再次查到相同数据的时候，直接走缓存，就不用走数据库了。</p>
<p>参考文档：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache</a></p>
</blockquote>
<p><img src="http://cdn.rongshen2020.com/20726a22.png" alt="image-20200726094620034"></p>
<p><img src="http://cdn.rongshen2020.com/20726a23.png" alt="image-20200726094637092"></p>
<h2 id="12-1、一级缓存："><a href="#12-1、一级缓存：" class="headerlink" title="12.1、一级缓存："></a>12.1、一级缓存：</h2><h2 id="12-2、二级缓存："><a href="#12-2、二级缓存：" class="headerlink" title="12.2、二级缓存："></a>12.2、二级缓存：</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p>
<p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<p><img src="http://cdn.rongshen2020.com/20726a24.png" alt="image-20200726103118359"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cache&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="12-3、自定义缓存："><a href="#12-3、自定义缓存：" class="headerlink" title="12.3、自定义缓存："></a>12.3、自定义缓存：</h2><p>EhCache 是一个<code>纯Java</code>的进程内<code>缓存框架</code>，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有<code>内存</code>和<code>磁盘</code>存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。</p>
<p>介绍链接：<a href="https://www.jianshu.com/p/154c82073b07">https://www.jianshu.com/p/154c82073b07</a></p>
<h2 id="12-4、redis做缓存："><a href="#12-4、redis做缓存：" class="headerlink" title="12.4、redis做缓存："></a>12.4、redis做缓存：</h2>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud alibaba之sentinel流量控制、熔断降级、系统负载</title>
    <url>/2020/10/04/springcloud-alibaba%E4%B9%8Bsentinel%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>springcloud学习笔记，第十三章，Sentinel流量控制、熔断降级、系统负载</p>
</blockquote>
<span id="more"></span>



<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p><strong>Sentinel哨兵=Hystrix豪猪</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020104a1.png"></p>
<h3 id="Sentinel-是什么？"><a href="#Sentinel-是什么？" class="headerlink" title="Sentinel 是什么？"></a>Sentinel 是什么？</h3><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h3 id="Sentinel-的主要特性："><a href="#Sentinel-的主要特性：" class="headerlink" title="Sentinel 的主要特性："></a>Sentinel 的主要特性：</h3><p><img src="http://cdn.rongshen2020.com/2020104a2.png"></p>
<h3 id="Sentinel-的开源生态："><a href="#Sentinel-的开源生态：" class="headerlink" title="Sentinel 的开源生态："></a>Sentinel 的开源生态：</h3><p><img src="http://cdn.rongshen2020.com/2020104a3.png"></p>
<h2 id="安装sentinel："><a href="#安装sentinel：" class="headerlink" title="安装sentinel："></a>安装sentinel：</h2><p>sentinel由两部分组成：</p>
<ul>
<li>后台和前台8080</li>
</ul>
<p>Sentinel 的使用可以分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 7 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持（见 <a href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D">主流框架适配</a>）。</li>
<li>控制台（Dashboard）：控制台主要负责管理推送规则、监控、集群限流分配管理、机器发现等。</li>
</ul>
<p>安装：<code>java -jar sentinel-dashboard-1.8.0.jar</code></p>
<p>访问：<code>localhost:8080</code>，登录账户和密码都是sentinel。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a4.png"></p>
<h2 id="微服务整合Sentinel："><a href="#微服务整合Sentinel：" class="headerlink" title="微服务整合Sentinel："></a>微服务整合Sentinel：</h2><ol>
<li><p>启动nacos8848成功</p>
<p><img src="http://cdn.rongshen2020.com/2020104a5.png"></p>
</li>
<li><p>新建moudle，<code>cloudalibaba-sentinel-service8401</code></p>
</li>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--SpringCloud ailibaba sentinel --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--openfeign--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #Nacos服务注册中心地址</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080 #配置Sentinel dashboard地址</span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line">            </span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类FlowLimitController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testA&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.info(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;...testB&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动sentinel：</p>
</li>
<li><p>启动微服务8401</p>
</li>
<li><p>启动8401微服务后查看sentinel控制台</p>
<ul>
<li>sentinel采用的是懒加载模式，需要你执行一次访问即可。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020104a6.png"></p>
</li>
</ol>
<h2 id="Sentinel的流控规则："><a href="#Sentinel的流控规则：" class="headerlink" title="Sentinel的流控规则："></a>Sentinel的流控规则：</h2><h3 id="简介：-1"><a href="#简介：-1" class="headerlink" title="简介："></a>简介：</h3><p><img src="http://cdn.rongshen2020.com/2020104a7.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a8.png"></p>
<h3 id="流控模式："><a href="#流控模式：" class="headerlink" title="流控模式："></a>流控模式：</h3><ol>
<li>直接模式，api达到限流条件式时，就直接限流。</li>
<li>关联</li>
<li>链路</li>
</ol>
<h4 id="QPS-直接-快速失败："><a href="#QPS-直接-快速失败：" class="headerlink" title="QPS-直接-快速失败："></a>QPS-直接-快速失败：</h4><p>QPS：每秒请求数。</p>
<p>系统默认的就是<strong>直接快速失败</strong>的模式：这里的单机阈值1就是1秒钟1次。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a9.png"></p>
<p>测试：</p>
<ul>
<li>快速点击访问<code>localhost:8401/testA</code>,结果就是Blocked by Sentinel(flow limiting)，服务限流了。</li>
</ul>
<h4 id="线程数-直接-快速失败："><a href="#线程数-直接-快速失败：" class="headerlink" title="线程数-直接-快速失败："></a>线程数-直接-快速失败：</h4><p>QPS和线程数的区别：请求需要包装在线程里面运行。一个线程从请求开始到请求完成的生命周期里要有时间限制的。</p>
<p>如果在controller里面设置：一个线程睡眠几秒钟。那么就会出现一个窗口处理多个线程的情况，（阈值是一的话）就会出现失败。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a10.png"></p>
<h4 id="关联："><a href="#关联：" class="headerlink" title="关联："></a>关联：</h4><p>当关联的资源达到阈值时，就限流自己。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a11.png"></p>
<p>设置效果：当关联资源/testB的qps阈值超过1时，就限流/testA的rest访问地址，当关联资源到阈值后限制配置好的资源名。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a12.png"></p>
<p>这样运行的结果就是，当模拟并发密集访问testB，运行后会发现testA也挂了。</p>
<h4 id="链路："><a href="#链路：" class="headerlink" title="链路："></a>链路：</h4><p><img src="http://cdn.rongshen2020.com/2020104a13.png"></p>
<p>自己模拟去吧。</p>
<h2 id="流控效果："><a href="#流控效果：" class="headerlink" title="流控效果："></a>流控效果：</h2><h3 id="直接失败："><a href="#直接失败：" class="headerlink" title="直接失败："></a>直接失败：</h3><p>前面已经模拟过了。</p>
<h3 id="预热warm-up："><a href="#预热warm-up：" class="headerlink" title="预热warm up："></a>预热warm up：</h3><p><strong>Warm Up：</strong></p>
<p>Warm Up（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">流量控制 - Warm Up 文档</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/WarmUpFlowDemo.java">WarmUpFlowDemo</a>。</p>
<p><strong>公式：</strong></p>
<p>阈值除以coldFactor(冷加载因子，默认是3)，经过预热时长后才会达到阈值。</p>
<p><strong>例：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020104a14.png"></p>
<p>解释上图：单机阈值是10表示我们一开始设想的是系统的最大并发是10个请求。但是使用warm up流控效果，所以就是10/3（冷加载因子，默认是3）=3，那么就是一开始只让3个并发量，后续再经过5秒的预热时长，慢慢加载到10。 </p>
<p><strong>冷加载因子：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020104a15.png"></p>
<p><strong>应用场景：</strong></p>
<p>如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能会把系统打死。预热方式就是为了保护系统，可以慢慢的把流量放进来，慢慢的把阈值增长到设定的阈值。</p>
<h3 id="排队等待："><a href="#排队等待：" class="headerlink" title="排队等待："></a>排队等待：</h3><p><img src="http://cdn.rongshen2020.com/2020104a16.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a17.png"></p>
<p>匀速排队（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。详细文档可以参考 <a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F">流量控制 - 匀速器模式</a>，具体的例子可以参见 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/PaceFlowDemo.java">PaceFlowDemo</a>。</p>
<p>该方式的作用如下图所示：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a18.png"></p>
<p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p>
<blockquote>
<p>注意：匀速排队模式暂时不支持 QPS &gt; 1000 的场景。</p>
</blockquote>
<h2 id="sentinel降级规则："><a href="#sentinel降级规则：" class="headerlink" title="sentinel降级规则："></a>sentinel降级规则：</h2><h3 id="简介：-2"><a href="#简介：-2" class="headerlink" title="简介："></a>简介：</h3><p><img src="http://cdn.rongshen2020.com/2020104a19.png"></p>
<p>降级策略：1.RT，2.异常比例，3.异常数。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a20.png"></p>
<p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其他的资源而导致级联错误。</p>
<p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都会自动熔断（默认行为是抛出DegradeException）</p>
<p><strong>注意：sentinel的断路器是没有半开状态的！</strong></p>
<p>回顾下hystrix半开状态：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a21.png"></p>
<h3 id="RT："><a href="#RT：" class="headerlink" title="RT："></a>RT：</h3><p>我用的sentinel版本是：1.8.0，RT变为了“慢调用比例”</p>
<ul>
<li>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020104a22.png"></p>
<p>测试：</p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">testD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">     log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置：</p>
<p>表示200毫秒处理一个请求，下一个时间窗口是1秒后。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a23.png"></p>
</li>
<li><p>jmeter压测：</p>
<p>一秒10个请求。</p>
</li>
<li><p>结论：</p>
<p>因为1秒10个请求，那么一个请求就是100毫秒。所以同时满足默认一秒5个线程和处理一个请求时间的双重限制。触发降级。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a24.png"></p>
</li>
</ol>
<h3 id="异常比例："><a href="#异常比例：" class="headerlink" title="异常比例："></a>异常比例：</h3><ul>
<li>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020104a25.png"></p>
<p>测试：</p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testD</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;testD 测试RT&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testD&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置：</p>
<p>要求请求的错误率最大为0.2（20%）。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a26.png"></p>
</li>
<li><p>jmeter：1秒10次请求。</p>
</li>
<li><p>结论：</p>
<p>因为我们的请求就是100%报错，并且每秒请求数大于10次 。所以就会触发降级。</p>
</li>
</ol>
<p><img src="http://cdn.rongshen2020.com/2020104a27.png"></p>
<h3 id="异常数："><a href="#异常数：" class="headerlink" title="异常数："></a>异常数：</h3><ul>
<li>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020104a28.png"></p>
<p>测试：</p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testE&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;testE 测试异常数&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testE 测试异常数&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p>配置：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a29.png"></p>
</li>
<li><p>结论：</p>
<p>访问<code>localhost:8401/testE</code>我们可以看到，第一次访问绝对报错，因为除数不能为0，我们可以看到error窗口，但是达到5次报错之后，进入熔断后降级。</p>
</li>
</ol>
<h2 id="Sentinel热点规则："><a href="#Sentinel热点规则：" class="headerlink" title="Sentinel热点规则："></a>Sentinel热点规则：</h2><h3 id="简介：-3"><a href="#简介：-3" class="headerlink" title="简介："></a>简介：</h3><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p>
<ul>
<li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li>
<li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li>
</ul>
<p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p>
<p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。</p>
<p><strong>之前我们在hytrix中学习过了兜底方法：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020104a30.png"></p>
<h3 id="定义热点规则："><a href="#定义热点规则：" class="headerlink" title="定义热点规则："></a>定义热点规则：</h3><ol>
<li><p>代码</p>
<p>deal_testHotKey()方法就是兜底方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;deal_testHotKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int age = 10/0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//兜底方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deal_testHotKey</span> <span class="params">(String p1, String p2, BlockException exception)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------deal_testHotKey,o(╥﹏╥)o&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a31.png"></p>
<p>上图的解释就是：参数索引就会请求传入参数的索引（默认是从0开始），<strong>此时我们访问/testHotkey并且带上p1参数，才能触发降级方法</strong>。方法testHotKey里面第一个参数只要QPS超过每秒1次。马上降级处理。</p>
</li>
<li><p>测试：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a32.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a33.png"></p>
</li>
</ol>
<h3 id="热点规则中的其他选项："><a href="#热点规则中的其他选项：" class="headerlink" title="热点规则中的其他选项："></a>热点规则中的其他选项：</h3><p><img src="http://cdn.rongshen2020.com/2020104a34.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a35.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a36.png"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><img src="http://cdn.rongshen2020.com/2020104a37.png"></p>
<h2 id="Sentinel系统规则："><a href="#Sentinel系统规则：" class="headerlink" title="Sentinel系统规则："></a>Sentinel系统规则：</h2><p>系统自适应限流：从整体维度对应用入口进行限流</p>
<p>对整体限流,比如设置QPS到达100,这里限流会限制整个系统不可以.这就是粗度的限流。不过我们还是推荐使用之前细粒度的方法。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a38.png"></p>
<p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p>
<p>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<p>这种的系统规则主要做总控，使用注意下，也不是太多。</p>
<h2 id="SentinelResource注解："><a href="#SentinelResource注解：" class="headerlink" title="@SentinelResource注解："></a>@SentinelResource注解：</h2><h3 id="按资源名称限流-后续处理："><a href="#按资源名称限流-后续处理：" class="headerlink" title="按资源名称限流+后续处理："></a>按资源名称限流+后续处理：</h3><ol>
<li><p>启动Nacos和Sentinel成功。</p>
</li>
<li><p>修改<code>cloudalibaba-sentinel-service8401</code></p>
</li>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8401</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span></span><br><span class="line">        port: 8719  #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Controller：</p>
<p>资源名就是主机里面Value的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/byResource&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">byResource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按资源名称限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial001&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handleException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,exception.getClass().getCanonicalName()+<span class="string">&quot;\t 服务不可用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置资源限流规则：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a39.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a40.png"></p>
<p>表示1秒钟内查询次数大于1，就跑到我们自定义的处理限流。</p>
</li>
<li><p>测试：</p>
<ul>
<li>1秒钟点击1下，ok。</li>
<li>超多上述问题，疯狂点击，返回自己定义的限流处理信息，限流发送。</li>
</ul>
<p><img src="http://cdn.rongshen2020.com/2020104a41.png"></p>
</li>
<li><p>额外问题：</p>
<ul>
<li>此时关闭微服务8401查看</li>
<li>Sentinel控制台，流控规则消失了？</li>
</ul>
</li>
</ol>
<h3 id="按照url地址限流-后续处理："><a href="#按照url地址限流-后续处理：" class="headerlink" title="按照url地址限流+后续处理："></a>按照url地址限流+后续处理：</h3><p>通过访问的URL来限流，会返回sentinel自带默认的限流处理信息。</p>
<ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/byUrl&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;byUrl&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">byUrl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按url限流测试OK&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial002&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有兜底方法就会使用系统默认的。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a42.png"></p>
</li>
<li><p>访问：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a43.png"></p>
</li>
</ol>
<h3 id="上面兜底方案面临的问题："><a href="#上面兜底方案面临的问题：" class="headerlink" title="上面兜底方案面临的问题："></a>上面兜底方案面临的问题：</h3><p><img src="http://cdn.rongshen2020.com/2020104a44.png"></p>
<h3 id="客户自定义限流处理逻辑："><a href="#客户自定义限流处理逻辑：" class="headerlink" title="客户自定义限流处理逻辑："></a>客户自定义限流处理逻辑：</h3><ol>
<li><p>创建CustomerBlockHandler类用于自定义限流处理逻辑</p>
</li>
<li><p>自定义限流处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aaron.alibaba.springcloud.myhandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aaron.springcloud.entities.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title">handlerException2</span><span class="params">(BlockException exception)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义,global handlerException----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RateLimitController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rateLimit/customerBlockHandler&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;customerBlockHandler&quot;,</span></span><br><span class="line"><span class="meta">        blockHandlerClass = CustomerBlockHandler.class,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;handlerException2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult <span class="title">customerBlockHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;按客戶自定义&quot;</span>,<span class="keyword">new</span> Payment(<span class="number">2020L</span>,<span class="string">&quot;serial003&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动微服务先调用一次</p>
</li>
<li><p>Sentinel控制台配置。配置下限流规则。</p>
</li>
<li><p>测试后我们自定义的出来了</p>
</li>
<li><p>进一步说明</p>
<p><img src="http://cdn.rongshen2020.com/2020104a45.png"></p>
</li>
</ol>
<h3 id="更多注解属性说明："><a href="#更多注解属性说明：" class="headerlink" title="更多注解属性说明："></a>更多注解属性说明：</h3><p>官网有更详细的解释。</p>
<h2 id="服务熔断："><a href="#服务熔断：" class="headerlink" title="服务熔断："></a>服务熔断：</h2><p>sentinel整合ribbon+openFeign+fallback。</p>
<p>记得启动nacos和sentinel。</p>
<h3 id="Sentinel服务熔断整合Ribbon："><a href="#Sentinel服务熔断整合Ribbon：" class="headerlink" title="Sentinel服务熔断整合Ribbon："></a>Sentinel服务熔断整合Ribbon：</h3><p><img src="http://cdn.rongshen2020.com/2020104a46.png"></p>
<ol>
<li><p>启动nacos和sentinel</p>
</li>
<li><p>提供者9003和9004</p>
<ol>
<li><p>新建两个模块。</p>
<ol>
<li><code>cloudalibaba-provider-payment9003</code></li>
<li><code>cloudalibaba-provider-payment9004</code></li>
</ol>
</li>
<li><p>POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--SpringCloud ailibaba nacos --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span><br><span class="line">        &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- SpringBoot整合Web组件 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--日常通用jar包配置--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9003</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-payment-provider</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:8848 #配置Nacos地址</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, Payment&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>,<span class="keyword">new</span> Payment(<span class="number">1L</span>,<span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>,<span class="keyword">new</span> Payment(<span class="number">2L</span>,<span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>,<span class="keyword">new</span> Payment(<span class="number">3L</span>,<span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        Payment payment = hashMap.get(id);</span><br><span class="line">        CommonResult&lt;Payment&gt; result = <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;from mysql,serverPort:  &quot;</span>+serverPort,payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试地址：<code>localhost:9003/paymentSQL/1</code></p>
</li>
</ol>
</li>
<li><p>消费者84</p>
<ol>
<li><p><code>cloudalibaba-consumer-nacos-order84</code></p>
</li>
<li><p>POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span></span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line"></span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:<span class="comment">//nacos-payment-provider</span></span><br></pre></td></tr></table></figure></li>
<li><p>主启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个CircleBreakerController:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;) //没有配置</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;) //fallback只负责业务异常</span></span><br><span class="line">    <span class="comment">//@SentinelResource(value = &quot;fallback&quot;,blockHandler = &quot;blockHandler&quot;) //blockHandler只负责sentinel控制台配置违规</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,</span></span><br><span class="line"><span class="meta">            exceptionsToIgnore = &#123;IllegalArgumentException.class&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id, CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//fallback</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,Throwable e)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;兜底异常handlerFallback,exception内容  &quot;</span>+e.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//blockHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">blockHandler</span><span class="params">(<span class="meta">@PathVariable</span>  Long id,BlockException blockException)</span> </span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment(id,<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">445</span>,<span class="string">&quot;blockHandler-sentinel限流,无此流水: blockException  &quot;</span>+blockException.getMessage(),payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：修改后请重启微服务，热部署对java代码生效及时，但对于@SentinelResource注解内属性，有时效果不好。</p>
</li>
<li><p>目的：</p>
<ol>
<li><p>fallback管运行异常</p>
</li>
<li><p>blockHandler管配置违规，在Sentinel界面去配置的。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Sentinel服务熔断无配置："><a href="#Sentinel服务熔断无配置：" class="headerlink" title="Sentinel服务熔断无配置："></a>Sentinel服务熔断无配置：</h3><p>测试地址：<code>localhost:84/consumer/fallback/1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleBreakerController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_URL = <span class="string">&quot;http://nacos-payment-provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/consumer/fallback/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">fallback</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CommonResult&lt;Payment&gt; result = restTemplate.getForObject(SERVICE_URL + <span class="string">&quot;/paymentSQL/&quot;</span>+id,CommonResult.class,id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;IllegalArgumentException,非法参数异常....&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException (<span class="string">&quot;NullPointerException,该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>既没有熔断也没有降级：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a47.png"></p>
<h3 id="Sentinel服务熔断只配置fallback："><a href="#Sentinel服务熔断只配置fallback：" class="headerlink" title="Sentinel服务熔断只配置fallback："></a>Sentinel服务熔断只配置fallback：</h3><p><img src="http://cdn.rongshen2020.com/2020104a48.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a49.png"></p>
<h3 id="Sentinel服务熔断只配置blockHandler："><a href="#Sentinel服务熔断只配置blockHandler：" class="headerlink" title="Sentinel服务熔断只配置blockHandler："></a>Sentinel服务熔断只配置blockHandler：</h3><p>blockHandler只负责sentinel控制台的配置违规。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a50.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a51.png"></p>
<p>那么运行异常，就不会管了。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a52.png"></p>
<p>但是我快速点击，启动sentinel的配置作用，那么就会报：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a53.png"></p>
<h3 id="Sentinel服务熔断配置fallback-blockHandler："><a href="#Sentinel服务熔断配置fallback-blockHandler：" class="headerlink" title="Sentinel服务熔断配置fallback+blockHandler："></a>Sentinel服务熔断配置fallback+blockHandler：</h3><p>运行报错会出现兜底方法。</p>
<p>流控也会出现。</p>
<p>流控的作用大于兜底方法，也就是blockHandler&gt;fallback</p>
<p><img src="http://cdn.rongshen2020.com/2020104a54.png"></p>
<h3 id="Sentinel服务熔断exceptionsToIgnore："><a href="#Sentinel服务熔断exceptionsToIgnore：" class="headerlink" title="Sentinel服务熔断exceptionsToIgnore："></a>Sentinel服务熔断exceptionsToIgnore：</h3><p><img src="http://cdn.rongshen2020.com/2020104a55.png"></p>
<h3 id="Sentinel服务熔断OpenFeign："><a href="#Sentinel服务熔断OpenFeign：" class="headerlink" title="Sentinel服务熔断OpenFeign："></a>Sentinel服务熔断OpenFeign：</h3><ol>
<li><p>修改84模块</p>
</li>
<li><p>POM</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">84</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: nacos-order-consumer</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: localhost:<span class="number">8848</span></span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:<span class="number">8080</span></span><br><span class="line">        port: <span class="number">8719</span></span><br><span class="line"></span><br><span class="line">service-url:</span><br><span class="line">  nacos-user-service: http:<span class="comment">//nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line">#对Feign的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: <span class="keyword">true</span></span><br></pre></td></tr></table></figure></li>
<li><p>业务类</p>
<p>带@FeignClient注解的业务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PaymentFallbackService实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">44444</span>,<span class="string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="keyword">new</span> Payment(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenFeign</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试<code>localhost:84/consumer/openfeign/1</code></p>
<p>测试84调用9003，此时故意关闭9003微服务提供者，看84消费侧自动降级，不会被耗死。</p>
</li>
</ol>
<p><strong>熔断框架的比较：</strong></p>
<p><img src="http://cdn.rongshen2020.com/2020104a56.png"></p>
<h2 id="Sentinel持久化规则："><a href="#Sentinel持久化规则：" class="headerlink" title="Sentinel持久化规则："></a>Sentinel持久化规则：</h2><p>默认规则是临时存储的，重启sentinel就会消失。</p>
<p><img src="http://cdn.rongshen2020.com/2020104a57.png"></p>
<p><strong>这里以之前的8401为案例进行修改:</strong></p>
<ol>
<li><p>修改8401的POM：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringCloud ailibaba sentinel-datasource-nacos 持久化需要用到--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件：添加：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a58.png"></p>
<p><strong>实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下</strong>。</p>
<p> 这里没有指定namespace, 但是是可以指定的。</p>
<p><strong>注意,这里的dataid要与8401的服务名一致</strong></p>
</li>
<li><p>在nacos中创建一个配置文件，dataId就是上面配置文件中指定的：</p>
<p><img src="http://cdn.rongshen2020.com/2020104a59.png"></p>
<p><img src="http://cdn.rongshen2020.com/2020104a60.png"></p>
</li>
<li><p>启动8401：</p>
</li>
<li><p>关闭8401：</p>
</li>
<li><p>此时重启8401，如果sentinel又可以正常取到规则，那么证明持久化成功。可以看到，又重新出现了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>springCloud alibaba</tag>
      </tags>
  </entry>
</search>
